diff --git a/arch/arm64/boot/dts/renesas/r9a09g057.dtsi b/arch/arm64/boot/dts/renesas/r9a09g057.dtsi
index f5f79ad..46bd9ad 100644
--- a/arch/arm64/boot/dts/renesas/r9a09g057.dtsi
+++ b/arch/arm64/boot/dts/renesas/r9a09g057.dtsi
@@ -2269,6 +2269,18 @@
 				};
 			};
 		};
+
+		drpai0: drpai@16800000 {
+			compatible = "renesas,rzv2h-drpai";
+			reg = <0 0x17000000 0 0x1000000>,
+				<0 0x16800000 0 0x400000>;
+			interrupts = <GIC_SPI 914 IRQ_TYPE_LEVEL_HIGH>,
+				<GIC_SPI 915 IRQ_TYPE_LEVEL_HIGH>,
+				<GIC_SPI 916 IRQ_TYPE_LEVEL_HIGH>,
+				<GIC_SPI 917 IRQ_TYPE_LEVEL_HIGH>;
+			resets = <&cpg R9A09G057_DRPAI_ARESETN>;
+			status = "disabled";
+		};
 	};
 
 	thermal-zones {
diff --git a/arch/arm64/boot/dts/renesas/r9a09g057h4-dev.dts b/arch/arm64/boot/dts/renesas/r9a09g057h4-dev.dts
index 0e89ef4..dd06a26 100644
--- a/arch/arm64/boot/dts/renesas/r9a09g057h4-dev.dts
+++ b/arch/arm64/boot/dts/renesas/r9a09g057h4-dev.dts
@@ -661,3 +661,9 @@
 		};
 	};
 };
+
+&drpai0 {
+	memory-region = <&drp_reserved>;
+	image-memory-region = <&image_buf0>;
+	status = "okay";
+};
diff --git a/arch/arm64/boot/dts/renesas/r9a09g057h4-evk-alpha.dts b/arch/arm64/boot/dts/renesas/r9a09g057h4-evk-alpha.dts
index b0c6159..e1bb04d 100644
--- a/arch/arm64/boot/dts/renesas/r9a09g057h4-evk-alpha.dts
+++ b/arch/arm64/boot/dts/renesas/r9a09g057h4-evk-alpha.dts
@@ -1294,3 +1294,9 @@
 &ssi4 {
 	shared-pin;
 };
+
+&drpai0 {
+	memory-region = <&drp_reserved>;
+	image-memory-region = <&image_buf0>;
+	status = "okay";
+};
diff --git a/arch/arm64/boot/dts/renesas/r9a09g057h4-evk-ver1.dts b/arch/arm64/boot/dts/renesas/r9a09g057h4-evk-ver1.dts
index 54892e5..627ac27 100644
--- a/arch/arm64/boot/dts/renesas/r9a09g057h4-evk-ver1.dts
+++ b/arch/arm64/boot/dts/renesas/r9a09g057h4-evk-ver1.dts
@@ -1110,3 +1110,9 @@
 &adc {
 	status = "okay";
 };
+
+&drpai0 {
+	memory-region = <&drp_reserved>;
+	image-memory-region = <&image_buf0>;
+	status = "okay";
+};
diff --git a/drivers/Kconfig b/drivers/Kconfig
index dcecc9f..4ac778b 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -235,4 +235,6 @@ source "drivers/interconnect/Kconfig"
 source "drivers/counter/Kconfig"
 
 source "drivers/most/Kconfig"
+
+source "drivers/drpai/Kconfig"
 endmenu
diff --git a/drivers/Makefile b/drivers/Makefile
index 5762280..354b8fd 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -189,3 +189,4 @@ obj-$(CONFIG_GNSS)		+= gnss/
 obj-$(CONFIG_INTERCONNECT)	+= interconnect/
 obj-$(CONFIG_COUNTER)		+= counter/
 obj-$(CONFIG_MOST)		+= most/
+obj-$(CONFIG_DRPAI)		+= drpai/
diff --git b/drivers/drpai/Kconfig b/drivers/drpai/Kconfig
new file mode 100644
index 0000000..ccbf90a
--- /dev/null
+++ b/drivers/drpai/Kconfig
@@ -0,0 +1,14 @@
+#
+# DRP-AI subsystem configuration
+#
+
+menu "DRP-AI/DRP support"
+
+config DRPAI
+	bool "DRP-AI support"
+	default y
+	help
+	  DRP-AI is a peripheral hardware that accelerates AI.
+	  If you want DRP-AI support, you should say Y here.
+
+endmenu
diff --git b/drivers/drpai/Makefile b/drivers/drpai/Makefile
new file mode 100644
index 0000000..5982e89
--- /dev/null
+++ b/drivers/drpai/Makefile
@@ -0,0 +1,6 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Makefile for DRP-AI/DRP.
+#
+
+obj-$(CONFIG_DRPAI)	+= drpai-core.o drpai-if.o
diff --git b/drivers/drpai/drpai-core.c b/drivers/drpai/drpai-core.c
new file mode 100644
index 0000000..3bb7694
--- /dev/null
+++ b/drivers/drpai/drpai-core.c
@@ -0,0 +1,1696 @@
+/*
+ * Driver for the Renesas RZ/V2H DRP unit
+ *
+ * Copyright (C) 2023 Renesas Electronics Corporation
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifdef __KERNEL__
+#include <linux/types.h>  /* for stdint */
+#include <asm/io.h>       /* for ioread/iowrite */
+#include <linux/delay.h>  /* for mdelay */
+#include <linux/module.h> /* for MODULE macro */
+#else
+#include <stdint.h>
+#endif
+
+#include "drpai-core.h"
+#include "drpai-reg.h"
+
+//------------------------------------------------------------------------------------------------------------------
+// Parameter setting
+//------------------------------------------------------------------------------------------------------------------
+#define DRP_DFCENA                  (0x1)
+#define DRP_DIVFIX                  (0x02)
+#define DRP_MIN_DIVFIX              (0x02)
+#define DRP_ADDR_RELOCATABLE_ENA    (0x0)
+#define AIMAC_DIVFIX                (0x01)
+#define AIMAC_ADDR_RELOCATABLE_ENA  (0x0)
+#define DRP_ECC_ENA                 (0x1)
+#define DRP_CDCC_PRERE              (0x1)
+#define DRP_CDCC_HFCFGW             (0x1)
+#define INIT_SET_BP_MODE            (0)
+#define INIT_SET_BP_CSTART          (0)
+#define INIT_SET_BP_ITR             (0)
+#define INIT_SET_BP_INST            (0)
+#define STP_ERRINT_STATUS_REG_NUM   (5)
+#define AIMAC_ERRINT_STATUS_REG_NUM (8)
+#define EXDx_ERRINT_STATUS_REG_NUM  (4)
+
+//------------------------------------------------------------------------------------------------------------------
+// Do not change
+//------------------------------------------------------------------------------------------------------------------
+#define DEF_DRP_SIDE                (0)
+#define DEF_AIMAC_SIDE              (1)
+
+
+//------------------------------------------------------------------------------------------------------------------
+// for Linux
+//------------------------------------------------------------------------------------------------------------------
+#ifndef __KERNEL__
+#define ioread32(addr)              (*((volatile uint32_t *)(addr)))
+#define ioread16(addr)              (*((volatile uint16_t *)(addr)))
+#define ioread8(addr)               (*((volatile uint8_t *)(addr)))
+#define iowrite32(value, addr)      (*((volatile uint32_t *)(addr)) = (uint32_t)(value))
+#define iowrite16(value, addr)      (*((volatile uint16_t *)(addr)) = (uint16_t)(value))
+#define iowrite8(value, addr)       (*((volatile uint8_t *)(addr))  = (uint8_t)(value))
+#endif
+
+//------------------------------------------------------------------------------------------------------------------
+// Prototype
+//------------------------------------------------------------------------------------------------------------------
+static void set_drpclkgen_freq(addr_t drp_base_addr, uint32_t bit_divfix, uint32_t bit_dfcena);
+static void stop_mclkgen(addr_t aimac_base_addr);
+static void start_drp_clk(addr_t drp_base_addr);
+static void stop_drp_clk(addr_t drp_base_addr);
+static void start_aimac_clk(addr_t aimac_base_addr);
+static void stop_aimac_clk(addr_t aimac_base_addr);
+static void disable_drp_swreset(addr_t drp_base_addr);
+static void enable_drp_swreset(addr_t drp_base_addr);
+static void disable_aimac_swreset(addr_t aimac_base_addr);
+static void enable_aimac_swreset(addr_t aimac_base_addr);
+static void aimac_inidividual_setting(addr_t aimac_base_addr);
+static void enable_addr_relocatable_func(addr_t drp_base_addr, addr_t aimac_base_addr, uint8_t* tbl);
+static void enable_addr_relocatable(addr_t addr, uint8_t* tbl);
+static void disable_addr_relocatable_func(addr_t drp_base_addr, addr_t aimac_base_addr);
+static void disable_addr_relocatable(addr_t addr);
+static int32_t stop_desc_prefetch(addr_t dmactl_addr);
+#if 0 /* for POC3N */
+static void set_synctbl_all1(addr_t synctbl_addr);
+#endif
+static int32_t dma_stop(addr_t dmactl_addr);
+static void start_drp_dmac(addr_t drp_base_addr);
+static int32_t stop_drp_dmac(addr_t drp_base_addr);
+static int32_t stop_drp_dmacw(addr_t drp_base_addr);
+static void start_aimac_dmac(addr_t aimac_base_addr);
+static int32_t stop_aimac_dmac(addr_t aimac_base_addr);
+static void disable_drp_intmask(addr_t drp_base_addr);
+static void enable_drp_intmask(addr_t drp_base_addr);
+static void disable_aimac_intmask(addr_t aimac_base_addr);
+static void drp_bootseq(addr_t drp_base_addr, uint8_t *drp_addr_relocatable_tbl);
+static void aimac_bootseq(addr_t aimac_base_addr, uint8_t *aimac_addr_relocatable_tbl);
+static void set_drp_desc(addr_t drp_base_addr, uint64_t drp_desc_addr);
+static void set_aimac_desc(addr_t aimac_base_addr, uint64_t cmd_desc_addr, uint64_t param_desc_addr);
+static void start_prefetch_drp(addr_t drp_base_addr);
+static void start_prefetch_aimac(addr_t aimac_base_addr);
+static int32_t stop_prefetch_drp(addr_t drp_base_addr);
+static int32_t stop_prefetch_aimac(addr_t aimac_base_addr);
+static int32_t drp_finalize(addr_t drp_base_addr);
+static int32_t aimac_finalize(addr_t aimac_base_addr);
+
+static void set_drp_maxfreq(addr_t drp_base_addr, uint32_t mindiv);
+static void set_aimac_freq(addr_t aimac_base_addr, uint32_t divfix);
+
+static int32_t loop_w(addr_t raddr, uint32_t exp_data, uint32_t mask);
+static int32_t check_reg(addr_t raddr, uint32_t exp, uint32_t mask0, uint32_t mask1);
+static void cpg_set(addr_t addr, int32_t bit, uint32_t val);
+static int32_t cpg_check(addr_t addr, int32_t bit, uint32_t val);
+#ifndef __KERNEL__
+static void mdelay(uint32_t msecs);
+#endif
+
+const static uint32_t stp_errint_status_reg_tbl[STP_ERRINT_STATUS_REG_NUM] =
+{
+    DRP_ERRINT_STATUS_ADDR, IDIF_EINT_ADDR, ODIF_EINT_ADDR, IDMAC_INTSE_ADDR, ODMAC_INTSE_ADDR,
+};
+
+const static char* stp_errint_status_reg_name_tbl[STP_ERRINT_STATUS_REG_NUM] =
+{
+    "DRP_ERRINT_STATUS","IDIF_EINT", "ODIF_EINT", "IDMAC_INTSE", "ODMAC_INTSE",
+};
+
+const static uint32_t aimac_errint_status_reg_tbl[AIMAC_ERRINT_STATUS_REG_NUM] =
+{
+    AID0_IDIF_EINT_ADDR, AID0_IDIF2_EINT_DSC_ADDR, AID0_IDMAC_INTSE_ADDR, AID1_IDIF_EINT_ADDR,
+    AID1_IDMAC_INTSE_ADDR, PRAM_INT_ADDR, FMBUF_ERR_STS_ADDR, MACCTL_ERR_STS_ADDR,
+};
+
+const static char* aimac_errint_status_reg_name_tbl[AIMAC_ERRINT_STATUS_REG_NUM] =
+{
+    "AID0_IDIF_EINT", "AID0_IDIF2_EINT_DSC", "AID0_IDMAC_INTSE", "AID1_IDIF_EINT",
+    "AID1_IDMAC_INTSE", "PRAM_INT", "FMBUF_ERR_STS", "MACCTL_ERR_STS",
+};
+
+const static uint32_t exd0_errint_status_reg_tbl[EXDx_ERRINT_STATUS_REG_NUM] =
+{
+    EXD0_IDIF_BADDR + IDIF_EINT_REG, EXD0_ODIF_BADDR + ODIF_EINT_REG, EXD0_IDMAC_INTSE_ADDR, EXD0_ODMAC_INTSE_ADDR,
+};
+
+const static char* exd0_errint_status_reg_name_tbl[EXDx_ERRINT_STATUS_REG_NUM] =
+{
+    "EXD0_IDIF_EINT", "EXD0_ODIF_EINT", "EXD0_IDMAC_INTSE", "EXD0_ODMAC_INTSE",
+};
+
+const static uint32_t exd1_errint_status_reg_tbl[EXDx_ERRINT_STATUS_REG_NUM] =
+{
+    EXD1_IDIF_BADDR + IDIF_EINT_REG, EXD1_ODIF_BADDR + ODIF_EINT_REG, EXD1_IDMAC_INTSE_ADDR, EXD1_ODMAC_INTSE_ADDR,
+};
+
+const static char* exd1_errint_status_reg_name_tbl[EXDx_ERRINT_STATUS_REG_NUM] =
+{
+    "EXD1_IDIF_EINT", "EXD1_ODIF_EINT", "EXD1_IDMAC_INTSE", "EXD1_ODMAC_INTSE",
+};
+
+//------------------------------------------------------------------------------------------------------------------
+// IF functions
+//------------------------------------------------------------------------------------------------------------------
+void R_DRPAI_DRP_Open(addr_t drp_base_addr, int32_t ch)
+{
+    drp_bootseq(drp_base_addr, 0);
+}
+
+void R_DRPAI_DRP_Start(addr_t drp_base_addr, int32_t ch, uint64_t desc)
+{
+    set_drp_desc(drp_base_addr, desc);
+    start_prefetch_drp(drp_base_addr);
+}
+
+int32_t R_DRPAI_DRP_Stop(addr_t drp_base_addr, int32_t ch)
+{
+    int32_t ret = R_DRPAI_SUCCESS;
+
+    if (0 != stop_prefetch_drp(drp_base_addr))
+    {
+        ret = R_DRPAI_ERR_STOP;
+        goto end;
+    }
+
+    goto end;
+
+end:
+    return ret;
+}
+
+int32_t R_DRPAI_DRP_SetMaxFreq(addr_t drp_base_addr, int32_t ch, uint32_t mindiv)
+{
+    int32_t ret = R_DRPAI_SUCCESS;
+
+    if ((2 <= mindiv) && (127 >= mindiv))
+    {
+        set_drp_maxfreq(drp_base_addr, mindiv);
+    }
+    else
+    {
+        ret = R_DRPAI_ERR_INVALID_ARG;
+    }
+
+    return ret;
+}
+
+int32_t R_DRPAI_DRP_EnableAddrReloc(addr_t drp_base_addr, uint8_t* tbl)
+{
+    int32_t ret = R_DRPAI_SUCCESS;
+
+    if (0 != tbl)
+    {
+        enable_addr_relocatable_func(drp_base_addr, 0, tbl);
+    }
+    else
+    {
+        ret = R_DRPAI_ERR_INVALID_ARG;
+    }
+
+    return ret;
+}
+
+void R_DRPAI_DRP_DisableAddrReloc(addr_t drp_base_addr)
+{
+    disable_addr_relocatable_func(drp_base_addr, 0);
+}
+
+int32_t R_DRPAI_DRP_Reset(addr_t drp_base_addr, int32_t ch)
+{
+    int32_t ret = R_DRPAI_SUCCESS;
+
+    if (0 != stop_prefetch_drp(drp_base_addr))
+    {
+        ret = R_DRPAI_ERR_RESET;
+        goto end;
+    }
+    if (0 != drp_finalize(drp_base_addr))
+    {
+        ret = R_DRPAI_ERR_RESET;
+        goto end;
+    }
+
+    goto end;
+
+end:
+    return ret;
+}
+
+void R_DRPAI_DRP_Errint(addr_t drp_base_addr, addr_t aimac_base_addr, int32_t ch)
+{
+    volatile uint32_t dscc_pamon;
+    volatile uint32_t exd0_dscc_pamon;
+    volatile uint32_t aid0_dscc_pamon;
+    volatile uint32_t stpc_errint_sts;
+    uint32_t index;
+    volatile uint32_t error_status;
+    volatile uint32_t dummy;
+
+    printk(KERN_ERR "DRP Error Interrupt\n");
+
+    dscc_pamon      = ioread32(drp_base_addr   + STP_DSCC_BADDR  + DSCC_PAMON_REG);
+    exd0_dscc_pamon = ioread32(aimac_base_addr + EXD0_DSCC_BADDR + DSCC_PAMON_REG);
+    aid0_dscc_pamon = ioread32(aimac_base_addr + AID0_DSCC_BADDR + DSCC_PAMON_REG);
+
+    printk(KERN_ERR "DSCC_PAMON : 0x%08X\n",      dscc_pamon);
+    printk(KERN_ERR "EXD0_DSCC_PAMON : 0x%08X\n", exd0_dscc_pamon);
+    printk(KERN_ERR "AID0_DSCC_PAMON : 0x%08X\n", aid0_dscc_pamon);
+
+    stpc_errint_sts = ioread32(drp_base_addr + STP_STPC_ERRINT_STS);
+    printk(KERN_ERR "STPC_ERRINT_STS : 0x%08X\n", stpc_errint_sts);
+
+    for (index = 0; index < STP_ERRINT_STATUS_REG_NUM; index++)
+    {
+        error_status = ioread32(drp_base_addr + stp_errint_status_reg_tbl[index]);
+        iowrite32(error_status, drp_base_addr + stp_errint_status_reg_tbl[index]);
+        dummy = ioread32(drp_base_addr + stp_errint_status_reg_tbl[index]);
+
+        printk(KERN_ERR "%s : 0x%08X\n", stp_errint_status_reg_name_tbl[index], error_status);
+    }
+}
+
+void R_DRPAI_AIMAC_Open(addr_t aimac_base_addr, int32_t ch)
+{
+    aimac_bootseq(aimac_base_addr, 0);
+}
+
+void R_DRPAI_AIMAC_Start(addr_t aimac_base_addr, int32_t ch, uint64_t cmd_desc, uint64_t param_desc)
+{
+    set_aimac_desc(aimac_base_addr, cmd_desc, param_desc);
+    start_prefetch_aimac(aimac_base_addr);
+}
+
+int32_t R_DRPAI_AIMAC_Stop(addr_t aimac_base_addr, int32_t ch)
+{
+    int32_t ret = R_DRPAI_SUCCESS;
+
+    if (0 != stop_prefetch_aimac(aimac_base_addr))
+    {
+        ret = R_DRPAI_ERR_STOP;
+        goto end;
+    }
+
+    goto end;
+
+end:
+    return ret;
+}
+
+int32_t R_DRPAI_AIMAC_SetFreq(addr_t aimac_base_addr, int32_t ch, uint32_t divfix)
+{
+    int32_t ret = R_DRPAI_SUCCESS;
+
+    if ((1 <= divfix) && (127 >= divfix))
+    {
+        set_aimac_freq(aimac_base_addr, divfix);
+    }
+    else
+    {
+        ret = R_DRPAI_ERR_INVALID_ARG;
+    }
+
+    return ret;
+}
+
+int32_t R_DRPAI_AIMAC_EnableAddrReloc(addr_t aimac_base_addr, uint8_t* tbl)
+{
+    int32_t ret = R_DRPAI_SUCCESS;
+
+    if (0 != tbl)
+    {
+        enable_addr_relocatable_func(0, aimac_base_addr, tbl);
+    }
+    else
+    {
+        ret = R_DRPAI_ERR_INVALID_ARG;
+    }
+
+    return ret;
+}
+
+void R_DRPAI_AIMAC_DisableAddrReloc(addr_t aimac_base_addr)
+{
+    disable_addr_relocatable_func(0, aimac_base_addr);
+}
+
+int32_t R_DRPAI_AIMAC_Reset(addr_t aimac_base_addr, int32_t ch)
+{
+    int32_t ret = R_DRPAI_SUCCESS;
+
+    if (0 != stop_prefetch_aimac(aimac_base_addr))
+    {
+        ret = R_DRPAI_ERR_RESET;
+        goto end;
+    }
+    if (0 != aimac_finalize(aimac_base_addr))
+    {
+        ret = R_DRPAI_ERR_RESET;
+        goto end;
+    }
+
+    goto end;
+
+end:
+    return R_DRPAI_SUCCESS;
+}
+
+int32_t R_DRPAI_AIMAC_Nmlint(addr_t aimac_base_addr, int32_t ch, uint32_t* reserved)
+{
+    int32_t ret = R_DRPAI_SUCCESS;
+    volatile uint32_t intmon_int;
+    uint32_t intexd0;
+    uint32_t intexd1;
+    volatile uint32_t dummy;
+    volatile uint32_t exd1_odif_intcnto1;
+
+    intmon_int = ioread32(aimac_base_addr + INTM_INT_REG);
+    intexd0 = (intmon_int >> 16) & 1;
+    intexd1 = (intmon_int >> 17) & 1;
+
+    reserved[DRPAI_RESERVED_INTMON_INT] = intmon_int;
+
+    reserved[DRPAI_RESERVED_EXD0_STPC_INT_STS] = 0;
+    reserved[DRPAI_RESERVED_EXD0_ODMACIF]      = 0;
+    if (0 != intexd0)
+    {
+        volatile uint32_t exd0_stpc_int_sts;
+        uint32_t odmacif_int;
+
+        exd0_stpc_int_sts = ioread32(aimac_base_addr + EXD0_STPC_BADDR + STPC_INT_STS);
+        odmacif_int = (exd0_stpc_int_sts >> 9) & 1;
+
+        reserved[DRPAI_RESERVED_EXD0_STPC_INT_STS] = exd0_stpc_int_sts;
+
+        if (0 != odmacif_int)
+        {
+            uint32_t exd0_odmacif;
+
+            exd0_odmacif = ioread32(aimac_base_addr + EXD0_ODIF_BADDR + ODIF_INT_REG);
+            iowrite32(exd0_odmacif, aimac_base_addr + EXD0_ODIF_BADDR + ODIF_INT_REG);
+            dummy = ioread32(aimac_base_addr + EXD0_ODIF_BADDR + ODIF_INT_REG); /* dummy read */
+
+            reserved[DRPAI_RESERVED_EXD0_ODMACIF] = exd0_odmacif;
+        }
+    }
+
+    reserved[DRPAI_RESERVED_EXD1_STPC_INT_STS] = 0;
+    reserved[DRPAI_RESERVED_EXD1_ODMACIF]      = 0;
+    if (0 != intexd1)
+    {
+        uint32_t exd1_stpc_int_sts;
+        uint32_t odmacif_int;
+
+        exd1_stpc_int_sts = ioread32(aimac_base_addr + EXD1_STPC_BADDR + STPC_INT_STS);
+        odmacif_int = (exd1_stpc_int_sts >> 9) & 1;
+
+        reserved[DRPAI_RESERVED_EXD1_STPC_INT_STS] = exd1_stpc_int_sts;
+
+        if (0 != odmacif_int)
+        {
+            uint32_t exd1_odmacif;
+
+            exd1_odmacif = ioread32(aimac_base_addr + EXD1_ODIF_BADDR + ODIF_INT_REG);
+            iowrite32(exd1_odmacif, aimac_base_addr + EXD1_ODIF_BADDR + ODIF_INT_REG);
+            dummy = ioread32(aimac_base_addr + EXD1_ODIF_BADDR + ODIF_INT_REG); /* dummy read */
+
+            reserved[DRPAI_RESERVED_EXD1_ODMACIF] = exd1_odmacif;
+        }
+    }
+
+    exd1_odif_intcnto1 = ioread32(aimac_base_addr + EXD1_ODIF_BADDR + ODIF_INTCNTO1_REG);
+
+    reserved[DRPAI_RESERVED_EXD0_ODIF_INTCNTO0] = 0;
+    reserved[DRPAI_RESERVED_EXD0_ODIF_INTCNTO1] = 0;
+    reserved[DRPAI_RESERVED_EXD1_ODIF_INTCNTO0] = 0;
+    reserved[DRPAI_RESERVED_EXD1_ODIF_INTCNTO1] = exd1_odif_intcnto1;
+
+    if (1 != exd1_odif_intcnto1)
+    {
+        ret = R_DRPAI_ERR_INT;
+    }
+
+    return ret;
+}
+
+void R_DRPAI_AIMAC_Errint(addr_t drp_base_addr, addr_t aimac_base_addr, int32_t ch)
+{
+    volatile uint32_t dscc_pamon;
+    volatile uint32_t exd0_dscc_pamon;
+    volatile uint32_t aid0_dscc_pamon;
+    volatile uint32_t intmon_errint;
+    uint32_t eintexd0;
+    uint32_t eintexd1;
+    uint32_t index;
+    volatile uint32_t error_status;
+    volatile uint32_t dummy;
+
+    printk(KERN_ERR "DRPAI Error Interrupt\n");
+
+    dscc_pamon      = ioread32(drp_base_addr   + STP_DSCC_BADDR  + DSCC_PAMON_REG);
+    exd0_dscc_pamon = ioread32(aimac_base_addr + EXD0_DSCC_BADDR + DSCC_PAMON_REG);
+    aid0_dscc_pamon = ioread32(aimac_base_addr + AID0_DSCC_BADDR + DSCC_PAMON_REG);
+
+    printk(KERN_ERR "DSCC_PAMON : 0x%08X\n",      dscc_pamon);
+    printk(KERN_ERR "EXD0_DSCC_PAMON : 0x%08X\n", exd0_dscc_pamon);
+    printk(KERN_ERR "AID0_DSCC_PAMON : 0x%08X\n", aid0_dscc_pamon);
+
+    intmon_errint = ioread32(aimac_base_addr + INTM_ERRINT_REG);
+    eintexd0 = (intmon_errint >> 16) & 1;
+    eintexd1 = (intmon_errint >> 17) & 1;
+
+    printk(KERN_ERR "INTMON_ERRINT : 0x%08X\n", intmon_errint);
+
+    if (0 != eintexd0)
+    {
+        volatile uint32_t exd0_stpc_errint_sts;
+
+        exd0_stpc_errint_sts = ioread32(aimac_base_addr + EXD0_STPC_BADDR + STPC_ERRINT_STS);
+        printk(KERN_ERR "EXD0_STPC_ERRINT_STS : 0x%08X\n", exd0_stpc_errint_sts);
+
+        for (index = 0; index < EXDx_ERRINT_STATUS_REG_NUM; index++)
+        {
+            error_status = ioread32(aimac_base_addr + exd0_errint_status_reg_tbl[index]);
+            iowrite32(error_status, aimac_base_addr + exd0_errint_status_reg_tbl[index]);
+            dummy = ioread32(aimac_base_addr + exd0_errint_status_reg_tbl[index]);
+
+            printk(KERN_ERR "%s : 0x%08X\n", exd0_errint_status_reg_name_tbl[index], error_status);
+        }
+    }
+
+    if (0 != eintexd1)
+    {
+        volatile uint32_t exd1_stpc_errint_sts;
+
+        exd1_stpc_errint_sts = ioread32(aimac_base_addr + EXD1_STPC_BADDR + STPC_ERRINT_STS);
+        printk(KERN_ERR "EXD1_STPC_ERRINT_STS : 0x%08X\n", exd1_stpc_errint_sts);
+
+        for (index = 0; index < EXDx_ERRINT_STATUS_REG_NUM; index++)
+        {
+            error_status = ioread32(aimac_base_addr + exd1_errint_status_reg_tbl[index]);
+            iowrite32(error_status, aimac_base_addr + exd1_errint_status_reg_tbl[index]);
+            dummy = ioread32(aimac_base_addr + exd1_errint_status_reg_tbl[index]);
+
+            printk(KERN_ERR "%s : 0x%08X\n", exd1_errint_status_reg_name_tbl[index], error_status);
+        }
+    }
+
+    for (index = 0; index < AIMAC_ERRINT_STATUS_REG_NUM; index++)
+    {
+        error_status = ioread32(aimac_base_addr + aimac_errint_status_reg_tbl[index]);
+        iowrite32(error_status, aimac_base_addr + aimac_errint_status_reg_tbl[index]);
+        dummy = ioread32(aimac_base_addr + aimac_errint_status_reg_tbl[index]);
+
+        printk(KERN_ERR "%s : 0x%08X\n", aimac_errint_status_reg_name_tbl[index], error_status);
+    }
+}
+
+void R_DRPAI_Status(addr_t drp_base_addr, addr_t aimac_base_addr, int32_t ch, uint32_t *reserved)
+{
+    reserved[DRPAI_RESERVED_STP_DSCC_PAMON]   = ioread32(drp_base_addr   + STP_DSCC_BADDR     + DSCC_PAMON_REG);
+    reserved[DRPAI_RESERVED_EXD0_DSCC_PAMON]  = ioread32(aimac_base_addr + EXD0_DSCC_BADDR    + DSCC_PAMON_REG);
+    reserved[DRPAI_RESERVED_AID0_DSCC_PAMON]  = ioread32(aimac_base_addr + AID0_DSCC_BADDR    + DSCC_PAMON_REG);
+    reserved[DRPAI_RESERVED_ADRCONV_CTL]      = ioread32(drp_base_addr   + STP_ADRCONV_BADDR  + ADRCONV_TBL_EN);
+    reserved[DRPAI_RESERVED_EXD0_ADRCONV_CTL] = ioread32(aimac_base_addr + EXD0_ADRCONV_BADDR + ADRCONV_TBL_EN);
+    reserved[DRPAI_RESERVED_SYNCTBL_TBL13]    = ioread32(drp_base_addr   + STP_STBL_TBL13);
+    reserved[DRPAI_RESERVED_SYNCTBL_TBL14]    = ioread32(drp_base_addr   + STP_STBL_TBL14);
+    reserved[DRPAI_RESERVED_SYNCTBL_TBL15]    = ioread32(drp_base_addr   + STP_STBL_TBL15);
+}
+
+int32_t R_DRPAI_DRP_RegRead(addr_t drp_base_addr, uint32_t offset, uint32_t* pvalue)
+{
+    int32_t ret;
+
+    if (0 == pvalue)
+    {
+        ret = R_DRPAI_ERR_INVALID_ARG;
+    }
+    else
+    {
+        *pvalue = ioread32(drp_base_addr + offset);
+        ret = R_DRPAI_SUCCESS;
+    }
+
+    return ret;
+}
+
+void R_DRPAI_DRP_RegWrite(addr_t drp_base_addr, uint32_t offset, uint32_t value)
+{
+    iowrite32(value, drp_base_addr + offset);
+}
+
+int32_t R_DRPAI_AIMAC_RegRead(addr_t aimac_base_addr, uint32_t offset, uint32_t* pvalue)
+{
+    int32_t ret;
+
+    if (0 == pvalue)
+    {
+        ret = R_DRPAI_ERR_INVALID_ARG;
+    }
+    else
+    {
+        *pvalue = ioread32(aimac_base_addr + offset);
+        ret = R_DRPAI_SUCCESS;
+    }
+
+    return ret;
+}
+
+void R_DRPAI_AIMAC_RegWrite(addr_t aimac_base_addr, uint32_t offset, uint32_t value)
+{
+    iowrite32(value, aimac_base_addr + offset);
+}
+
+//------------------------------------------------------------------------------------------------------------------
+// CLKGEN module setting
+//------------------------------------------------------------------------------------------------------------------
+
+static void set_drpclkgen_freq(addr_t drp_base_addr, uint32_t bit_divfix, uint32_t bit_dfcena)
+{
+    uint32_t BIT_STBYWT;
+
+    BIT_STBYWT = 0x1;
+    iowrite32(BIT_STBYWT,                       drp_base_addr + STP_STPC_BADDR + STPC_CLKGEN_STBYWAIT);
+    iowrite32((bit_divfix << 16) | bit_dfcena,  drp_base_addr + STP_STPC_BADDR + STPC_CLKGEN_DIV);
+    BIT_STBYWT = 0x0;
+    iowrite32(BIT_STBYWT,                       drp_base_addr + STP_STPC_BADDR + STPC_CLKGEN_STBYWAIT);
+}
+
+static void stop_mclkgen(addr_t aimac_base_addr)
+{
+    uint32_t BIT_MCLKGEN = 0x01;
+
+    iowrite32(0x7F << 16,   aimac_base_addr + EXD0_STPC_BADDR + STPC_CLKSW_CONFIG);
+    iowrite32(BIT_MCLKGEN,  aimac_base_addr + EXD0_STPC_BADDR + STPC_CLKGEN_RST);
+}
+
+//------------------------------------------------------------------------------------------------------------------
+// Enable/Disable DMA channel clock
+//------------------------------------------------------------------------------------------------------------------
+
+static void start_drp_clk(addr_t drp_base_addr)
+{
+    uint32_t BIT_CMN_CLKE  = 0x1;
+    uint32_t BIT_STBL_CLKE = 0x1;
+    uint32_t BIT_DSCC_CLKE = 0x1;
+    uint32_t BIT_CFGW_CLKE = 0x1;
+    uint32_t BIT_CHOx_CLKE = 0xF;
+    uint32_t BIT_CHIx_CLKE = 0xF;
+
+    iowrite32((BIT_STBL_CLKE << 29) |
+              (BIT_CMN_CLKE  << 28) |
+              (BIT_CHOx_CLKE << 16) |
+              (BIT_DSCC_CLKE <<  9) |
+              (BIT_CFGW_CLKE <<  8) |
+              (BIT_CHIx_CLKE <<  0),    drp_base_addr + STP_STPC_BADDR + STPC_CLKE);
+}
+
+static void stop_drp_clk(addr_t drp_base_addr)
+{
+    uint32_t BIT_CMN_CLKE  = 0x0;
+    uint32_t BIT_STBL_CLKE = 0x0;
+    uint32_t BIT_DSCC_CLKE = 0x0;
+    uint32_t BIT_CFGW_CLKE = 0x0;
+    uint32_t BIT_CHOx_CLKE = 0x0;
+    uint32_t BIT_CHIx_CLKE = 0x0;
+
+    iowrite32(0xFFFFFFFF & ((BIT_STBL_CLKE << 29) |
+                            (BIT_CMN_CLKE  << 28) |
+                            (BIT_CHOx_CLKE << 16) |
+                            (BIT_DSCC_CLKE <<  9) |
+                            (BIT_CFGW_CLKE <<  8) |
+                            (BIT_CHIx_CLKE <<  0)), drp_base_addr + STP_STPC_BADDR + STPC_CLKE);
+}
+
+static void start_aimac_clk(addr_t aimac_base_addr)
+{
+    uint32_t BIT_CMN_CLKE  = 0x1;
+    uint32_t BIT_DSCC_CLKE = 0x1;
+    uint32_t BIT_MCMD_CLKE = 0x1;
+    uint32_t BIT_CHOx_CLKE = 0x3;
+    uint32_t BIT_CHIx_CLKE = 0x3;
+    uint32_t BIT_MCLK_AIM  = 0x1;
+    uint32_t BIT_DCLK_AIM  = 0x1;
+    uint32_t BIT_ACLK_AIM  = 0x1;
+
+    iowrite32((BIT_CMN_CLKE  << 28) |
+              (BIT_CHOx_CLKE << 16) |
+              (BIT_DSCC_CLKE <<  9) |
+              (BIT_MCMD_CLKE <<  2) |
+              (BIT_CHIx_CLKE <<  0),    aimac_base_addr + EXD0_STPC_BADDR + STPC_CLKE);
+
+    iowrite32((BIT_CMN_CLKE  << 28) |
+              (BIT_CHOx_CLKE << 16) |
+              (BIT_CHIx_CLKE <<  0),    aimac_base_addr + EXD1_STPC_BADDR + STPC_CLKE);
+
+    iowrite32((BIT_MCLK_AIM << 2) |
+              (BIT_DCLK_AIM << 1) |
+              (BIT_ACLK_AIM << 0),      aimac_base_addr + CLKRSTCON_BADDR + CLKRSTCON_CLKE_REG);
+}
+
+static void stop_aimac_clk(addr_t aimac_base_addr)
+{
+    iowrite32(0x00000000, aimac_base_addr + EXD0_STPC_BADDR + STPC_CLKE);
+    iowrite32(0x00000000, aimac_base_addr + EXD1_STPC_BADDR + STPC_CLKE);
+    iowrite32(0x00000000, aimac_base_addr + CLKRSTCON_BADDR + CLKRSTCON_CLKE_REG);
+}
+
+//------------------------------------------------------------------------------------------------------------------
+// Enable/Disable SW reset
+//------------------------------------------------------------------------------------------------------------------
+
+static void disable_drp_swreset(addr_t drp_base_addr)
+{
+    uint32_t BIT_DRP_RST    = 0x0;
+    uint32_t BIT_DRPOIF_RST = 0x0;
+    uint32_t BIT_DRPIIF_RST = 0x0;
+    uint32_t BIT_CMN_RST    = 0x0;
+    uint32_t BIT_STBL_RST   = 0x0;
+    uint32_t BIT_DSCC_RST   = 0x0;
+    uint32_t BIT_CFGW_RST   = 0x0;
+    uint32_t BIT_CHOx_RST   = 0x0;
+    uint32_t BIT_CHIx_RST   = 0x0;
+
+    iowrite32(0xFFFFFFFF & ((BIT_DRP_RST   << 31) |
+                            (BIT_STBL_RST  << 29) |
+                            (BIT_CMN_RST   << 28) |
+                            (BIT_DRPOIF_RST<< 27) |
+                            (BIT_DRPIIF_RST<< 26) |
+                            (BIT_CHOx_RST  << 16) |
+                            (BIT_DSCC_RST  <<  9) |
+                            (BIT_CFGW_RST  <<  8) |
+                            (BIT_CHIx_RST  <<  0)), drp_base_addr + STP_STPC_BADDR + STPC_SFTRST);
+}
+
+static void enable_drp_swreset(addr_t drp_base_addr)
+{
+    iowrite32(0xFFFFFFFF, drp_base_addr + STP_STPC_BADDR + STPC_SFTRST);
+}
+
+static void disable_aimac_swreset(addr_t aimac_base_addr)
+{
+    uint32_t BIT_CMN_RST  = 0x0;
+    uint32_t BIT_DSCC_RST = 0x0;
+    uint32_t BIT_MCMD_RST = 0x0;
+    uint32_t BIT_CHOx_RST = 0x0;
+    uint32_t BIT_CHIx_RST = 0x0;
+    uint32_t BIT_STBL     = 0x1;
+    uint32_t BIT_MAC      = 0x0;
+    uint32_t BIT_PRAM     = 0x0;
+    uint32_t BIT_CMDS     = 0x0;
+    uint32_t BIT_ADMA     = 0x0;
+
+    iowrite32((BIT_CMN_RST  << 28) |
+              (BIT_CHOx_RST << 16) |
+              (BIT_DSCC_RST <<  9) |
+              (BIT_MCMD_RST <<  2) |
+              (BIT_CHIx_RST <<  0), aimac_base_addr + EXD0_STPC_BADDR + STPC_SFTRST);
+    iowrite32((BIT_CMN_RST  << 28) |
+              (BIT_CHOx_RST << 16) |
+              (BIT_CHIx_RST <<  0), aimac_base_addr + EXD1_STPC_BADDR + STPC_SFTRST);
+    iowrite32((BIT_STBL     <<  4) |
+              (BIT_MAC      <<  3) |
+              (BIT_PRAM     <<  2) |
+              (BIT_CMDS     <<  1) |
+              (BIT_ADMA     <<  0), aimac_base_addr + CLKRSTCON_BADDR + CLKRSTCON_SFTRST_REG);
+}
+
+static void enable_aimac_swreset(addr_t aimac_base_addr)
+{
+    iowrite32(0xB1FF03FF, aimac_base_addr + EXD0_STPC_BADDR + STPC_SFTRST);
+    iowrite32(0xB1FF03FF, aimac_base_addr + EXD1_STPC_BADDR + STPC_SFTRST);
+    iowrite32(0x0000001F, aimac_base_addr + CLKRSTCON_BADDR + CLKRSTCON_SFTRST_REG);
+}
+
+
+//------------------------------------------------------------------------------------------------------------------
+// AI-MAC individual setting
+//------------------------------------------------------------------------------------------------------------------
+
+static void aimac_inidividual_setting(addr_t aimac_base_addr)
+{
+    uint32_t BIT_EO_CEN = 0x1;
+
+    iowrite32(BIT_EO_CEN << 11, aimac_base_addr + FMBUF_CLK_CTRL);
+}
+
+//------------------------------------------------------------------------------------------------------------------
+// Address relocatable
+//------------------------------------------------------------------------------------------------------------------
+
+static void enable_addr_relocatable_func(addr_t drp_base_addr, addr_t aimac_base_addr, uint8_t* tbl)
+{
+    if (0 != drp_base_addr)
+    {
+        enable_addr_relocatable(drp_base_addr + STP_ADRCONV_BADDR, tbl);
+    }
+    if (0 != aimac_base_addr)
+    {
+        enable_addr_relocatable(aimac_base_addr + EXD0_ADRCONV_BADDR, tbl);
+    }
+}
+
+static void enable_addr_relocatable(addr_t addr, uint8_t* tbl)
+{
+    if (0 == tbl)
+    {
+        iowrite32(0x00000000, addr + ADRCONV_TBL_EN);
+    }
+    else
+    {
+        uint32_t i;
+        uint32_t BIT_VLD;
+        uint32_t BIT_PG;
+        uint32_t BIT_MAP_ADR_24to31;
+        uint32_t BIT_MAP_ADR_32to39;
+
+        for (i = 0; i < 256; i++)
+        {
+            BIT_VLD            = ((uint32_t)tbl[i * 4 + 0] & 0xFF);
+            BIT_PG             = ((uint32_t)tbl[i * 4 + 1] & 0xFF);
+            BIT_MAP_ADR_24to31 = ((uint32_t)tbl[i * 4 + 2] & 0xFF);
+            BIT_MAP_ADR_32to39 = ((uint32_t)tbl[i * 4 + 3] & 0xFF);
+            iowrite32((BIT_MAP_ADR_24to31 << 24) |
+                      (BIT_MAP_ADR_32to39 <<  8) |
+                      (BIT_PG             <<  4) |
+                      (BIT_VLD            <<  0),   addr + ADRCONV_TBL + i * 4);
+        }
+        iowrite32(0x00000001, addr + ADRCONV_TBL_EN);
+    }
+}
+
+static void disable_addr_relocatable_func(addr_t drp_base_addr, addr_t aimac_base_addr)
+{
+    if (0 != drp_base_addr)
+    {
+        disable_addr_relocatable(drp_base_addr + STP_ADRCONV_BADDR);
+    }
+    if (0 != aimac_base_addr)
+    {
+        disable_addr_relocatable(aimac_base_addr + EXD0_ADRCONV_BADDR);
+    }
+}
+
+static void disable_addr_relocatable(addr_t addr)
+{
+    iowrite32(0x00000000, addr + ADRCONV_TBL_EN);
+}
+
+//------------------------------------------------------------------------------------------------------------------
+// Start/Stop prefetch descriptor
+//------------------------------------------------------------------------------------------------------------------
+static int32_t stop_desc_prefetch(addr_t dmactl_addr)
+{
+    iowrite8(0x00, dmactl_addr);
+
+    return loop_w(dmactl_addr, 0x00000000, 0xFFFFFFFD);
+}
+
+//------------------------------------------------------------------------------------------------------------------
+// Start/Stop DMA channel.
+//------------------------------------------------------------------------------------------------------------------
+#if 0 /* for POC3N */
+static void set_synctbl_all1(addr_t synctbl_addr)
+{
+    uint32_t id;
+
+    for (id = 0; id < 16; id++)
+    {
+        iowrite32(0xFFFFFFFF, synctbl_addr + id * 4);
+    }
+}
+#endif
+
+static int32_t dma_stop(addr_t dmactl_addr)
+{
+    int32_t ret = -1;
+    uint32_t loop;
+
+    iowrite8(0x00, dmactl_addr + 0x2);
+    iowrite8(0x00, dmactl_addr + 0x0);
+
+    loop = 0;
+    while ((100 > loop) && (0 != ret))
+    {
+        if (0 == check_reg(dmactl_addr, 0x00080000, 0x00000002, 0x00080000))
+        {
+            ret = 0;
+            break;
+        }
+        udelay(1);
+        loop++;
+    }
+
+    loop = 0;
+    while ((100 > loop) && (0 != ret))
+    {
+        if (0 == check_reg(dmactl_addr, 0x00080000, 0x00000002, 0x00080000))
+        {
+            ret = 0;
+            break;
+        }
+        usleep_range(100, 200);
+        loop++;
+    }
+
+    return ret;
+}
+
+static void start_drp_dmac(addr_t drp_base_addr)
+{
+    uint32_t BIT_DEN   = 0x1;
+    uint32_t BIT_REQEN = 0x1;
+    uint32_t BIT_DSEL  = 0x0;
+
+    iowrite32((BIT_REQEN << 18) | (BIT_DSEL << 8) | (BIT_DEN << 0), drp_base_addr + STP_IDIF_BADDR + IDIF_DMACTLI0_REG);
+    iowrite32((BIT_REQEN << 18) | (BIT_DSEL << 8) | (BIT_DEN << 0), drp_base_addr + STP_IDIF_BADDR + IDIF_DMACTLI1_REG);
+    iowrite32((BIT_REQEN << 18) | (BIT_DSEL << 8) | (BIT_DEN << 0), drp_base_addr + STP_IDIF_BADDR + IDIF_DMACTLI2_REG);
+    iowrite32((BIT_REQEN << 18) | (BIT_DSEL << 8) | (BIT_DEN << 0), drp_base_addr + STP_IDIF_BADDR + IDIF_DMACTLI3_REG);
+
+    iowrite32((BIT_REQEN << 18) |                   (BIT_DEN << 0), drp_base_addr + STP_ODIF_BADDR + ODIF_DMACTLO0_REG);
+    iowrite32((BIT_REQEN << 18) |                   (BIT_DEN << 0), drp_base_addr + STP_ODIF_BADDR + ODIF_DMACTLO1_REG);
+    iowrite32((BIT_REQEN << 18) |                   (BIT_DEN << 0), drp_base_addr + STP_ODIF_BADDR + ODIF_DMACTLO2_REG);
+    iowrite32((BIT_REQEN << 18) |                   (BIT_DEN << 0), drp_base_addr + STP_ODIF_BADDR + ODIF_DMACTLO3_REG);
+
+    iowrite32((BIT_REQEN << 18) |                   (BIT_DEN << 0), drp_base_addr + STP_IDIF_BADDR + IDIF_DMACTLCW_REG);
+}
+
+static int32_t stop_drp_dmac(addr_t drp_base_addr)
+{
+    int32_t ret = 0;
+
+    if (0 != dma_stop(drp_base_addr + STP_IDIF_BADDR + IDIF_DMACTLI0_REG))
+    {
+        goto error_stop;
+    }
+    if (0 != dma_stop(drp_base_addr + STP_IDIF_BADDR + IDIF_DMACTLI1_REG))
+    {
+        goto error_stop;
+    }
+    if (0 != dma_stop(drp_base_addr + STP_IDIF_BADDR + IDIF_DMACTLI2_REG))
+    {
+        goto error_stop;
+    }
+    if (0 != dma_stop(drp_base_addr + STP_IDIF_BADDR + IDIF_DMACTLI3_REG))
+    {
+        goto error_stop;
+    }
+    if (0 != dma_stop(drp_base_addr + STP_ODIF_BADDR + ODIF_DMACTLO0_REG))
+    {
+        goto error_stop;
+    }
+    if (0 != dma_stop(drp_base_addr + STP_ODIF_BADDR + ODIF_DMACTLO1_REG))
+    {
+        goto error_stop;
+    }
+    if (0 != dma_stop(drp_base_addr + STP_ODIF_BADDR + ODIF_DMACTLO2_REG))
+    {
+        goto error_stop;
+    }
+    if (0 != dma_stop(drp_base_addr + STP_ODIF_BADDR + ODIF_DMACTLO3_REG))
+    {
+        goto error_stop;
+    }
+
+    goto end;
+
+error_stop:
+    ret = -1;
+    goto end;
+
+end:
+    return ret;
+}
+
+static int32_t stop_drp_dmacw(addr_t drp_base_addr)
+{
+    addr_t dmactl_addr = drp_base_addr + STP_IDIF_BADDR + IDIF_DMACTLCW_REG;
+
+    iowrite8(0x00, dmactl_addr);
+
+    return loop_w(dmactl_addr, 0x00000000, 0xFFFFFFFD);
+}
+
+static void start_aimac_dmac(addr_t aimac_base_addr)
+{
+    uint32_t BIT_DEN   = 0x1;
+    uint32_t BIT_REQEN = 0x1;
+    uint32_t wdata     = (BIT_REQEN << 18) | (BIT_DEN << 0);
+
+    iowrite32(wdata, aimac_base_addr + EXD0_IDIF_BADDR + IDIF_DMACTLMCMD_REG);
+    iowrite32(wdata, aimac_base_addr + EXD0_IDIF_BADDR + IDIF_DMACTLI0_REG);
+    iowrite32(wdata, aimac_base_addr + EXD0_IDIF_BADDR + IDIF_DMACTLI1_REG);
+    iowrite32(wdata, aimac_base_addr + EXD1_IDIF_BADDR + IDIF_DMACTLI0_REG);
+    iowrite32(wdata, aimac_base_addr + EXD1_IDIF_BADDR + IDIF_DMACTLI1_REG);
+    iowrite32(wdata, aimac_base_addr + EXD0_ODIF_BADDR + ODIF_DMACTLO0_REG);
+    iowrite32(wdata, aimac_base_addr + EXD0_ODIF_BADDR + ODIF_DMACTLO1_REG);
+    iowrite32(wdata, aimac_base_addr + EXD1_ODIF_BADDR + ODIF_DMACTLO0_REG);
+    iowrite32(wdata, aimac_base_addr + EXD1_ODIF_BADDR + ODIF_DMACTLO1_REG);
+
+    iowrite32(wdata, aimac_base_addr + AID0_IDIF_BADDR + IDIF_DMACTLI0_REG);
+    iowrite32(wdata, aimac_base_addr + AID0_IDIF_BADDR + IDIF_DMACTLI1_REG);
+    iowrite32(wdata, aimac_base_addr + AID0_IDIF2_BADDR + IDIF_DMACTPCMD_REG);
+    iowrite32(wdata, aimac_base_addr + AID1_IDIF_BADDR + IDIF_DMACTLI0_REG);
+}
+
+static int32_t stop_aimac_dmac(addr_t aimac_base_addr)
+{
+    int32_t ret = 0;
+
+    if (0 != dma_stop(aimac_base_addr + AID0_IDIF2_BADDR + IDIF_DMACTPCMD_REG))
+    {
+        goto error_stop;
+    }
+    if (0 != dma_stop(aimac_base_addr + EXD0_IDIF_BADDR + IDIF_DMACTLMCMD_REG))
+    {
+        goto error_stop;
+    }
+
+    if (0 != dma_stop(aimac_base_addr + AID0_IDIF_BADDR + IDIF_DMACTLI0_REG))
+    {
+        goto error_stop;
+    }
+    if (0 != dma_stop(aimac_base_addr + AID0_IDIF_BADDR + IDIF_DMACTLI1_REG))
+    {
+        goto error_stop;
+    }
+    if (0 != dma_stop(aimac_base_addr + AID1_IDIF_BADDR + IDIF_DMACTLI0_REG))
+    {
+        goto error_stop;
+    }
+
+    if (0 != dma_stop(aimac_base_addr + EXD0_IDIF_BADDR + IDIF_DMACTLI0_REG))
+    {
+        goto error_stop;
+    }
+    if (0 != dma_stop(aimac_base_addr + EXD0_IDIF_BADDR + IDIF_DMACTLI1_REG))
+    {
+        goto error_stop;
+    }
+    if (0 != dma_stop(aimac_base_addr + EXD1_IDIF_BADDR + IDIF_DMACTLI0_REG))
+    {
+        goto error_stop;
+    }
+    if (0 != dma_stop(aimac_base_addr + EXD1_IDIF_BADDR + IDIF_DMACTLI1_REG))
+    {
+        goto error_stop;
+    }
+    if (0 != dma_stop(aimac_base_addr + EXD0_ODIF_BADDR + ODIF_DMACTLO0_REG))
+    {
+        goto error_stop;
+    }
+    if (0 != dma_stop(aimac_base_addr + EXD0_ODIF_BADDR + ODIF_DMACTLO1_REG))
+    {
+        goto error_stop;
+    }
+    if (0 != dma_stop(aimac_base_addr + EXD1_ODIF_BADDR + ODIF_DMACTLO0_REG))
+    {
+        goto error_stop;
+    }
+    if (0 != dma_stop(aimac_base_addr + EXD1_ODIF_BADDR + ODIF_DMACTLO1_REG))
+    {
+        goto error_stop;
+    }
+
+    goto end;
+
+error_stop:
+    ret = -1;
+    goto end;
+
+end:
+    return ret;
+}
+
+//------------------------------------------------------------------------------------------------------------------
+// DRP-AI interrupt mask setting
+//------------------------------------------------------------------------------------------------------------------
+static void disable_drp_intmask(addr_t drp_base_addr)
+{
+#if (0 != DRP_ECC_ENA)
+    iowrite32(0x0000073F, drp_base_addr + DRP_ERRINT_ENABLE);
+#else
+    iowrite32(0x00000000, drp_base_addr + DRP_ERRINT_ENABLE);
+    iowrite32(0x00000007, drp_base_addr + DRP_ECC);
+#endif
+
+    iowrite32(0xF8F0F0F0, drp_base_addr + STP_IDIF_BADDR  + IDIF_EINTMSK_REG);
+    iowrite32(0xFFFEFEFE, drp_base_addr + STP_IDIF_BADDR  + IDIF_EINTMSK_DSC_REG);
+    iowrite32(0xFFF0F0F0, drp_base_addr + STP_ODIF_BADDR  + ODIF_EINTMSK_REG);
+    iowrite32(0xFFFFFFF8, drp_base_addr + STP_IDMAC_BADDR + IDMAC_INTME_REG);
+    iowrite32(0xFFFFFFFC, drp_base_addr + STP_ODMAC_BADDR + ODMAC_INTME_REG);
+
+    iowrite32(0xFFFFFFFE, drp_base_addr + STP_ODIF_BADDR + ODIF_INTMSK_REG);
+
+    // setting ELC0
+    iowrite32(0x0000000F, drp_base_addr + STP_ODIF_BADDR + ODIF_ELCCTL_REG);
+}
+
+static void enable_drp_intmask(addr_t drp_base_addr)
+{
+    // disable DRP error interrupt
+    iowrite32(0x00000000, drp_base_addr + DRP_ERRINT_ENABLE);
+
+    // enable abnormal interrupt
+    iowrite32(0xFFFFFFFF, drp_base_addr + STP_IDIF_BADDR  + IDIF_EINTMSK_REG);
+    iowrite32(0xFFFFFFFF, drp_base_addr + STP_IDIF_BADDR  + IDIF_EINTMSK_DSC_REG);
+    iowrite32(0xFFFFFFFF, drp_base_addr + STP_ODIF_BADDR  + ODIF_EINTMSK_REG);
+    iowrite32(0xFFFFFFFF, drp_base_addr + STP_IDMAC_BADDR + IDMAC_INTME_REG);
+    iowrite32(0xFFFFFFFF, drp_base_addr + STP_ODMAC_BADDR + ODMAC_INTME_REG);
+
+    // enable normal interrupt
+    iowrite32(0xFFFFFFFF, drp_base_addr + STP_ODIF_BADDR + ODIF_INTMSK_REG);
+
+    // disable ELC0 output
+    iowrite32(0x00000000, drp_base_addr + STP_ODIF_BADDR + ODIF_ELCCTL_REG);
+}
+
+static void disable_aimac_intmask(addr_t aimac_base_addr)
+{
+    // unmask normal interrupt
+    iowrite32(0xFFFFFFFF, aimac_base_addr + EXD0_ODIF_BADDR  + ODIF_INTMSK_REG);
+    iowrite32(0xFFFFFFFD, aimac_base_addr + EXD1_ODIF_BADDR  + ODIF_INTMSK_REG);
+
+    // unmask abnormal interrupt
+    iowrite32(0xFFFCFCFC, aimac_base_addr + AID0_IDIF_BADDR  + IDIF_EINTMSK_REG);
+    iowrite32(0xFFFEFEFE, aimac_base_addr + AID0_IDIF2_BADDR + IDIF_EINTMSK_DSC_REG);
+    iowrite32(0xFFFFFFF8, aimac_base_addr + AID0_IDMAC_BADDR + IDMAC_INTME_REG);
+    iowrite32(0xFFFEFEFE, aimac_base_addr + AID1_IDIF_BADDR  + IDIF_EINTMSK_REG);
+    iowrite32(0xFFFFFFF8, aimac_base_addr + AID1_IDMAC_BADDR + IDMAC_INTME_REG);
+    iowrite32(0xFFFCFCFC, aimac_base_addr + EXD0_IDIF_BADDR  + IDIF_EINTMSK_REG);
+    iowrite32(0xFFFBFBFB, aimac_base_addr + EXD0_IDIF_BADDR  + IDIF_EINTMSK_DSC_REG);
+    iowrite32(0xFFFCFCFC, aimac_base_addr + EXD0_ODIF_BADDR  + ODIF_EINTMSK_REG);
+    iowrite32(0xFFFFFFF8, aimac_base_addr + EXD0_IDMAC_BADDR + IDMAC_INTME_REG);
+    iowrite32(0xFFFFFFFC, aimac_base_addr + EXD0_ODMAC_BADDR + ODMAC_INTME_REG);
+    iowrite32(0xFFFCFCFC, aimac_base_addr + EXD1_IDIF_BADDR  + IDIF_EINTMSK_REG);
+    iowrite32(0xFFFCFCFC, aimac_base_addr + EXD1_ODIF_BADDR  + ODIF_EINTMSK_REG);
+    iowrite32(0xFFFFFFF8, aimac_base_addr + EXD1_IDMAC_BADDR + IDMAC_INTME_REG);
+    iowrite32(0xFFFFFFFC, aimac_base_addr + EXD1_ODMAC_BADDR + ODMAC_INTME_REG);
+
+    iowrite32(0xFFFF0FCC, aimac_base_addr + PRAM_INTMSK);
+    iowrite32(0xFFFFFE0C, aimac_base_addr + FMBUF_ERR_MSK);
+    iowrite32(0xFFFFFFF0, aimac_base_addr + MACTOP_MACCTL_ERR_MSK);
+
+    // setup MAC_ELC0 output
+    iowrite32(0x00000003, aimac_base_addr + EXD0_ODIF_BADDR  + ODIF_ELCCTL_REG);
+    iowrite32(0x00000003, aimac_base_addr + EXD1_ODIF_BADDR  + ODIF_ELCCTL_REG);
+}
+
+static void enable_aimac_intmask(addr_t aimac_base_addr)
+{
+    iowrite32(0xFFFFFFFF, aimac_base_addr + EXD0_ODIF_BADDR  + ODIF_INTMSK_REG);
+    iowrite32(0xFFFFFFFF, aimac_base_addr + EXD1_ODIF_BADDR  + ODIF_INTMSK_REG);
+
+    iowrite32(0xFFFFFFFF, aimac_base_addr + AID0_IDIF_BADDR  + IDIF_EINTMSK_REG);
+    iowrite32(0xFFFFFFFF, aimac_base_addr + AID0_IDIF2_BADDR + IDIF_EINTMSK_DSC_REG);
+    iowrite32(0xFFFFFFFF, aimac_base_addr + AID0_IDMAC_BADDR + IDMAC_INTME_REG);
+    iowrite32(0xFFFFFFFF, aimac_base_addr + AID1_IDIF_BADDR  + IDIF_EINTMSK_REG);
+    iowrite32(0xFFFFFFFF, aimac_base_addr + AID1_IDMAC_BADDR + IDMAC_INTME_REG);
+    iowrite32(0xFFFFFFFF, aimac_base_addr + EXD0_IDIF_BADDR  + IDIF_EINTMSK_REG);
+    iowrite32(0xFFFFFFFF, aimac_base_addr + EXD0_IDIF_BADDR  + IDIF_EINTMSK_DSC_REG);
+    iowrite32(0xFFFFFFFF, aimac_base_addr + EXD0_ODIF_BADDR  + ODIF_EINTMSK_REG);
+    iowrite32(0xFFFFFFFF, aimac_base_addr + EXD0_IDMAC_BADDR + IDMAC_INTME_REG);
+    iowrite32(0xFFFFFFFF, aimac_base_addr + EXD0_ODMAC_BADDR + ODMAC_INTME_REG);
+    iowrite32(0xFFFFFFFF, aimac_base_addr + EXD1_IDIF_BADDR  + IDIF_EINTMSK_REG);
+    iowrite32(0xFFFFFFFF, aimac_base_addr + EXD1_ODIF_BADDR  + ODIF_EINTMSK_REG);
+    iowrite32(0xFFFFFFFF, aimac_base_addr + EXD1_IDMAC_BADDR + IDMAC_INTME_REG);
+    iowrite32(0xFFFFFFFF, aimac_base_addr + EXD1_ODMAC_BADDR + ODMAC_INTME_REG);
+    iowrite32(0xFFFFFFFF, aimac_base_addr + PRAM_INTMSK);
+    iowrite32(0xFFFFFFFF, aimac_base_addr + FMBUF_ERR_MSK);
+    iowrite32(0xFFFFFFFF, aimac_base_addr + MACTOP_MACCTL_ERR_MSK);
+
+    iowrite32(0x00000000, aimac_base_addr + EXD0_ODIF_BADDR  + ODIF_ELCCTL_REG);
+    iowrite32(0x00000000, aimac_base_addr + EXD1_ODIF_BADDR  + ODIF_ELCCTL_REG);
+}
+
+//==================================================================================================================
+// Initialize (DRP)
+//==================================================================================================================
+static void drp_bootseq(addr_t drp_base_addr, uint8_t *drp_addr_relocatable_tbl)
+{
+    uint32_t BIT_DRPCLKGEN_RST = 0x0;
+
+    // 1. release DRPCLKGEN module reset
+    iowrite32(BIT_DRPCLKGEN_RST, drp_base_addr + STP_STPC_BADDR + STPC_CLKGEN_RST);
+
+    // 2. setup DRP clock frequency
+    set_drpclkgen_freq(drp_base_addr, DRP_DIVFIX, DRP_DFCENA);
+
+    // 3. enable DMA channel clock
+    start_drp_clk(drp_base_addr);
+
+    // 4. release soft reset
+    disable_drp_swreset(drp_base_addr);
+
+    // 5. initialize SYNCTBL
+    // Not required for V2H
+
+    // 6. setup address relocatable table
+    enable_addr_relocatable_func(drp_base_addr, 0, drp_addr_relocatable_tbl);
+
+    // 7. setup DMA channel
+    start_drp_dmac(drp_base_addr);
+
+    // 8. unmask interrupt
+    disable_drp_intmask(drp_base_addr);
+}
+
+static void aimac_bootseq(addr_t aimac_base_addr, uint8_t *aimac_addr_relocatable_tbl)
+{
+    uint32_t BIT_MCLKGEN_RST = 0x0;
+
+    // 1. release MCLKGEN module reset
+    iowrite32(BIT_MCLKGEN_RST, aimac_base_addr + EXD0_STPC_BADDR + STPC_CLKGEN_RST);
+
+    // 2. setup AIMAC clock frequency
+    set_aimac_freq(aimac_base_addr, AIMAC_DIVFIX);
+
+    // 3. Supply/Stop clock (initialize multi cycle FF)
+    iowrite32(0x00000007, aimac_base_addr + CLKRSTCON_BADDR + CLKRSTCON_CLKE_REG);
+    iowrite32(0x00000000, aimac_base_addr + EXD0_DRPIN_M_BADDR + DRPIN_DUMMY); // dummy access
+    iowrite32(0x00000000, aimac_base_addr + CLKRSTCON_BADDR + CLKRSTCON_CLKE_REG);
+
+    // 4. release soft reset
+    disable_aimac_swreset(aimac_base_addr);
+
+    // 5. enable clock
+    start_aimac_clk(aimac_base_addr);
+
+    // 6. AI-MAC version specific setting
+    aimac_inidividual_setting(aimac_base_addr);
+
+    // 7. address relocatable setting
+    enable_addr_relocatable_func(0, aimac_base_addr, aimac_addr_relocatable_tbl);
+
+    // 8. DMA channel setting
+    start_aimac_dmac(aimac_base_addr);
+
+    // 9. unmask interrupt
+    disable_aimac_intmask(aimac_base_addr);
+}
+
+//==================================================================================================================
+// Procedure of DRP/AIMAC
+//==================================================================================================================
+static void set_drp_desc(addr_t drp_base_addr, uint64_t drp_desc_addr)
+{
+    iowrite32(drp_desc_addr & 0xFFFFFFFF, drp_base_addr + STP_DSCC_BADDR + DSCC_DPA_REG);
+    iowrite32(drp_desc_addr >> 32,        drp_base_addr + STP_DSCC_BADDR + DSCC_DPA2_REG);
+}
+
+static void set_aimac_desc(addr_t aimac_base_addr, uint64_t cmd_desc_addr, uint64_t param_desc_addr)
+{
+    iowrite32(cmd_desc_addr   & 0xFFFFFFFF, aimac_base_addr + EXD0_DSCC_BADDR + DSCC_DPA_REG);
+    iowrite32(cmd_desc_addr   >> 32,        aimac_base_addr + EXD0_DSCC_BADDR + DSCC_DPA2_REG);
+    iowrite32(param_desc_addr & 0xFFFFFFFF, aimac_base_addr + AID0_DSCC_BADDR + DSCC_DPA_REG);
+    iowrite32(param_desc_addr >> 32,        aimac_base_addr + AID0_DSCC_BADDR + DSCC_DPA2_REG);
+}
+
+static void start_prefetch_drp(addr_t drp_base_addr)
+{
+    uint32_t BIT_DSCEN = 0x1;
+
+    iowrite32(BIT_DSCEN << 0, drp_base_addr + STP_DSCC_BADDR + DSCC_DCTLI0_REG);
+}
+
+static void start_prefetch_aimac(addr_t aimac_base_addr)
+{
+    uint32_t BIT_DSCEN = 0x1;
+
+    iowrite32(BIT_DSCEN << 0, aimac_base_addr + EXD0_DSCC_BADDR + DSCC_DCTLI0_REG);
+    iowrite32(BIT_DSCEN << 0, aimac_base_addr + AID0_DSCC_BADDR + DSCC_DCTLI0_REG);
+}
+
+//==================================================================================================================
+// Stop procedure
+//==================================================================================================================
+static int32_t stop_prefetch_drp(addr_t drp_base_addr)
+{
+    // 1. Stop descriptor prefetch.
+    return stop_desc_prefetch(drp_base_addr + STP_DSCC_BADDR + DSCC_DCTLI0_REG);
+}
+
+static int32_t stop_prefetch_aimac(addr_t aimac_base_addr)
+{
+    int32_t ret = 0;
+
+    // 1. Stop descriptor prefetch.
+    ret = stop_desc_prefetch(aimac_base_addr + AID0_DSCC_BADDR + DSCC_DCTLI0_REG);
+    if (0 != ret)
+    {
+        goto end;
+    }
+    ret = stop_desc_prefetch(aimac_base_addr + EXD0_DSCC_BADDR + DSCC_DCTLI0_REG);
+    if (0 != ret)
+    {
+        goto end;
+    }
+    goto end;
+
+end:
+    return ret;
+}
+
+static int32_t drp_finalize(addr_t drp_base_addr)
+{
+    int32_t ret = 0;
+
+    // 2. Stop writing configuration data.
+    if (0 != stop_drp_dmacw(drp_base_addr))
+    {
+        ret = -1;
+        goto end;
+    }
+
+    // 3. Mask interrput.
+    enable_drp_intmask(drp_base_addr);
+
+    // 4. Stop data input/output.
+    if (0 != stop_drp_dmac(drp_base_addr))
+    {
+        ret = -1;
+        goto end;
+    }
+
+    // 5. Disable address relocation table.
+    disable_addr_relocatable_func(drp_base_addr, 0);
+
+    // 6. Set up DRP core to fixed frequency mode.
+    set_drpclkgen_freq(drp_base_addr, 0x7F, 0x0);
+
+    // 7. Software reset.
+    enable_drp_swreset(drp_base_addr);
+
+    // 8. Stop DMA channel clock.
+    stop_drp_clk(drp_base_addr);
+
+    // 9. Reset DRPCLKGEN module.
+    iowrite32(0x00000001, drp_base_addr + STP_STPC_BADDR + STPC_CLKGEN_RST);
+
+    goto end;
+
+end:
+    return ret;
+}
+
+static int32_t aimac_finalize(addr_t aimac_base_addr)
+{
+    int32_t ret = 0;
+
+    // 2. mask interrupt.
+    enable_aimac_intmask(aimac_base_addr);
+
+    // 3. Stop command input.
+    /* TBD */
+
+    // 4. Stop parameter (weight, bias) input.
+    /* TBD */
+
+    // 5. Forced stop data input/output
+    if (0 != stop_aimac_dmac(aimac_base_addr))
+    {
+        ret = -1;
+        goto end;
+    }
+
+    // 6. Disable address relocatable table.
+    disable_addr_relocatable_func(0, aimac_base_addr);
+
+    // 7. Stop clock.
+    stop_aimac_clk(aimac_base_addr);
+
+    // 8. Software reset.
+    enable_aimac_swreset(aimac_base_addr);
+
+    // 9. Stop MCLKGEN
+    stop_mclkgen(aimac_base_addr);
+
+    goto end;
+
+end:
+    return ret;
+}
+
+int32_t reset_cpg(addr_t cpg_base_addr, int32_t ch)
+{
+    int32_t ret = R_DRPAI_SUCCESS;
+    int32_t BIT_NUM_RST    = (0 == ch) ? 13 : 12;
+    int32_t BIT_NUM_RSTMON = (0 == ch) ? 14 : 13;
+
+    // Reset on setting.
+    cpg_set(cpg_base_addr + CPG_RST_15_REG, BIT_NUM_RST, 0x0u);
+    if (0 != cpg_check(cpg_base_addr + CPG_RSTMON_7_REG, BIT_NUM_RSTMON, 0x1u))
+    {
+        ret = R_DRPAI_ERR_RESET;
+        goto end;
+    }
+
+    // Reset off setting.
+    cpg_set(cpg_base_addr + CPG_RST_15_REG, BIT_NUM_RST, 0x1u);
+    if (0 != cpg_check(cpg_base_addr + CPG_RSTMON_7_REG, BIT_NUM_RSTMON, 0x0u))
+    {
+        ret = R_DRPAI_ERR_RESET;
+        goto end;
+    }
+
+    goto end;
+
+end:
+    return ret;
+}
+
+//==================================================================================================================
+// Procedure of changing DRP-AI clock (for debug).
+//==================================================================================================================
+static void set_drp_maxfreq(addr_t drp_base_addr, uint32_t mindiv)
+{
+    iowrite32(mindiv, drp_base_addr + DRP_MINDIV);
+}
+
+static void set_aimac_freq(addr_t aimac_base_addr, uint32_t divfix)
+{
+    iowrite32(divfix << 16, aimac_base_addr + EXD0_STPC_BADDR + STPC_CLKSW_CONFIG);
+}
+
+//==================================================================================================================
+// reg check loop
+//==================================================================================================================
+static int32_t loop_w(addr_t raddr, uint32_t exp_data, uint32_t mask)
+{
+    int32_t ret = -1;
+    uint32_t loop;
+
+    loop = 0;
+    while ((100 > loop) && (0 != ret))
+    {
+        if (0 == check_reg(raddr, exp_data, ~mask, 0))
+        {
+            ret = 0;
+            break;
+        }
+        udelay(1);
+        loop++;
+    }
+
+    loop = 0;
+    while ((100 > loop) && (0 != ret))
+    {
+        if (0 == check_reg(raddr, exp_data, ~mask, 0))
+        {
+            ret = 0;
+            break;
+        }
+        usleep_range(100, 200);
+        loop++;
+    }
+
+    return ret;
+}
+
+static int32_t check_reg(addr_t raddr, uint32_t exp, uint32_t mask0, uint32_t mask1)
+{
+    int32_t result = -1;
+    uint32_t rdata = ioread32(raddr);
+
+    if ((0 != mask0) && (0 == mask1))
+    {
+        if ((rdata & mask0) == (exp & mask0))
+        {
+            result = 0;
+        }
+    }
+    else if ((0 == mask0) && (0 != mask1))
+    {
+        if ((rdata & mask1) == (exp & mask1))
+        {
+            result = 0;
+        }
+    }
+    else if ((0 != mask0) && (0 != mask1))
+    {
+        if (((rdata & mask0) == (exp & mask0)) || ((rdata & mask1) == (exp & mask1)))
+        {
+            result = 0;
+        }
+    }
+
+    return result;
+}
+
+//==================================================================================================================
+// CPG function
+//==================================================================================================================
+int32_t initialize_cpg(addr_t cpg_base_addr)
+{
+    int32_t ret = R_DRPAI_SUCCESS;
+
+    // PLLETH
+    cpg_set(cpg_base_addr + CPG_PLLETH_STBY_REG, 0, 0x1u);
+
+    // PLLETH_MON
+    if (0 != loop_w(cpg_base_addr + CPG_PLLETH_MON_REG, 0x00000010u, 0xFFFFFFEFu))
+    {
+        goto error_init;
+    }
+
+    // MSTOP
+    cpg_set(cpg_base_addr + CPG_BUS_8_MSTOP_REG, 12, 0x0u);  // DRP_SRAM0
+    cpg_set(cpg_base_addr + CPG_BUS_8_MSTOP_REG, 13, 0x0u);  // DRP_SRAM1
+    cpg_set(cpg_base_addr + CPG_BUS_8_MSTOP_REG, 14, 0x0u);  // DRP_SRAM2
+    cpg_set(cpg_base_addr + CPG_BUS_8_MSTOP_REG, 15, 0x0u);  // DRP_SRAM3
+    cpg_set(cpg_base_addr + CPG_BUS_9_MSTOP_REG,  0, 0x0u);  // DRP_SRAM4
+    cpg_set(cpg_base_addr + CPG_BUS_9_MSTOP_REG,  1, 0x0u);  // DRP_SRAM5
+    cpg_set(cpg_base_addr + CPG_BUS_9_MSTOP_REG,  2, 0x0u);  // DRP_SRAM6
+    cpg_set(cpg_base_addr + CPG_BUS_9_MSTOP_REG,  3, 0x0u);  // DRP_SRAM7
+    cpg_set(cpg_base_addr + CPG_BUS_8_MSTOP_REG,  8, 0x0u);  // AIMAC
+    cpg_set(cpg_base_addr + CPG_BUS_8_MSTOP_REG,  9, 0x0u);  // STP
+    cpg_set(cpg_base_addr + CPG_BUS_8_MSTOP_REG, 10, 0x0u);  // DRP
+
+    cpg_set(cpg_base_addr + CPG_BUS_12_MSTOP_REG, 1, 0x0u);
+    cpg_set(cpg_base_addr + CPG_BUS_12_MSTOP_REG, 2, 0x0u);
+    cpg_set(cpg_base_addr + CPG_BUS_12_MSTOP_REG, 3, 0x0u);
+    cpg_set(cpg_base_addr + CPG_BUS_12_MSTOP_REG, 4, 0x0u);
+    cpg_set(cpg_base_addr + CPG_BUS_12_MSTOP_REG, 5, 0x0u);
+    cpg_set(cpg_base_addr + CPG_BUS_12_MSTOP_REG, 6, 0x0u);
+    cpg_set(cpg_base_addr + CPG_BUS_12_MSTOP_REG, 7, 0x0u);
+    cpg_set(cpg_base_addr + CPG_BUS_12_MSTOP_REG, 8, 0x0u);
+
+    // CLK_ON
+    cpg_set(cpg_base_addr + CPG_CLKON_1_REG,  8, 0x1u);  // SRAM_0
+    cpg_set(cpg_base_addr + CPG_CLKON_1_REG,  9, 0x1u);  // SRAM_1
+    cpg_set(cpg_base_addr + CPG_CLKON_1_REG, 10, 0x1u);  // SRAM_2
+    cpg_set(cpg_base_addr + CPG_CLKON_1_REG, 11, 0x1u);  // SRAM_3
+    cpg_set(cpg_base_addr + CPG_CLKON_1_REG, 12, 0x1u);  // SRAM_4
+    cpg_set(cpg_base_addr + CPG_CLKON_1_REG, 13, 0x1u);  // SRAM_5
+    cpg_set(cpg_base_addr + CPG_CLKON_1_REG, 14, 0x1u);  // SRAM_6
+    cpg_set(cpg_base_addr + CPG_CLKON_1_REG, 15, 0x1u);  // SRAM_7
+    cpg_set(cpg_base_addr + CPG_CLKON_17_REG, 0, 0x1u);  // DRP.DCLKIN
+    cpg_set(cpg_base_addr + CPG_CLKON_17_REG, 1, 0x1u);  // DRP.ACLK
+    cpg_set(cpg_base_addr + CPG_CLKON_17_REG, 2, 0x1u);  // DRP.INITCLK
+    cpg_set(cpg_base_addr + CPG_CLKON_17_REG, 3, 0x1u);  // DRPAI.DCLKIN
+    cpg_set(cpg_base_addr + CPG_CLKON_17_REG, 4, 0x1u);  // DRPAI.ACLK
+    cpg_set(cpg_base_addr + CPG_CLKON_17_REG, 5, 0x1u);  // DRPAI.INITCLK
+    cpg_set(cpg_base_addr + CPG_CLKON_17_REG, 6, 0x1u);  // DRPAI.MCLK
+
+    // CLK_MON
+    if (0 != cpg_check(cpg_base_addr + CPG_CLKMON_0_REG, 24, 0x1u))  // SRAM_0
+    {
+        goto error_init;
+    }
+    if (0 != cpg_check(cpg_base_addr + CPG_CLKMON_0_REG, 25, 0x1u))  // SRAM_1
+    {
+        goto error_init;
+    }
+    if (0 != cpg_check(cpg_base_addr + CPG_CLKMON_0_REG, 26, 0x1u))  // SRAM_2
+    {
+        goto error_init;
+    }
+    if (0 != cpg_check(cpg_base_addr + CPG_CLKMON_0_REG, 27, 0x1u))  // SRAM_3
+    {
+        goto error_init;
+    }
+    if (0 != cpg_check(cpg_base_addr + CPG_CLKMON_0_REG, 28, 0x1u))  // SRAM_4
+    {
+        goto error_init;
+    }
+    if (0 != cpg_check(cpg_base_addr + CPG_CLKMON_0_REG, 29, 0x1u))  // SRAM_5
+    {
+        goto error_init;
+    }
+    if (0 != cpg_check(cpg_base_addr + CPG_CLKMON_0_REG, 30, 0x1u))  // SRAM_6
+    {
+        goto error_init;
+    }
+    if (0 != cpg_check(cpg_base_addr + CPG_CLKMON_0_REG, 31, 0x1u))  // SRAM_7
+    {
+        goto error_init;
+    }
+    if (0 != cpg_check(cpg_base_addr + CPG_CLKMON_8_REG, 16, 0x1u))  // DRP.DCLK
+    {
+        goto error_init;
+    }
+    if (0 != cpg_check(cpg_base_addr + CPG_CLKMON_8_REG, 17, 0x1u))  // DRP.ACLK
+    {
+        goto error_init;
+    }
+    if (0 != cpg_check(cpg_base_addr + CPG_CLKMON_8_REG, 18, 0x1u))  // DRP.INITCLK
+    {
+        goto error_init;
+    }
+    if (0 != cpg_check(cpg_base_addr + CPG_CLKMON_8_REG, 19, 0x1u))  // DRPAI.DCLK
+    {
+        goto error_init;
+    }
+    if (0 != cpg_check(cpg_base_addr + CPG_CLKMON_8_REG, 20, 0x1u))  // DRPAI.ACLK
+    {
+        goto error_init;
+    }
+    if (0 != cpg_check(cpg_base_addr + CPG_CLKMON_8_REG, 21, 0x1u))  // DRPAI.INITCLK
+    {
+        goto error_init;
+    }
+    if (0 != cpg_check(cpg_base_addr + CPG_CLKMON_8_REG, 22, 0x1u))  // DRPAI.MCLK
+    {
+        goto error_init;
+    }
+
+    // Reset OFF
+    cpg_set(cpg_base_addr + CPG_RST_3_REG,  14, 0x1u);  // SRAM_0
+    cpg_set(cpg_base_addr + CPG_RST_3_REG,  15, 0x1u);  // SRAM_1
+    cpg_set(cpg_base_addr + CPG_RST_4_REG,   0, 0x1u);  // SRAM_2
+    cpg_set(cpg_base_addr + CPG_RST_4_REG,   1, 0x1u);  // SRAM_3
+    cpg_set(cpg_base_addr + CPG_RST_4_REG,   2, 0x1u);  // SRAM_4
+    cpg_set(cpg_base_addr + CPG_RST_4_REG,   3, 0x1u);  // SRAM_5
+    cpg_set(cpg_base_addr + CPG_RST_4_REG,   4, 0x1u);  // SRAM_6
+    cpg_set(cpg_base_addr + CPG_RST_4_REG,   5, 0x1u);  // SRAM_7
+    cpg_set(cpg_base_addr + CPG_RST_15_REG, 12, 0x1u);  // DRP.ARESETn
+    cpg_set(cpg_base_addr + CPG_RST_15_REG, 13, 0x1u);  // DRPAI.ARESETn
+
+    // RSTMON
+    if (0 != cpg_check(cpg_base_addr + CPG_RSTMON_1_REG, 15, 0x0u))  // SRAM_0
+    {
+        goto error_init;
+    }
+    if (0 != cpg_check(cpg_base_addr + CPG_RSTMON_1_REG, 16, 0x0u))  // SRAM_1
+    {
+        goto error_init;
+    }
+    if (0 != cpg_check(cpg_base_addr + CPG_RSTMON_1_REG, 17, 0x0u))  // SRAM_2
+    {
+        goto error_init;
+    }
+    if (0 != cpg_check(cpg_base_addr + CPG_RSTMON_1_REG, 18, 0x0u))  // SRAM_3
+    {
+        goto error_init;
+    }
+    if (0 != cpg_check(cpg_base_addr + CPG_RSTMON_1_REG, 19, 0x0u))  // SRAM_4
+    {
+        goto error_init;
+    }
+    if (0 != cpg_check(cpg_base_addr + CPG_RSTMON_1_REG, 20, 0x0u))  // SRAM_5
+    {
+        goto error_init;
+    }
+    if (0 != cpg_check(cpg_base_addr + CPG_RSTMON_1_REG, 21, 0x0u))  // SRAM_6
+    {
+        goto error_init;
+    }
+    if (0 != cpg_check(cpg_base_addr + CPG_RSTMON_1_REG, 22, 0x0u))  // SRAM_7
+    {
+        goto error_init;
+    }
+    if (0 != cpg_check(cpg_base_addr + CPG_RSTMON_7_REG, 13, 0x0u))  // DRP.ARESETn
+    {
+        goto error_init;
+    }
+    if (0 != cpg_check(cpg_base_addr + CPG_RSTMON_7_REG, 14, 0x0u))  // DRPAI.ARESETn
+    {
+        goto error_init;
+    }
+
+    goto end;
+
+error_init:
+    ret = R_DRPAI_ERR_INIT;
+    goto end;
+
+end:
+    return ret;
+}
+
+static void cpg_set(addr_t addr, int32_t bit, uint32_t val)
+{
+    uint32_t rdata;
+
+    rdata = ioread32(addr);
+    rdata = (rdata >> bit) & 1;
+
+    if (rdata != val)
+    {
+        uint32_t wdata = (1 << (bit + 16)) + (val << bit);
+
+        iowrite32(wdata, addr);
+    }
+}
+
+static int32_t cpg_check(addr_t addr, int32_t bit, uint32_t val)
+{
+    int32_t ret = -1;
+    uint32_t loop;
+
+    loop = 0;
+    while ((100 > loop) && (0 != ret))
+    {
+        if (0 == check_reg(addr, (val << bit), (1 << bit), 0))
+        {
+            ret = 0;
+            break;
+        }
+        udelay(1);
+        loop++;
+    }
+
+    loop = 0;
+    while ((100 > loop) && (0 != ret))
+    {
+        if (0 == check_reg(addr, (val << bit), (1 << bit), 0))
+        {
+            ret = 0;
+            break;
+        }
+        usleep_range(100, 200);
+        loop++;
+    }
+
+    return ret;
+}
+
+#ifndef __KERNEL__
+/* about 3.9 sec maximum. */
+static void mdelay(uint32_t msecs)
+{
+    volatile uint32_t i;
+
+    for (i = 0; i < msecs * 1100000; i++);
+}
+#endif
+
+#ifdef __KERNEL__
+#if 1
+/* V2H conditional compilation */
+MODULE_DESCRIPTION("RZ/V2H DRPAI driver");
+#endif
+MODULE_AUTHOR("Renesas Electronics Corporation");
+MODULE_LICENSE("GPL v2");
+#endif
diff --git b/drivers/drpai/drpai-core.h b/drivers/drpai/drpai-core.h
new file mode 100644
index 0000000..d3f7ef4
--- /dev/null
+++ b/drivers/drpai/drpai-core.h
@@ -0,0 +1,120 @@
+/*
+ * Driver for the Renesas RZ/V2H DRP-AI unit
+ *
+ * Copyright (C) 2023 Renesas Electronics Corporation
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef DRPAI__H
+#define DRPAI__H
+
+//------------------------------------------------------------------------------------------------------------------
+// include
+//------------------------------------------------------------------------------------------------------------------
+#ifdef __KERNEL__
+#include <linux/types.h>  /* for stdint */
+#else
+#include <stdint.h>
+#endif
+
+//------------------------------------------------------------------------------------------------------------------
+// Macro
+//------------------------------------------------------------------------------------------------------------------
+#define R_DRPAI_SUCCESS                     (0)
+#define R_DRPAI_ERR_INVALID_ARG             (-1)
+#define R_DRPAI_ERR_INIT                    (-2)
+#define R_DRPAI_ERR_INT                     (-3)
+#define R_DRPAI_ERR_STOP                    (-4)
+#define R_DRPAI_ERR_RESET                   (-5)
+
+/* reserved */
+#define DRPAI_RESERVED_STP_DSCC_PAMON       (0)
+#define DRPAI_RESERVED_EXD0_DSCC_PAMON      (1)
+#define DRPAI_RESERVED_AID0_DSCC_PAMON      (2)
+#define DRPAI_RESERVED_ADRCONV_CTL          (3)
+#define DRPAI_RESERVED_EXD0_ADRCONV_CTL     (4)
+#define DRPAI_RESERVED_SYNCTBL_TBL13        (5)
+#define DRPAI_RESERVED_SYNCTBL_TBL14        (6)
+#define DRPAI_RESERVED_SYNCTBL_TBL15        (7)
+
+/* reserved AIMAC Nmlint */
+#define DRPAI_RESERVED_INTMON_INT           (16)
+#define DRPAI_RESERVED_EXD0_STPC_INT_STS    (17)
+#define DRPAI_RESERVED_EXD0_ODMACIF         (18)
+#define DRPAI_RESERVED_EXD1_STPC_INT_STS    (19)
+#define DRPAI_RESERVED_EXD1_ODMACIF         (20)
+#define DRPAI_RESERVED_EXD0_ODIF_INTCNTO0   (21)
+#define DRPAI_RESERVED_EXD0_ODIF_INTCNTO1   (22)
+#define DRPAI_RESERVED_EXD1_ODIF_INTCNTO0   (23)
+#define DRPAI_RESERVED_EXD1_ODIF_INTCNTO1   (24)
+
+/* for CPG reset */
+#define CPG_RESET_SUCCESS                   (0)
+#define RST_MAX_TIMEOUT                     (100)
+
+/* Debug macro (for only kernel) */
+// #define DRPAI_DRV_DEBUG
+#ifdef DRPAI_DRV_DEBUG
+#define DRPAI_DEBUG_PRINT(fmt, ...) \
+            pr_info("[%s: %d](pid: %d) "fmt, \
+                            __func__, __LINE__, current->pid, ##__VA_ARGS__)
+#else
+#define DRPAI_DEBUG_PRINT(...)
+#endif
+
+//------------------------------------------------------------------------------------------------------------------
+// typedef
+//------------------------------------------------------------------------------------------------------------------
+#ifdef __KERNEL__
+typedef void __iomem* addr_t;
+#else
+typedef uint64_t addr_t;
+#endif
+
+typedef struct drpai_odif_intcnto
+{
+    uint32_t    ch0;
+    uint32_t    ch1;
+    uint32_t    ch2;
+    uint32_t    ch3;
+} drpai_odif_intcnto_t;
+
+//------------------------------------------------------------------------------------------------------------------
+// Prototype
+//------------------------------------------------------------------------------------------------------------------
+void    R_DRPAI_DRP_Open(addr_t drp_base_addr, int32_t ch);
+void    R_DRPAI_DRP_Start(addr_t drp_base_addr, int32_t ch, uint64_t desc);
+int32_t R_DRPAI_DRP_Stop(addr_t drp_base_addr, int32_t ch);
+int32_t R_DRPAI_DRP_SetMaxFreq(addr_t drp_base_addr, int32_t ch, uint32_t mindiv);
+int32_t R_DRPAI_DRP_EnableAddrReloc(addr_t drp_base_addr, uint8_t* tbl);
+void    R_DRPAI_DRP_DisableAddrReloc(addr_t drp_base_addr);
+int32_t R_DRPAI_DRP_Reset(addr_t drp_base_addr, int32_t ch);
+void    R_DRPAI_DRP_Errint(addr_t drp_base_addr, addr_t aimac_base_addr, int32_t ch);
+void    R_DRPAI_AIMAC_Open(addr_t aimac_base_addr, int32_t ch);
+void    R_DRPAI_AIMAC_Start(addr_t aimac_base_addr, int32_t ch, uint64_t cmd_desc, uint64_t param_desc);
+int32_t R_DRPAI_AIMAC_Stop(addr_t aimac_base_addr, int32_t ch);
+int32_t R_DRPAI_AIMAC_SetFreq(addr_t aimac_base_addr, int32_t ch, uint32_t divfix);
+int32_t R_DRPAI_AIMAC_EnableAddrReloc(addr_t aimac_base_addr, uint8_t* tbl);
+void    R_DRPAI_AIMAC_DisableAddrReloc(addr_t aimac_base_addr);
+int32_t R_DRPAI_AIMAC_Reset(addr_t aimac_base_addr, int32_t ch);
+int32_t R_DRPAI_AIMAC_Nmlint(addr_t aimac_base_addr, int32_t ch, uint32_t* reserved);
+void    R_DRPAI_AIMAC_Errint(addr_t drp_base_addr, addr_t aimac_base_addr, int32_t ch);
+void    R_DRPAI_Status(addr_t drp_base_addr, addr_t aimac_base_addr, int32_t ch, uint32_t* reserved);
+int32_t R_DRPAI_DRP_RegRead(addr_t drp_base_addr, uint32_t offset, uint32_t* pvalue);
+void    R_DRPAI_DRP_RegWrite(addr_t drp_base_addr, uint32_t offset, uint32_t value);
+int32_t R_DRPAI_AIMAC_RegRead(addr_t aimac_base_addr, uint32_t offset, uint32_t* pvalue);
+void    R_DRPAI_AIMAC_RegWrite(addr_t aimac_base_addr, uint32_t offset, uint32_t value);
+
+int32_t initialize_cpg(addr_t cpg_base_addr);
+int32_t reset_cpg(addr_t cpg_base_addr, int32_t ch);
+
+#endif /* DRPAI__H */
diff --git b/drivers/drpai/drpai-if.c b/drivers/drpai/drpai-if.c
new file mode 100644
index 0000000..f61c155
--- /dev/null
+++ b/drivers/drpai/drpai-if.c
@@ -0,0 +1,4325 @@
+/*
+ * Driver for the Renesas RZ/V2H DRP-AI unit
+ *
+ * Copyright (C) 2024 Renesas Electronics Corporation
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <asm/cacheflush.h>
+#include <asm/current.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/miscdevice.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/pm.h>
+#include <linux/poll.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/uaccess.h>
+#include <linux/wait.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include <linux/buffer_head.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/reset.h>
+#include <linux/drpai.h>    /* Header file for DRP-AI Driver */
+#include "drpai-core.h"     /* Header file for DRP-AI Core */
+
+// #define DRPAI_DRV_DEBUG_WAIT
+#ifdef DRPAI_DRV_DEBUG_WAIT
+#define DRPAI_DEBUG_WAIT(...) msleep(1100);
+#else
+#define DRPAI_DEBUG_WAIT(...)
+#endif
+
+#ifdef DRPAI_DRV_DEBUG
+#define DRPAI_DRV_DEBUG_MODE        " (Debug Mode ON)"
+#else
+#define DRPAI_DRV_DEBUG_MODE        ""
+#endif
+
+#ifdef DRPAI_DRV_DEBUG_WAIT
+#define DRPAI_DRV_DEBUG_WAIT_MODE   " (Debug Wait Mode ON)"
+#else
+#define DRPAI_DRV_DEBUG_WAIT_MODE   ""
+#endif
+
+/*Macro definitions*/
+#define DRPAI_DRIVER_VERSION        "1.01 rel.1"
+#define DRPAI_DEV_NUM               (1)
+#define DRPAI_DRIVER_NAME           "drpai"     /* Device name */
+#define DRPAI_64BYTE_ALIGN          (0x3F)      /* Check 64-byte alignment */
+#define DRPAI_MAX_24BIT             (0xFFFFFF)
+#define DRPAI_INF_24BIT             (0x1000000)
+#define DRPAI_MAX_32BIT             (0xFFFFFFFF)
+#define DRPAI_INF_32BIT             (0x100000000uLL)
+#define DRPAI_MAX_40BIT             (0xFFFFFFFFFFuLL)
+#define DRPAI_INF_40BIT             (0x10000000000uLL)
+#define DRPAI_ADRCONV_TBL_NUM       (256)
+#define DRPAI_ADRCONV_NUM           ((DRPAI_ADRCONV_TBL_NUM) * 4)
+#define DRPAI_SRAM_ADDR             (0x08200000)
+#define DRPAI_SRAM_SIZE             (0x00400000)
+
+#define DRPAI_STATUS_IDLE_RW        (10)
+#define DRPAI_STATUS_ASSIGN         (11)
+#define DRPAI_STATUS_DUMP_REG       (12)
+#define DRPAI_STATUS_READ_MEM       (13)
+#define DRPAI_STATUS_READ_REG       (14)
+#define DRPAI_STATUS_WRITE          (15)
+#define DRPAI_STATUS_ASSIGN_PARAM   (16)
+#define DRPAI_STATUS_WRITE_PARAM    (17)
+
+#define MAX_SEM_TIMEOUT             (msecs_to_jiffies(1000))
+#define HEAD_SENTINEL               (UINT_MAX)
+
+#define DRP_DESC_ENTRY_SIZE         (16)
+#define DRP_DESC_TYPE_INDEX         (3)
+#define DRP_DESC_TYPE_RSHIFT        (3)
+#define DRP_DESC_TYPE_MASK          (0x01)
+#define DRP_DESC_CF_INDEX           (3)
+#define DRP_DESC_CF_RSHIFT          (4)
+#define DRP_DESC_CF_MASK            (0x0F)
+#define DRP_DESC_MOD_INDEX          (1)
+#define DRP_DESC_MOD_RSHIFT         (6)
+#define DRP_DESC_MOD_MASK           (0x03)
+#define DRP_DESC_FUNC_INDEX         (1)
+#define DRP_DESC_FUNC_RSHIFT        (2)
+#define DRP_DESC_FUNC_MASK          (0x01)
+#define DRP_DESC_CF_DRP_DMA         (0)
+#define DRP_DESC_CF_AIMAC_DMA0      (8)
+#define DRP_DESC_CF_AIMAC_DMA1      (9)
+#define DRP_DESC_CF_AIMAC_DMA2      (12)
+#define DRP_DESC_CF_AIMAC_DMA3      (13)
+#define DRP_DESC_CF_AIMAC_PARAM     (5)
+#define DRP_DESC_CF_CFG_LOAD        (1)
+#define DRP_DESC_ADDR_INDEX         (4)
+
+#define DRP_PARAM_raddr             (0)
+#define DRP_PARAM_waddr             (4)
+#define DRP_PARAM_IMG_IWIDTH        (8)
+#define DRP_PARAM_IMG_IHEIGHT       (10)
+#define DRP_PARAM_IMG_OWIDTH        (16)
+#define DRP_PARAM_IMG_OHEIGHT       (18)
+#define DRP_PARAM_CROP_POS_X        (48)
+#define DRP_PARAM_CROP_POS_Y        (50)
+#define DRP_LIB_NAME_CROP           (",drp_lib:crop,")
+#define DRP_PARAM_ATTR_OFFSET_ADD   ("OFFSET_ADD:")
+#define DRP_PARAM_ATTR_PROP_INPUT   (",prop:input,")
+#define DRP_PARAM_ATTR_PROP_OUTPUT  (",prop:output,")
+#define DRP_PARAM_ATTR_PARAM        ("Param:")
+#define DRP_PARAM_ATTR_OFFSET       ("offset:")
+#define DRP_PARAM_NAME_RADDR        ("raddr")
+#define DRP_PARAM_NAME_WADDR        ("waddr")
+#define DRP_PARAM_NAME_ADDR         ("_ADDR")
+
+#define SYS_SIZE                    (1024)
+#define SYS_DRP_BANK                (0x38)
+#define SYS_MASK_DRP                (0x000000C0)
+#define SYS_SHIFT                   (26)
+
+#if 1 /* for CPG direct access (preliminary) */
+#define CPG_SIZE                    (0x10000)
+#define CPG_BASE_ADDRESS            (0x10420000uLL)
+#endif
+
+#define IRQ_CHECK_ENABLE            (1)
+#define IRQ_CHECK_DISABLE           (0)
+
+/* from drpai-core.h */
+#define DEVICE_RZV2M                (0)
+#define DEVICE_RZV2MA               (1)
+#define DEVICE_RZV2L                (2)
+#define DEVICE_RZV2H                (3)
+
+#if 1
+/* V2H conditional compilation */
+#define DRP_CH_NUM                  (2)
+#define AIMAC_CH_NUM                (1)
+#elif 0
+/* V2L conditional compilation */
+#define DRP_CH_NUM                  (1)
+#define AIMAC_CH_NUM                (1)
+#endif
+
+/* V2L conditional compilation */
+#if 0
+#define ISP_FINISH_SUCCESS          (0)
+#define DRPAI_SGL_DRP_DESC_SIZE     (80)
+#define DRPAI_DESC_CMD_SIZE         (16)
+#define DRPAI_CMA_SIZE              ((DRPAI_SGL_DRP_DESC_SIZE * DRPAI_SEQ_NUM) + DRPAI_DESC_CMD_SIZE + 64)
+#endif
+
+/* A function called from the kernel */
+static int drpai_probe(struct platform_device *pdev);
+static int drpai_remove(struct platform_device *pdev);
+static int drpai_open(struct inode *inode, struct file *file);
+static int drpai_close(struct inode *inode, struct file *file);
+static int drpai_flush(struct file *file, fl_owner_t id);
+static ssize_t  drpai_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos);
+static ssize_t  drpai_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos);
+static long drpai_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);
+static unsigned int drpai_poll( struct file* filp, poll_table* wait );
+static irqreturn_t irq_drp_errint(int irq, void *dev);
+static irqreturn_t irq_mac_nmlint(int irq, void *dev);
+static irqreturn_t irq_mac_errint(int irq, void *dev);
+/* V2L conditional compilation */
+#if 0
+static irqreturn_t irq_drp_nmlint(int irq, void *dev);
+#endif
+
+/* Internal function */
+static int drpai_regist_driver(void);
+static int drpai_regist_device(struct platform_device *pdev);
+static void drpai_unregist_driver(void);
+static void drpai_unregist_device(void);
+static void drpai_init_device(uint32_t ch);
+static int8_t drpai_reset_device(uint32_t ch);
+static long drpai_ioctl_assign(struct file *filp, unsigned int cmd, unsigned long arg);
+static long drpai_ioctl_start(struct file *filp, unsigned int cmd, unsigned long arg);
+static long drpai_ioctl_get_status(struct file *filp, unsigned int cmd, unsigned long arg);
+static long drpai_ioctl_reset(struct file *filp, unsigned int cmd, unsigned long arg);
+static long drpai_ioctl_reg_dump(struct file *filp, unsigned int cmd, unsigned long arg);
+static long drpai_ioctl_assign_param(struct file *filp, unsigned int cmd, unsigned long arg);
+static long drpai_ioctl_prepost_crop(struct file *filp, unsigned int cmd, unsigned long arg);
+static long drpai_ioctl_prepost_inaddr(struct file *filp, unsigned int cmd, unsigned long arg);
+static long drpai_ioctl_get_drpai_area(struct file *filp, unsigned int cmd, unsigned long arg);
+static long drpai_ioctl_set_drp_max_freq(struct file *filp, unsigned int cmd, unsigned long arg);
+static long drpai_ioctl_set_drpai_freq(struct file *filp, unsigned int cmd, unsigned long arg);
+static long drpai_ioctl_set_adrconv(struct file *filp, unsigned int cmd, unsigned long arg);
+static long drpai_ioctl_set_extra_area(struct file *filp, unsigned int cmd, unsigned long arg);
+/* V2L conditional compilation */
+#if 0
+static long drpai_ioctl_set_seq(struct file *filp, unsigned int cmd, unsigned long arg);
+#endif
+static int32_t reverse_adrconv_tbl(uint8_t *adrconv_tbl, uint64_t conv, uint32_t *org);
+static char *get_param_attr(char *line, char *attr, unsigned long *rvalue, char **str);
+static int8_t drp_param_change16(uint64_t base, uint64_t offset, uint16_t value);
+static int8_t drp_param_change32(uint64_t base, uint64_t offset, uint32_t value);
+static int32_t drpai_check_area(uint64_t addr, uint64_t size);
+static int8_t drpai_flush_dcache_input_area(uint64_t addr, uint64_t size);
+static int drpai_drp_cpg_init(void);
+static int drpai_open_process(void);
+static int drpai_close_process(void);
+
+/* V2L conditional compilation */
+#if 0
+/* DRP init function for V2L simple ISP */
+static int drpai_drp_config_init(void);
+static void drpai_drp_config_uninit(void);
+
+/* Function called from the kernel for V2L simple ISP */
+int drpai_open_k(void);
+int drpai_close_k(void);
+int drpai_start_k(drpai_data_t *arg, void (*isp_finish)(int result));
+#endif
+
+static long drpai_ioctl_read_drp_reg(struct file *filp, unsigned int cmd, unsigned long arg);
+static long drpai_ioctl_write_drp_reg(struct file *filp, unsigned int cmd, unsigned long arg);
+static long drpai_ioctl_read_drpai_reg(struct file *filp, unsigned int cmd, unsigned long arg);
+static long drpai_ioctl_write_drpai_reg(struct file *filp, unsigned int cmd, unsigned long arg);
+static long drpai_ioctl_read_cpg_reg(struct file *filp, unsigned int cmd, unsigned long arg);
+static long drpai_ioctl_write_cpg_reg(struct file *filp, unsigned int cmd, unsigned long arg);
+
+/* Linux device driver initialization */
+static const unsigned int MINOR_BASE = 0;
+static const unsigned int MINOR_NUM  = DRPAI_DEV_NUM;       /* Minor number */
+static unsigned int drpai_major;                    /* Major number (decided dinamically) */
+static struct cdev drpai_cdev;                      /* Character device object */
+static struct class *drpai_class = NULL;            /* class object */
+struct device *drpai_device_array[DRPAI_DEV_NUM];
+
+/* Type definitions */
+struct drpai_priv
+{
+    struct platform_device *pdev;
+    const char *dev_name;
+    uint8_t dev_tag;
+    drpai_status_t drpai_status;
+    spinlock_t lock;
+    struct semaphore sem;
+    refcount_t count;
+    void __iomem *drp_base;
+    void __iomem *aimac_base;
+    struct reset_control *rstc;
+    uint32_t irq_flag;
+
+/* V2L conditional compilation */
+#if 0
+/* V2L ISP */
+    struct clk *clk_int;
+    struct clk *clk_aclk_drp;
+    struct clk *clk_mclk;
+    struct clk *clk_dclkin;
+    struct clk *clk_aclk;
+    void (*isp_finish_loc)(int);
+#endif
+};
+
+static DECLARE_WAIT_QUEUE_HEAD(drpai_waitq);
+
+static struct drpai_priv *drpai_priv;
+
+struct drpai_rw_status
+{
+    uint32_t rw_status;
+    uint64_t read_count;
+    uint64_t write_count;
+    uint32_t drp_reg_offset_count;
+    uint32_t aimac_reg_offset_count;
+    drpai_data_t drpai_data;
+    struct list_head list;
+    drpai_assign_param_t assign_param;
+    char *param_info;
+    atomic_t inout_flag;
+    uint32_t get_drpai_area_count;
+    uint32_t image_region_vaddr;
+    uint32_t image_region_vnum;
+    int32_t adrconv_en;
+    uint8_t adrconv_tbl[DRPAI_ADRCONV_NUM];
+    uint32_t drp_mindiv;
+    uint32_t drpai_divfix;
+};
+
+static DEFINE_SEMAPHORE(rw_sem);
+static struct drpai_rw_status *drpai_rw_sentinel;
+
+/* Virtual base address of register */
+static void __iomem *drp_base_addr[DRP_CH_NUM];
+static void __iomem *aimac_base_address[AIMAC_CH_NUM];
+#if 1 /* for CPG direct access (preliminary) */
+static void __iomem *cpg_base_address;
+#endif
+static resource_size_t drp_size;
+static resource_size_t aimac_size;
+#if 1 /* for CPG direct access (preliminary) */
+static resource_size_t cpg_size;
+#endif
+static resource_size_t drpai_region_base_addr;
+static resource_size_t drpai_region_size;
+static resource_size_t drpai_region2_base_addr;
+static resource_size_t drpai_region2_size;
+static resource_size_t drpai_linux_mem_start;
+static resource_size_t drpai_linux_mem_size;
+static resource_size_t drpai_linux_mem2_start;
+static resource_size_t drpai_linux_mem2_size;
+static resource_size_t drpai_linux_mem3_start;
+static resource_size_t drpai_linux_mem3_size;
+static resource_size_t image_region_addr;
+static resource_size_t image_region_size;
+
+/* V2L conditional compilation */
+#if 0
+/* ISP */
+static char* p_dmabuf_vaddr;
+static dma_addr_t p_dmabuf_phyaddr;
+static unsigned char drp_single_desc_bin[] =
+{
+  0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x80, 0x00, 0x01, 0x00, 0x91, 0x81, 0x50, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x07, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x80, 0x00, 0x01, 0x00, 0x91, 0x81, 0x20, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+static drpai_seq_t seq;
+drpai_odif_intcnto_t odif_intcnto;
+static uint32_t exe_mode;
+/* ISP */
+#endif
+
+/* handler table */
+static struct file_operations s_mydevice_fops =
+{
+    .open           = drpai_open,
+    .release        = drpai_close,
+    .write          = drpai_write,
+    .read           = drpai_read,
+    .unlocked_ioctl = drpai_ioctl,
+    .compat_ioctl   = drpai_ioctl, /* for 32-bit App */
+    .poll           = drpai_poll,
+    .flush          = drpai_flush,
+};
+
+static const struct of_device_id drpai_match[] =
+{
+    { .compatible = "renesas,rzv2ma-drpai",},
+    { .compatible = "renesas,rzv2m-drpai", },
+    { .compatible = "renesas,rzv2l-drpai", },
+    { .compatible = "renesas,rzv2h-drpai", },
+    { /* sentinel */ }
+};
+
+static struct platform_driver drpai_platform_driver =
+{
+    .driver = {
+        .name   = "drpai-rz",
+        .of_match_table = drpai_match,
+    },
+    .probe      = drpai_probe,
+    .remove     = drpai_remove,
+};
+
+static int drpai_probe(struct platform_device *pdev)
+{
+    int ret;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    ret = drpai_regist_driver();
+    if (0 != ret)
+    {
+        return ret;
+    }
+
+    ret = drpai_regist_device(pdev);
+    if (0 != ret)
+    {
+        drpai_unregist_driver();
+        return ret;
+    }
+
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return ret;
+}
+
+static int drpai_remove(struct platform_device *pdev)
+{
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    drpai_unregist_driver();
+    drpai_unregist_device();
+
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return 0;
+}
+
+static int drpai_open(struct inode *inode, struct file *file)
+{
+    int result = 0;
+    struct drpai_priv *priv = drpai_priv;
+    struct drpai_rw_status *drpai_rw_status = 0;
+    uint32_t tbl;
+    uint32_t offset;
+    uint32_t act_size;
+    uint32_t tbl_num;
+    uint32_t page;
+    uint32_t map;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+    DRPAI_DEBUG_PRINT("major %d minor %d\n", imajor(inode), iminor(inode));
+
+    /* Allocate drpai_rw_status to each file descriptor */
+    drpai_rw_status = kzalloc(sizeof(struct drpai_rw_status), GFP_KERNEL);
+    if (!drpai_rw_status)
+    {
+        result = -ENOMEM;
+        goto end;
+    }
+    /* Initialization flag */
+    drpai_rw_status->rw_status            = DRPAI_STATUS_IDLE_RW;
+    drpai_rw_status->param_info           = NULL;
+    drpai_rw_status->get_drpai_area_count = 0;
+    drpai_rw_status->adrconv_en           = 0;
+    for (tbl = 0; tbl < DRPAI_ADRCONV_NUM; tbl++)
+    {
+        drpai_rw_status->adrconv_tbl[tbl] = 0;
+    }
+    if (0 == image_region_size)
+    {
+        drpai_rw_status->image_region_vaddr = DRPAI_MAX_32BIT;
+        drpai_rw_status->image_region_vnum  = 0;
+    }
+    else
+    {
+        offset = ((uint32_t)image_region_addr & DRPAI_MAX_24BIT);
+        act_size = offset + (uint32_t)image_region_size;
+        tbl_num = (act_size >> 24);
+        tbl_num = (0 == (act_size & DRPAI_MAX_24BIT)) ? tbl_num : tbl_num + 1;
+
+        page = DRPAI_ADRCONV_TBL_NUM - tbl_num;
+        drpai_rw_status->image_region_vaddr = (uint32_t)((page << 24) | offset);
+
+        map = (image_region_addr >> 24);
+
+        for (tbl = page; tbl < (page + tbl_num); tbl++)
+        {
+            drpai_rw_status->adrconv_tbl[tbl * 4 + 0] = 1;             /* Valid           */
+            drpai_rw_status->adrconv_tbl[tbl * 4 + 1] = 0;             /* PG = 0 (16MB)   */
+            drpai_rw_status->adrconv_tbl[tbl * 4 + 2] = (map &  0xFF); /* MAP_ADDR[31:24] */
+            drpai_rw_status->adrconv_tbl[tbl * 4 + 3] = (map >>    8); /* MAP_ADDR[39:32] */
+            map++;
+        }
+
+        drpai_rw_status->image_region_vnum  = tbl_num;
+    }
+    drpai_rw_status->drp_mindiv   = 2;
+    drpai_rw_status->drpai_divfix = 1;
+    INIT_LIST_HEAD(&drpai_rw_status->list);
+    atomic_set(&drpai_rw_status->inout_flag, 0);
+    DRPAI_DEBUG_PRINT("Generated list %px rw_status %d prev %px next %px\n", &drpai_rw_status->list, drpai_rw_status->rw_status, drpai_rw_status->list.prev, drpai_rw_status->list.next);
+    file->private_data = drpai_rw_status;
+    DRPAI_DEBUG_PRINT("status1:   %d\n", priv->drpai_status.status);
+    DRPAI_DEBUG_PRINT("status_rw1:%d\n", drpai_rw_status->rw_status);
+
+    if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT)))
+    {
+        result = -ETIMEDOUT;
+        goto end;
+    }
+
+    if(1 == refcount_read(&priv->count))
+    {
+        result = drpai_open_process();
+        if(R_DRPAI_SUCCESS != result)
+        {
+            goto end;
+        }
+    }
+    /* Increment reference count */
+    refcount_inc(&priv->count);
+
+    DRPAI_DEBUG_PRINT("status2:   %d\n", priv->drpai_status.status);
+    DRPAI_DEBUG_PRINT("status_rw2:%d\n", drpai_rw_status->rw_status);
+
+    result = 0;
+
+    DRPAI_DEBUG_WAIT();
+    goto end;
+end:
+    if((-ENOMEM != result) || (-ETIMEDOUT != result))
+    {
+        up(&priv->sem);
+    }
+    if((0 != drpai_rw_status) && (0 != result))
+    {
+        kfree(file->private_data);
+        file->private_data = NULL;
+    }
+
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return result;
+}
+
+static int drpai_close(struct inode *inode, struct file *file)
+{
+    int result = 0;
+    struct drpai_priv *priv = drpai_priv;
+    struct drpai_rw_status *drpai_rw_status = file->private_data;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+    DRPAI_DEBUG_PRINT("major %d minor %d\n", imajor(inode), iminor(inode));
+
+    if(unlikely(down_interruptible(&rw_sem)))
+    {
+        /* Note: this errno won't be returned to user*/
+        result = -ERESTART;
+        DRPAI_DEBUG_PRINT("R/W semaphore obtained failed\n");
+        goto end;
+    }
+
+    DRPAI_DEBUG_PRINT("HEAD  list %px rw_status %d prev %px next %px\n", &drpai_rw_sentinel->list, drpai_rw_sentinel->rw_status, drpai_rw_sentinel->list.prev, drpai_rw_sentinel->list.next);
+    if(!list_empty(&drpai_rw_sentinel->list))
+    {
+        if((DRPAI_STATUS_ASSIGN         == drpai_rw_status->rw_status) ||
+           (DRPAI_STATUS_READ_MEM       == drpai_rw_status->rw_status) ||
+           (DRPAI_STATUS_WRITE          == drpai_rw_status->rw_status))
+           {
+                DRPAI_DEBUG_PRINT("Deleted list %px rw_status %d prev %px next %px\n", &drpai_rw_status->list, drpai_rw_status->rw_status, drpai_rw_status->list.prev, drpai_rw_status->list.next);
+                list_del(&drpai_rw_status->list);
+           }
+    }
+    up(&rw_sem);
+
+    if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT)))
+    {
+        /* Note: this errno won't be returned to user*/
+        result = -ETIMEDOUT;
+        DRPAI_DEBUG_PRINT("API semaphore obtained failed\n");
+        goto end;
+    }
+
+    DRPAI_DEBUG_PRINT("status1:   %d\n", priv->drpai_status.status);
+
+    if(2 == refcount_read(&priv->count))
+    {
+        result = drpai_close_process();
+        if(R_DRPAI_SUCCESS != result)
+        {
+            DRPAI_DEBUG_PRINT("Reset failed\n");
+        }
+    }
+    /* Decrement referenece count */
+    refcount_dec(&priv->count);
+
+    DRPAI_DEBUG_PRINT("status2:   %d\n", priv->drpai_status.status);
+
+    DRPAI_DEBUG_WAIT();
+    goto end;
+end:
+    if((-ERESTART != result) || (-ETIMEDOUT != result))
+    {
+        up(&priv->sem);
+    }
+    /* Free memory */
+    if(NULL != drpai_rw_status->param_info)
+    {
+        DRPAI_DEBUG_PRINT("vfree is called\n");
+        vfree(drpai_rw_status->param_info);
+        drpai_rw_status->param_info = NULL;
+    }
+    if(file->private_data)
+    {
+        DRPAI_DEBUG_PRINT("kfree is called\n");
+        kfree(file->private_data);
+        file->private_data = NULL;
+    }
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return result;
+}
+
+static int drpai_flush(struct file *file, fl_owner_t id)
+{
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    DRPAI_DEBUG_PRINT("end.\n");
+    return 0;
+}
+
+static ssize_t  drpai_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos)
+{
+    ssize_t result = 0;
+    volatile void *p_drpai_cma = 0;
+    struct drpai_rw_status *drpai_rw_status = filp->private_data;
+    uint64_t addr;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    if(unlikely(down_trylock(&rw_sem)))
+    {
+        result = -ERESTART;
+        goto end;
+    }
+
+    DRPAI_DEBUG_PRINT("status_rw1:%d\n", drpai_rw_status->rw_status);
+
+    /* Check status */
+    if (!((DRPAI_STATUS_ASSIGN         == drpai_rw_status->rw_status) ||
+          (DRPAI_STATUS_WRITE          == drpai_rw_status->rw_status) ||
+          (DRPAI_STATUS_ASSIGN_PARAM   == drpai_rw_status->rw_status) ||
+          (DRPAI_STATUS_WRITE_PARAM    == drpai_rw_status->rw_status)))
+    {
+        result = -EACCES;
+        goto end;
+    }
+
+    /* Check Argument */
+    if (NULL == buf)
+    {
+        result = -EFAULT;
+        goto end;
+    }
+    if (0 == count)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    switch(drpai_rw_status->rw_status)
+    {
+        case DRPAI_STATUS_ASSIGN:
+            /* DRPAI_STATUS_ASSIGN -> DRPAI_STATUS_WRITE */
+            drpai_rw_status->rw_status = DRPAI_STATUS_WRITE;
+            break;
+        case DRPAI_STATUS_ASSIGN_PARAM:
+            /* DRPAI_STATUS_ASSIGN_PARAM -> DRPAI_STATUS_WRITE_PARAM */
+            drpai_rw_status->rw_status = DRPAI_STATUS_WRITE_PARAM;
+            break;
+        default:
+            ; /* Do nothing */
+            break;
+    }
+    DRPAI_DEBUG_PRINT("status_rw2:%d\n", drpai_rw_status->rw_status);
+
+    switch(drpai_rw_status->rw_status)
+    {
+        case DRPAI_STATUS_WRITE:
+            /* Expand to DRP for CMA */
+            addr = drpai_rw_status->drpai_data.address;
+            p_drpai_cma = phys_to_virt(addr + drpai_rw_status->write_count);
+            if (p_drpai_cma == 0)
+            {
+                result = -EFAULT;
+                goto end;
+            }
+            if (drpai_rw_status->drpai_data.size < (drpai_rw_status->write_count + count))
+            {
+                count = drpai_rw_status->drpai_data.size - drpai_rw_status->write_count;
+            }
+            if (copy_from_user((void *)p_drpai_cma, buf, count))
+            {
+                result = -EFAULT;
+                goto end;
+            }
+            drpai_rw_status->write_count = drpai_rw_status->write_count + count;
+
+            /* DRPAI_STATUS_WRITE -> DRPAI_STATUS_IDLE_RW */
+            if (drpai_rw_status->drpai_data.size <= drpai_rw_status->write_count)
+            {
+                p_drpai_cma = phys_to_virt(addr);
+                if (p_drpai_cma == 0)
+                {
+                    result = -EFAULT;
+                    goto end;
+                }
+                __flush_dcache_area((void *)p_drpai_cma, drpai_rw_status->drpai_data.size);
+                drpai_rw_status->rw_status = DRPAI_STATUS_IDLE_RW;
+                DRPAI_DEBUG_PRINT("Deleted list %px rw_status %d prev %px next %px\n", &drpai_rw_status->list, drpai_rw_status->rw_status, drpai_rw_status->list.prev, drpai_rw_status->list.next);
+                list_del(&drpai_rw_status->list);
+                drpai_rw_status->drpai_data.address = 0x0;
+                drpai_rw_status->drpai_data.size    = 0x0;
+            }
+            result = count;
+            break;
+        case DRPAI_STATUS_WRITE_PARAM:
+            if (drpai_rw_status->assign_param.info_size < (drpai_rw_status->write_count + count))
+            {
+                count = drpai_rw_status->assign_param.info_size - drpai_rw_status->write_count;
+            }
+            /* Copy arguments from user space to kernel space */
+            if (copy_from_user(&drpai_rw_status->param_info[drpai_rw_status->write_count], buf, count))
+            {
+                result = -EFAULT;
+                goto end;
+            }
+            drpai_rw_status->write_count = drpai_rw_status->write_count + count;
+            /* DRPAI_STATUS_WRITE_PARAM -> DRPAI_STATUS_IDLE_RW */
+            if (drpai_rw_status->assign_param.info_size <= drpai_rw_status->write_count)
+            {
+                DRPAI_DEBUG_PRINT("Status is changed \n");
+                drpai_rw_status->rw_status = DRPAI_STATUS_IDLE_RW;
+            }
+            result = count;
+            break;
+        default:
+            ; /* Do nothing */
+            break;
+    }
+
+    DRPAI_DEBUG_WAIT();
+    goto end;
+end:
+    if(-ERESTART != result)
+    {
+        up(&rw_sem);
+    }
+    DRPAI_DEBUG_PRINT("status_rw3:%d\n", drpai_rw_status->rw_status);
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return result;
+}
+
+static ssize_t drpai_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
+{
+    ssize_t result = 0;
+    uint8_t *kbuf = NULL;
+    volatile void *p_drpai_cma = 0;
+    uint32_t reg_val;
+    uint32_t i;
+    struct drpai_rw_status *drpai_rw_status = filp->private_data;
+    struct drpai_priv *priv = drpai_priv;
+    uint64_t addr;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    if(unlikely(down_trylock(&rw_sem)))
+    {
+        result = -ERESTART;
+        goto end;
+    }
+
+    DRPAI_DEBUG_PRINT("status_rw1:%d\n", drpai_rw_status->rw_status);
+
+    /* Check status */
+    if (!((DRPAI_STATUS_ASSIGN  == drpai_rw_status->rw_status) ||
+        (DRPAI_STATUS_DUMP_REG  == drpai_rw_status->rw_status) ||
+        (DRPAI_STATUS_READ_MEM  == drpai_rw_status->rw_status) ||
+        (DRPAI_STATUS_READ_REG  == drpai_rw_status->rw_status)))
+    {
+        result = -EACCES;
+        goto end;
+    }
+
+    /* Check Argument */
+    if (NULL == buf)
+    {
+        result = -EFAULT;
+        goto end;
+    }
+    if (0 == count)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    switch(drpai_rw_status->rw_status)
+    {
+        case DRPAI_STATUS_ASSIGN:
+            /* DRPAI_STATUS_ASSIGN -> DRPAI_STATUS_READ_MEM */
+            drpai_rw_status->rw_status = DRPAI_STATUS_READ_MEM;
+            break;
+        case DRPAI_STATUS_DUMP_REG:
+            /* DRPAI_STATUS_DUMP_REG -> DRPAI_STATUS_READ_REG */
+            drpai_rw_status->rw_status = DRPAI_STATUS_READ_REG;
+            break;
+        default:
+            ; /* Do nothing */
+            break;
+    }
+    DRPAI_DEBUG_PRINT("status_rw2:%d\n", drpai_rw_status->rw_status);
+
+    switch(drpai_rw_status->rw_status)
+    {
+        case DRPAI_STATUS_READ_MEM:
+            /* Read DRP-AI memory */
+            addr = drpai_rw_status->drpai_data.address;
+            p_drpai_cma = phys_to_virt(addr + drpai_rw_status->read_count);
+            if (p_drpai_cma == 0)
+            {
+                result = -EFAULT;
+                goto end;
+            }
+            if ( !( drpai_rw_status->drpai_data.size >= (drpai_rw_status->read_count + count) ) )
+            {
+                count = drpai_rw_status->drpai_data.size - drpai_rw_status->read_count;
+            }
+            /* Copy arguments from kernel space to user space */
+            if (copy_to_user(buf, (void *)p_drpai_cma, count))
+            {
+                result = -EFAULT;
+                goto end;
+            }
+            drpai_rw_status->read_count = drpai_rw_status->read_count + count;
+
+            /* DRPAI_STATUS_READ -> DRPAI_STATUS_IDLE_RW */
+            if (drpai_rw_status->drpai_data.size <= drpai_rw_status->read_count)
+            {
+                drpai_rw_status->rw_status = DRPAI_STATUS_IDLE_RW;
+                DRPAI_DEBUG_PRINT("Deleted list %px rw_status %d prev %px next %px\n", &drpai_rw_status->list, drpai_rw_status->rw_status, drpai_rw_status->list.prev, drpai_rw_status->list.next);
+                list_del(&drpai_rw_status->list);
+                drpai_rw_status->drpai_data.address = 0x0;
+                drpai_rw_status->drpai_data.size    = 0x0;
+            }
+            i = count;
+            break;
+        case DRPAI_STATUS_READ_REG:
+            /* Read DRP-AI register */
+            if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT)))
+            {
+                result = -ETIMEDOUT;
+                goto end;
+            }
+            /* Secure Kbuf area */
+            kbuf = vmalloc(count);
+            if (NULL == kbuf)
+            {
+                result = -ENOMEM;
+                goto end;
+            }
+            for (i = 0; i < count; i+=4)
+            {
+                if (drp_size > drpai_rw_status->read_count)
+                {
+                    reg_val = ioread32(drp_base_addr[0] + drpai_rw_status->drp_reg_offset_count);
+                    *(kbuf + i)     = (uint8_t)reg_val;
+                    *(kbuf + i + 1) = (uint8_t)(reg_val >> 8);
+                    *(kbuf + i + 2) = (uint8_t)(reg_val >> 16);
+                    *(kbuf + i + 3) = (uint8_t)(reg_val >> 24);
+                    drpai_rw_status->drp_reg_offset_count+=4;
+                }
+                else
+                {
+                    reg_val = ioread32(aimac_base_address[0] + drpai_rw_status->aimac_reg_offset_count);
+                    *(kbuf + i)     = (uint8_t)reg_val;
+                    *(kbuf + i + 1) = (uint8_t)(reg_val >> 8);
+                    *(kbuf + i + 2) = (uint8_t)(reg_val >> 16);
+                    *(kbuf + i + 3) = (uint8_t)(reg_val >> 24);
+                    drpai_rw_status->aimac_reg_offset_count+=4;
+                }
+                drpai_rw_status->read_count+=4;
+
+                /* DRPAI_STATUS_READ_REG -> DRPAI_STATUS_IDLE_RW */
+                if ((drp_size + aimac_size) <= drpai_rw_status->read_count)
+                {
+                    drpai_rw_status->rw_status = DRPAI_STATUS_IDLE_RW;
+                    i+=4;
+                    break;
+                }
+            }
+            up(&priv->sem);
+            /* Copy arguments from kernel space to user space */
+            if (copy_to_user(buf, kbuf, count))
+            {
+                result = -EFAULT;
+                goto end;
+            }
+            break;
+        default:
+            ; /* Do nothing */
+            break;
+    }
+
+    result = i;
+
+    DRPAI_DEBUG_WAIT();
+    goto end;
+end:
+    if(-ERESTART != result)
+    {
+        up(&rw_sem);
+    }
+    if (NULL != kbuf)
+    {
+        /* Free kbuf */
+        vfree(kbuf);
+    }
+    DRPAI_DEBUG_PRINT("status_rw3:%d\n", drpai_rw_status->rw_status);
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return result;
+}
+
+static long drpai_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    long result = 0;
+
+    switch (cmd) {
+    case DRPAI_ASSIGN:
+        DRPAI_DEBUG_PRINT("[ioctl(DRPAI_ASSIGN)]\n");
+        result = drpai_ioctl_assign(filp, cmd, arg);
+        break;
+    case DRPAI_START:
+        DRPAI_DEBUG_PRINT("[ioctl(DRPAI_START)]\n");
+        result = drpai_ioctl_start(filp, cmd, arg);
+        break;
+    case DRPAI_RESET:
+        DRPAI_DEBUG_PRINT("[ioctl(DRPAI_RESET)]\n");
+        result = drpai_ioctl_reset(filp, cmd, arg);
+        break;
+    case DRPAI_GET_STATUS:
+        DRPAI_DEBUG_PRINT("[ioctl(DRPAI_GET_STATUS)]\n");
+        result = drpai_ioctl_get_status(filp, cmd, arg);
+        break;
+    case DRPAI_REG_DUMP:
+        DRPAI_DEBUG_PRINT("[ioctl(DRPAI_REG_DUMP)]\n");
+        result = drpai_ioctl_reg_dump(filp, cmd, arg);
+        break;
+    case DRPAI_ASSIGN_PARAM:
+        DRPAI_DEBUG_PRINT("[ioctl(DRPAI_ASSIGN_PARAM)]\n");
+        result = drpai_ioctl_assign_param(filp, cmd, arg);
+        break;
+    case DRPAI_PREPOST_CROP:
+        DRPAI_DEBUG_PRINT("[ioctl(DRPAI_PREPOST_CROP)]\n");
+        result = drpai_ioctl_prepost_crop(filp, cmd, arg);
+        break;
+    case DRPAI_PREPOST_INADDR:
+        DRPAI_DEBUG_PRINT("[ioctl(DRPAI_PREPOST_INADDR)]\n");
+        result = drpai_ioctl_prepost_inaddr(filp, cmd, arg);
+        break;
+    case DRPAI_GET_DRPAI_AREA:
+        DRPAI_DEBUG_PRINT("[ioctl(DRPAI_GET_DRPAI_AREA)]\n");
+        result = drpai_ioctl_get_drpai_area(filp, cmd, arg);
+        break;
+    case DRPAI_SET_DRP_MAX_FREQ:
+        DRPAI_DEBUG_PRINT("[ioctl(DRPAI_SET_DRP_MAX_FREQ)]\n");
+        result = drpai_ioctl_set_drp_max_freq(filp, cmd, arg);
+        break;
+    case DRPAI_SET_DRPAI_FREQ:
+        DRPAI_DEBUG_PRINT("[ioctl(DRPAI_SET_DRPAI_FREQ)]\n");
+        result = drpai_ioctl_set_drpai_freq(filp, cmd, arg);
+        break;
+    case DRPAI_SET_ADRCONV:
+        DRPAI_DEBUG_PRINT("[ioctl(DRPAI_SET_ADRCONV)]\n");
+        result = drpai_ioctl_set_adrconv(filp, cmd, arg);
+        break;
+    case DRPAI_SET_EXTRA_AREA:
+        DRPAI_DEBUG_PRINT("[ioctl(DRPAI_SET_EXTRA_AREA)]\n");
+        result = drpai_ioctl_set_extra_area(filp, cmd, arg);
+        break;
+/* V2L conditional compilation */
+#if 0
+    case DRPAI_SET_SEQ:
+        DRPAI_DEBUG_PRINT("[ioctl(DRPAI_SET_SEQ)]\n");
+        result = drpai_ioctl_set_seq(filp, cmd, arg);
+        break;
+#endif
+    case DRPAI_READ_DRP_REG:
+        DRPAI_DEBUG_PRINT("[ioctl(DRPAI_READ_DRP_REG)]\n");
+        result = drpai_ioctl_read_drp_reg(filp, cmd, arg);
+        break;
+    case DRPAI_WRITE_DRP_REG:
+        DRPAI_DEBUG_PRINT("[ioctl(DRPAI_WRITE_DRP_REG)]\n");
+        result = drpai_ioctl_write_drp_reg(filp, cmd, arg);
+        break;
+    case DRPAI_READ_DRPAI_REG:
+        DRPAI_DEBUG_PRINT("[ioctl(DRPAI_READ_DRPAI_REG)]\n");
+        result = drpai_ioctl_read_drpai_reg(filp, cmd, arg);
+        break;
+    case DRPAI_WRITE_DRPAI_REG:
+        DRPAI_DEBUG_PRINT("[ioctl(DRPAI_WRITE_DRPAI_REG)]\n");
+        result = drpai_ioctl_write_drpai_reg(filp, cmd, arg);
+        break;
+    case DRPAI_READ_CPG_REG:
+        DRPAI_DEBUG_PRINT("[ioctl(DRPAI_READ_CPG_REG)]\n");
+        result = drpai_ioctl_read_cpg_reg(filp, cmd, arg);
+        break;
+    case DRPAI_WRITE_CPG_REG:
+        DRPAI_DEBUG_PRINT("[ioctl(DRPAI_WRITE_CPG_REG)]\n");
+        result = drpai_ioctl_write_cpg_reg(filp, cmd, arg);
+        break;
+    default:
+        DRPAI_DEBUG_PRINT(KERN_WARNING "unsupported command %d\n", cmd);
+        result = -EFAULT;
+        break;
+    }
+    goto end;
+
+end:
+    return result;
+}
+
+static unsigned int drpai_poll( struct file* filp, poll_table* wait )
+{
+    unsigned int retmask = 0;
+    struct drpai_priv *priv = drpai_priv;
+    unsigned long flags;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    spin_lock_irqsave(&priv->lock, flags);
+
+    poll_wait( filp, &drpai_waitq,  wait );
+
+    if (IRQ_CHECK_DISABLE == priv->irq_flag)
+    {
+        retmask |= ( POLLIN  | POLLRDNORM );
+    }
+
+    spin_unlock_irqrestore(&priv->lock, flags);
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return retmask;
+}
+
+/* V2L conditional compilation */
+#if 0
+static irqreturn_t irq_drp_nmlint(int irq, void *dev)
+{
+    unsigned long flags;
+    struct drpai_priv *priv = drpai_priv;
+    drpai_odif_intcnto_t local_odif_intcnto;
+    void (*finish_callback)(int);
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    spin_lock_irqsave(&priv->lock, flags);
+    /* For success ISP call back*/
+    finish_callback = priv->isp_finish_loc;
+
+    DRPAI_DEBUG_PRINT("\n");
+    DRPAI_DEBUG_PRINT("status1:%d\n", priv->drpai_status.status);
+
+    /* DRP normal interrupt processing */
+    R_DRPAI_DRP_Nmlint(drp_base_addr[0], 0, &local_odif_intcnto);
+
+    odif_intcnto.ch0 += local_odif_intcnto.ch0;
+    odif_intcnto.ch1 += local_odif_intcnto.ch1;
+    odif_intcnto.ch2 += local_odif_intcnto.ch2;
+    odif_intcnto.ch3 += local_odif_intcnto.ch3;
+
+    DRPAI_DEBUG_PRINT("ODIF_INTCNTO0 : 0x%08X\n", odif_intcnto.ch0);
+    DRPAI_DEBUG_PRINT("ODIF_INTCNTO1 : 0x%08X\n", odif_intcnto.ch1);
+    DRPAI_DEBUG_PRINT("ODIF_INTCNTO2 : 0x%08X\n", odif_intcnto.ch2);
+    DRPAI_DEBUG_PRINT("ODIF_INTCNTO3 : 0x%08X\n", odif_intcnto.ch3);
+
+    DRPAI_DEBUG_PRINT("local_ODIF_INTCNTO0 : 0x%08X\n", local_odif_intcnto.ch0);
+    DRPAI_DEBUG_PRINT("local_ODIF_INTCNTO1 : 0x%08X\n", local_odif_intcnto.ch1);
+    DRPAI_DEBUG_PRINT("local_ODIF_INTCNTO2 : 0x%08X\n", local_odif_intcnto.ch2);
+    DRPAI_DEBUG_PRINT("local_ODIF_INTCNTO3 : 0x%08X\n", local_odif_intcnto.ch3);
+
+/* DRP single operation */
+    if(DRPAI_EXE_AI == exe_mode)
+    {
+        if  ((1 == odif_intcnto.ch0) &&
+            (1 == odif_intcnto.ch1) &&
+            (1 == odif_intcnto.ch2) &&
+            (1 == odif_intcnto.ch3))
+        {
+            /* Internal state update */
+            priv->drpai_status.status = DRPAI_STATUS_IDLE;
+            DRPAI_DEBUG_PRINT("status2:%d\n", priv->drpai_status.status);
+            /* For success ISP call back*/
+            if(NULL != finish_callback)
+            {
+                (*finish_callback)(ISP_FINISH_SUCCESS);
+            }
+        }
+    }
+    else if (DRPAI_EXE_DRP == exe_mode)
+    {
+        if ((seq.num == odif_intcnto.ch0) &&
+            (seq.num == odif_intcnto.ch1) &&
+            (seq.num == odif_intcnto.ch2) &&
+            (seq.num == odif_intcnto.ch3))
+        {
+            /* Internal state update */
+            priv->drpai_status.status = DRPAI_STATUS_IDLE;
+            DRPAI_DEBUG_PRINT("status2:%d\n", priv->drpai_status.status);
+            priv->irq_flag = IRQ_CHECK_DISABLE;
+            /* Wake up the process */
+            wake_up_interruptible( &drpai_waitq );
+        }
+    }
+    else
+    {
+        // do nothing
+    }
+/* DRP single operation */
+
+    priv->isp_finish_loc = NULL;
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return IRQ_HANDLED;
+}
+#endif
+
+static irqreturn_t irq_drp_errint(int irq, void *dev)
+{
+    unsigned long flags;
+    struct drpai_priv *priv = drpai_priv;
+/* V2L conditional compilation */
+#if 0
+    void (*finish_callback)(int); /* For error simple ISP call back*/
+#endif
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    spin_lock_irqsave(&priv->lock, flags);
+
+/* V2L conditional compilation */
+#if 0
+    finish_callback = priv->isp_finish_loc;
+
+    if(NULL != finish_callback)
+    {
+        (*finish_callback)(-EIO);
+    }
+#endif
+
+    DRPAI_DEBUG_PRINT("status1:   %d\n", priv->drpai_status.status);
+
+    /* DRP error interrupt processing */
+    R_DRPAI_DRP_Errint(drp_base_addr[0], aimac_base_address[0], 0);
+
+    /* Internal state update */
+    priv->drpai_status.err = DRPAI_ERRINFO_DRP_ERR;
+    priv->drpai_status.status = DRPAI_STATUS_IDLE;
+    priv->irq_flag = IRQ_CHECK_DISABLE;
+
+#if 0
+    /* V2L conditional compilation */
+    /* Wake up the process when it's not ISP mode*/
+    if(NULL == finish_callback)
+    {
+        wake_up_interruptible( &drpai_waitq );
+    }
+    priv->isp_finish_loc = NULL;
+#else
+    /* Wake up the process */
+    wake_up_interruptible( &drpai_waitq );
+#endif
+
+    DRPAI_DEBUG_PRINT("status2:   %d\n", priv->drpai_status.status);
+    spin_unlock_irqrestore(&priv->lock, flags);
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return IRQ_HANDLED;
+}
+
+static irqreturn_t irq_mac_nmlint(int irq, void *dev)
+{
+    unsigned long flags;
+    struct drpai_priv *priv = drpai_priv;
+    int32_t ret;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    spin_lock_irqsave(&priv->lock, flags);
+    DRPAI_DEBUG_PRINT(" \n");
+    DRPAI_DEBUG_PRINT("status1:   %d\n", priv->drpai_status.status);
+
+    /* AI-MAC normal interrupt processing */
+    ret = R_DRPAI_AIMAC_Nmlint(aimac_base_address[0], 0, &priv->drpai_status.reserved[0]);
+    if ((R_DRPAI_SUCCESS != ret) && (DRPAI_ERRINFO_SUCCESS == priv->drpai_status.err))
+    {
+        /* Internal state update */
+        priv->drpai_status.err = DRPAI_ERRINFO_AIMAC_ERR;
+    }
+
+    ret = R_DRPAI_DRP_Stop(drp_base_addr[0], 0);
+    if ((R_DRPAI_SUCCESS != ret) && (DRPAI_ERRINFO_SUCCESS == priv->drpai_status.err))
+    {
+        /* Internal state update */
+        priv->drpai_status.err = DRPAI_ERRINFO_DRP_ERR;
+    }
+    ret = R_DRPAI_AIMAC_Stop(aimac_base_address[0], 0);
+    if ((R_DRPAI_SUCCESS != ret) && (DRPAI_ERRINFO_SUCCESS == priv->drpai_status.err))
+    {
+        /* Internal state update */
+        priv->drpai_status.err = DRPAI_ERRINFO_AIMAC_ERR;
+    }
+
+    /* Internal state update */
+    priv->drpai_status.status = DRPAI_STATUS_IDLE;
+    priv->irq_flag = IRQ_CHECK_DISABLE;
+
+    /* Wake up the process */
+    wake_up_interruptible( &drpai_waitq );
+
+    DRPAI_DEBUG_PRINT("status2:   %d\n", priv->drpai_status.status);
+    spin_unlock_irqrestore(&priv->lock, flags);
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return IRQ_HANDLED;
+}
+
+static irqreturn_t irq_mac_errint(int irq, void *dev)
+{
+    unsigned long flags;
+    struct drpai_priv *priv = drpai_priv;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    spin_lock_irqsave(&priv->lock, flags);
+    DRPAI_DEBUG_PRINT(" \n");
+    DRPAI_DEBUG_PRINT("status1:   %d\n", priv->drpai_status.status);
+
+    /* AI-MAC error interrupt processing */
+    R_DRPAI_AIMAC_Errint(drp_base_addr[0], aimac_base_address[0], 0);
+
+    /* Internal state update */
+    priv->drpai_status.err = DRPAI_ERRINFO_AIMAC_ERR;
+    priv->drpai_status.status = DRPAI_STATUS_IDLE;
+    priv->irq_flag = IRQ_CHECK_DISABLE;
+
+    /* Wake up the process */
+    wake_up_interruptible( &drpai_waitq );
+
+    DRPAI_DEBUG_PRINT("status2:   %d\n", priv->drpai_status.status);
+    spin_unlock_irqrestore(&priv->lock, flags);
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return IRQ_HANDLED;
+}
+
+static int drpai_regist_driver(void)
+{
+    int alloc_ret = 0;
+    int cdev_err = 0;
+    dev_t dev;
+    int minor;
+    int ptr_err;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    /* Get free major number. */
+    alloc_ret = alloc_chrdev_region(&dev, MINOR_BASE, MINOR_NUM, DRPAI_DRIVER_NAME);
+    if (alloc_ret != 0) {
+        pr_err("DRP-AI Driver: alloc_chrdev_region = %d\n", alloc_ret);
+        return -ENOMEM;
+    }
+
+    /* Save major number. */
+    drpai_major = MAJOR(dev);
+    dev = MKDEV(drpai_major, MINOR_BASE);
+
+    /* Initialize cdev and registration handler table. */
+    cdev_init(&drpai_cdev, &s_mydevice_fops);
+    drpai_cdev.owner = THIS_MODULE;
+
+    /* Registration cdev */
+    cdev_err = cdev_add(&drpai_cdev, dev, MINOR_NUM);
+    if (cdev_err != 0) {
+        pr_err("DRP-AI Driver: cdev_add = %d\n", cdev_err);
+        unregister_chrdev_region(dev, MINOR_NUM);
+        return -ENOMEM;
+    }
+
+    /* Cleate class "/sys/class/drpai/" */
+    drpai_class = class_create(THIS_MODULE, DRPAI_DRIVER_NAME);
+    if (IS_ERR(drpai_class)) {
+        ptr_err = PTR_ERR(drpai_class);
+        pr_err("DRP-AI Driver: class_create = %d\n", ptr_err);
+        cdev_del(&drpai_cdev);
+        unregister_chrdev_region(dev, MINOR_NUM);
+        return -ENOMEM;
+    }
+
+    /* Make "/sys/class/drpai/drpai*" */
+    for (minor = MINOR_BASE; minor < MINOR_BASE + MINOR_NUM; minor++) {
+        drpai_device_array[minor - MINOR_BASE] =
+        device_create(drpai_class, NULL, MKDEV(drpai_major, minor), NULL, DRPAI_DRIVER_NAME "%d", minor);
+    }
+
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return 0;
+}
+
+static int drpai_regist_device(struct platform_device *pdev)
+{
+    struct resource *res;
+    struct resource reserved_res;
+    struct device_node *np;
+    struct drpai_priv *priv;
+    struct drpai_rw_status *drpai_rw_status;
+    int irq, ret;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    /* Intialize DRP-AI status to control */
+    priv = devm_kzalloc(&pdev->dev, sizeof(struct drpai_priv), GFP_KERNEL);
+    if (!priv) {
+        dev_err(&pdev->dev, "cannot allocate private data\n");
+        return -ENOMEM;
+    }
+
+    platform_set_drvdata(pdev, priv);
+    priv->pdev = pdev;
+    priv->dev_name = dev_name(&pdev->dev);
+    spin_lock_init(&priv->lock);
+    sema_init(&priv->sem, DRPAI_DEV_NUM);
+    refcount_set(&priv->count, 1);
+    priv->drpai_status.status = DRPAI_STATUS_INIT;
+    priv->drpai_status.err    = DRPAI_ERRINFO_SUCCESS;
+    drpai_priv = priv;
+
+    /* Initialize list head */
+    drpai_rw_status = devm_kzalloc(&pdev->dev, sizeof(struct drpai_rw_status), GFP_KERNEL);
+    if (!drpai_rw_status) {
+        dev_err(&pdev->dev, "cannot allocate sentinel data\n");
+        return -ENOMEM;
+    }
+    drpai_rw_status->rw_status  = HEAD_SENTINEL;
+    drpai_rw_status->param_info = NULL;
+    INIT_LIST_HEAD(&drpai_rw_status->list);
+    atomic_set(&drpai_rw_status->inout_flag, 0);
+    drpai_rw_sentinel = drpai_rw_status;
+    DRPAI_DEBUG_PRINT("HEAD  list %px rw_status %d prev %px next %px\n", &drpai_rw_sentinel->list, drpai_rw_sentinel->rw_status, drpai_rw_sentinel->list.prev, drpai_rw_sentinel->list.next);
+
+    if (of_device_is_compatible(pdev->dev.of_node, "renesas,rzv2h-drpai"))
+    {
+        drpai_priv->dev_tag = DEVICE_RZV2H;
+        dev_info(&pdev->dev, "DRP-AI Driver version : %s V2H\n", DRPAI_DRIVER_VERSION DRPAI_DRV_DEBUG_MODE DRPAI_DRV_DEBUG_WAIT_MODE);
+    }
+    else
+    {
+        /* Do Nothing */
+    }
+
+    /* Get reserved memory region from Device tree.*/
+    np = of_parse_phandle(pdev->dev.of_node, "memory-region", 0);
+    if (!np) {
+        dev_err(&pdev->dev, "No %s specified\n", "memory-region");
+        return -ENOMEM;
+    }
+
+    /* Convert memory region to a struct resource */
+    ret = of_address_to_resource(np, 0, &reserved_res);
+    if (ret) {
+        dev_err(&pdev->dev, "No memory address assigned to the memory-region\n");
+        return -ENOMEM;
+    }
+    drpai_region_base_addr = reserved_res.start;
+    drpai_region_size = resource_size(&reserved_res);
+    dev_info(&pdev->dev, "DRP-AI memory region start 0x%016llX, size 0x%016llX\n", drpai_region_base_addr, drpai_region_size);
+    if ((DRPAI_MAX_40BIT < drpai_region_base_addr) ||
+        (DRPAI_INF_40BIT < drpai_region_size) ||
+        (DRPAI_INF_40BIT < (drpai_region_base_addr + drpai_region_size)) ||
+        (0 == drpai_region_size)) {
+        dev_err(&pdev->dev, "Invalid DRP-AI memory region\n");
+        return -ENOMEM;
+    }
+
+    /* Get additional memory region from Device tree.*/
+    drpai_region2_base_addr = DRPAI_MAX_40BIT;
+    drpai_region2_size = 0;
+    np = of_parse_phandle(pdev->dev.of_node, "memory-region2", 0);
+    if (np) {
+        /* Convert memory region to a struct resource */
+        ret = of_address_to_resource(np, 0, &reserved_res);
+        if (ret) {
+            dev_err(&pdev->dev, "No address assigned to the memory-region2\n");
+        } else {
+            drpai_region2_base_addr = reserved_res.start;
+            drpai_region2_size = resource_size(&reserved_res);
+            dev_info(&pdev->dev, "DRP-AI memory region 2 start 0x%016llX, size 0x%016llX\n", drpai_region2_base_addr, drpai_region2_size);
+            if ((DRPAI_MAX_40BIT < drpai_region2_base_addr) ||
+                (DRPAI_INF_40BIT < drpai_region2_size) ||
+                (DRPAI_INF_40BIT < (drpai_region2_base_addr + drpai_region2_size)) ||
+                (0 == drpai_region2_size)) {
+                dev_info(&pdev->dev, "Invalid DRP-AI memory region 2\n");
+                drpai_region2_base_addr = DRPAI_MAX_40BIT;
+                drpai_region2_size = 0;
+            }
+        }
+    }
+
+    /* Get image memory region from Device tree.*/
+    image_region_addr = DRPAI_MAX_40BIT;
+    image_region_size = 0;
+    np = of_parse_phandle(pdev->dev.of_node, "image-memory-region", 0);
+    if (np) {
+        /* Convert memory region to a struct resource */
+        ret = of_address_to_resource(np, 0, &reserved_res);
+        if (ret) {
+            dev_err(&pdev->dev, "No memory address assigned to the image-memory-region\n");
+        } else {
+            image_region_addr = reserved_res.start;
+            image_region_size = resource_size(&reserved_res);
+            dev_info(&pdev->dev, "Image memory region start 0x%016llX, size 0x%016llX\n", image_region_addr, image_region_size);
+            if ((DRPAI_MAX_40BIT < image_region_addr) ||
+                (DRPAI_INF_40BIT < image_region_size) ||
+                (DRPAI_INF_40BIT < (image_region_addr + image_region_size)) ||
+                (0 == image_region_size)) {
+                dev_info(&pdev->dev, "Invalid image memory region\n");
+                image_region_addr = DRPAI_MAX_40BIT;
+                image_region_size = 0;
+            } else if (DRPAI_INF_32BIT < ((image_region_addr & DRPAI_MAX_24BIT) + image_region_size)) {
+                image_region_size = DRPAI_INF_32BIT - (image_region_addr & DRPAI_MAX_24BIT);
+                dev_info(&pdev->dev, "Reduced image memory region size 0x%016llX\n", image_region_size);
+            }
+        }
+    }
+
+    /* Get linux memory region from Device tree.*/
+    drpai_linux_mem_start = DRPAI_MAX_40BIT;
+    drpai_linux_mem_size = 0;
+    np = of_parse_phandle(pdev->dev.of_node, "linux-memory-region", 0);
+    if (np) {
+        /* read linux start address and size */
+        ret = of_address_to_resource(np, 0, &reserved_res);
+        if (ret) {
+            dev_err(&pdev->dev, "No address assigned to the linux-memory-region\n");
+        } else {
+            drpai_linux_mem_start = reserved_res.start;
+            drpai_linux_mem_size = resource_size(&reserved_res);
+            dev_info(&pdev->dev, "Linux memory region start 0x%016llX, size 0x%016llX\n", drpai_linux_mem_start, drpai_linux_mem_size);
+            if ((DRPAI_MAX_40BIT < drpai_linux_mem_start) ||
+                (DRPAI_INF_40BIT < drpai_linux_mem_size) ||
+                (DRPAI_INF_40BIT < (drpai_linux_mem_start + drpai_linux_mem_size)) ||
+                (0 == drpai_linux_mem_size)) {
+                dev_info(&pdev->dev, "Invalid linux memory region\n");
+                drpai_linux_mem_start = DRPAI_MAX_40BIT;
+                drpai_linux_mem_size = 0;
+            }
+        }
+    }
+
+    drpai_linux_mem2_start = DRPAI_MAX_40BIT;
+    drpai_linux_mem2_size = 0;
+    np = of_parse_phandle(pdev->dev.of_node, "linux-memory-region2", 0);
+    if (np) {
+        /* read linux start address and size */
+        ret = of_address_to_resource(np, 0, &reserved_res);
+        if (ret) {
+            dev_err(&pdev->dev, "No address assigned to the linux-memory-region2\n");
+        } else {
+            drpai_linux_mem2_start = reserved_res.start;
+            drpai_linux_mem2_size = resource_size(&reserved_res);
+            dev_info(&pdev->dev, "Linux memory region 2 start 0x%016llX, size 0x%016llX\n", drpai_linux_mem2_start, drpai_linux_mem2_size);
+            if ((DRPAI_MAX_40BIT < drpai_linux_mem2_start) ||
+                (DRPAI_INF_40BIT < drpai_linux_mem2_size) ||
+                (DRPAI_INF_40BIT < (drpai_linux_mem2_start + drpai_linux_mem2_size)) ||
+                (0 == drpai_linux_mem2_size)) {
+                dev_info(&pdev->dev, "Invalid linux memory region 2\n");
+                drpai_linux_mem2_start = DRPAI_MAX_40BIT;
+                drpai_linux_mem2_size = 0;
+            }
+        }
+    }
+
+    drpai_linux_mem3_start = DRPAI_MAX_40BIT;
+    drpai_linux_mem3_size = 0;
+    np = of_parse_phandle(pdev->dev.of_node, "linux-memory-region3", 0);
+    if (np) {
+        /* read linux start address and size */
+        ret = of_address_to_resource(np, 0, &reserved_res);
+        if (ret) {
+            dev_err(&pdev->dev, "No address assigned to the linux-memory-region3\n");
+        } else {
+            drpai_linux_mem3_start = reserved_res.start;
+            drpai_linux_mem3_size = resource_size(&reserved_res);
+            dev_info(&pdev->dev, "Linux memory region 3 start 0x%016llX, size 0x%016llX\n", drpai_linux_mem3_start, drpai_linux_mem3_size);
+            if ((DRPAI_MAX_40BIT < drpai_linux_mem3_start) ||
+                (DRPAI_INF_40BIT < drpai_linux_mem3_size) ||
+                (DRPAI_INF_40BIT < (drpai_linux_mem3_start + drpai_linux_mem3_size)) ||
+                (0 == drpai_linux_mem3_size)) {
+                dev_info(&pdev->dev, "Invalid linux memory region 3\n");
+                drpai_linux_mem3_start = DRPAI_MAX_40BIT;
+                drpai_linux_mem3_size = 0;
+            }
+        }
+    }
+
+    /* Convert DRP base address from physical to virtual */
+    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+    if (!res) {
+        dev_err(&pdev->dev, "cannot get resources (reg)\n");
+        return -EINVAL;
+    }
+    priv->drp_base = devm_ioremap(&pdev->dev, res->start, resource_size(res));
+    if (!priv->drp_base) {
+        dev_err(&pdev->dev, "cannot ioremap\n");
+        return -EINVAL;
+    }
+    drp_base_addr[0] = priv->drp_base;
+    drp_size = resource_size(res);
+    dev_info(&pdev->dev, "DRP base address 0x%016llX, size 0x%016llX\n", res->start, drp_size);
+
+    /* Convert AI-MAC base address from physical to virtual */
+    res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+    if (!res) {
+        dev_err(&pdev->dev, "cannot get resources (reg)\n");
+        return -EINVAL;
+    }
+    priv->aimac_base = devm_ioremap(&pdev->dev, res->start, resource_size(res));
+    if (!priv->aimac_base) {
+        dev_err(&pdev->dev, "cannot ioremap\n");
+        return -EINVAL;
+    }
+    aimac_base_address[0] = priv->aimac_base;
+    aimac_size = resource_size(res);
+    dev_info(&pdev->dev, "AI-MAC base address 0x%016llX, size 0x%016llX\n", res->start, aimac_size);
+
+    /* Registering an interrupt handler */
+    irq = platform_get_irq(pdev, 1);
+    ret = devm_request_irq(&pdev->dev, irq, irq_drp_errint, 0, "drpa errint", priv);
+    if (ret) {
+        dev_err(&pdev->dev, "Failed to claim IRQ!\n");
+        return ret;
+    }
+    irq = platform_get_irq(pdev, 2);
+    ret = devm_request_irq(&pdev->dev, irq, irq_mac_nmlint, 0, "drpa mac_nmlint", priv);
+    if (ret) {
+        dev_err(&pdev->dev, "Failed to claim IRQ!\n");
+        return ret;
+    }
+    irq = platform_get_irq(pdev, 3);
+    ret = devm_request_irq(&pdev->dev, irq, irq_mac_errint, 0, "drpa mac_errint", priv);
+    if (ret) {
+        dev_err(&pdev->dev, "Failed to claim IRQ!\n");
+        return ret;
+    }
+
+/* V2L conditional compilation */
+#if 0
+
+    irq = platform_get_irq(pdev, 0);
+    ret = devm_request_irq(&pdev->dev, irq, irq_drp_nmlint, 0, "drpa nmlint", priv);
+    if (ret) {
+        dev_err(&pdev->dev, "Failed to claim IRQ!\n");
+        return ret;
+    }
+    /* Get clock controller info */
+    priv->clk_int = devm_clk_get(&pdev->dev, "intclk");
+    if (IS_ERR(priv->clk_int)) {
+        dev_err(&pdev->dev, "missing controller clock");
+        return PTR_ERR(priv->clk_int);
+    }
+
+    priv->clk_aclk_drp = devm_clk_get(&pdev->dev, "aclk_drp");
+    if (IS_ERR(priv->clk_aclk_drp)) {
+        dev_err(&pdev->dev, "missing controller clock");
+        return PTR_ERR(priv->clk_aclk_drp);
+    }
+
+    priv->clk_mclk = devm_clk_get(&pdev->dev, "mclk");
+    if (IS_ERR(priv->clk_mclk)) {
+        dev_err(&pdev->dev, "missing controller clock");
+        return PTR_ERR(priv->clk_mclk);
+    }
+
+    priv->clk_dclkin = devm_clk_get(&pdev->dev, "dclkin");
+    if (IS_ERR(priv->clk_dclkin)) {
+        dev_err(&pdev->dev, "missing controller clock");
+        return PTR_ERR(priv->clk_dclkin);
+    }
+
+    priv->clk_aclk = devm_clk_get(&pdev->dev, "aclk");
+    if (IS_ERR(priv->clk_aclk)) {
+        dev_err(&pdev->dev, "missing controller clock");
+        return PTR_ERR(priv->clk_aclk);
+    }
+
+#endif
+
+#if 1 /* for CPG direct access (preliminary) */
+    cpg_size = CPG_SIZE;
+    cpg_base_address = ioremap(CPG_BASE_ADDRESS, cpg_size);
+    if (cpg_base_address == 0)
+    {
+        pr_info("[%s: %d](pid: %d) failed to get cpg_base_address\n", __func__, __LINE__, current->pid);
+        return -EINVAL;
+    }
+#endif
+    /* Get reset controller info */
+    priv->rstc = devm_reset_control_get(&pdev->dev, NULL);
+    if (IS_ERR(priv->rstc))
+    {
+        dev_err(&pdev->dev, "Failed to get DRP CPG reset controller\n");
+#if 1 /* for CPG direct access (preliminary) */
+        iounmap(cpg_base_address);
+#endif
+        return PTR_ERR(priv->rstc);
+    }
+    else
+    {
+        DRPAI_DEBUG_PRINT("Get DRP CPG reset controller\n");
+    }
+
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return 0;
+}
+
+static void drpai_unregist_driver(void)
+{
+    dev_t dev = MKDEV(drpai_major, MINOR_BASE);
+    int minor;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    /* Delete "/sys/class/mydevice/mydevice*". */
+    for (minor = MINOR_BASE; minor < MINOR_BASE + MINOR_NUM; minor++) {
+        device_destroy(drpai_class, MKDEV(drpai_major, minor));
+    }
+
+    /* Destroy "/sys/class/mydevice/". */
+    class_destroy(drpai_class);
+
+    /* Delete cdev from kernel. */
+    cdev_del(&drpai_cdev);
+
+    /* Unregistration */
+    unregister_chrdev_region(dev, MINOR_NUM);
+    DRPAI_DEBUG_PRINT("end.\n");
+}
+
+static void drpai_unregist_device(void)
+{
+    DRPAI_DEBUG_PRINT("start.\n");
+
+#if 1 /* for CPG direct access (preliminary) */
+    iounmap(cpg_base_address);
+#endif
+
+    DRPAI_DEBUG_PRINT("end.\n");
+}
+
+static int8_t drpai_reset_device(uint32_t ch)
+{
+    int8_t retval;
+    struct drpai_priv *priv = drpai_priv;
+    int r_data;
+    int32_t i = 0;
+    bool is_stop = false;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    /* Reset DRP */
+    if(R_DRPAI_SUCCESS != R_DRPAI_DRP_Reset(drp_base_addr[0], ch))
+    {
+        goto err_reset;
+    }
+
+    /* Reset AI-MAC */
+    if(R_DRPAI_SUCCESS != R_DRPAI_AIMAC_Reset(aimac_base_address[0], ch))
+    {
+        goto err_reset;
+    }
+
+    r_data = reset_control_status(priv->rstc);
+    DRPAI_DEBUG_PRINT("CPG reset_control_status before %d \n", r_data);
+
+    /* Access reset controller interface */
+    reset_control_reset(priv->rstc);
+
+    /* Check reset status */
+    i = 0;
+    while((RST_MAX_TIMEOUT > i) && (false == is_stop))
+    {
+        udelay(1);
+        i++;
+        r_data = reset_control_status(priv->rstc);
+        DRPAI_DEBUG_PRINT("CPG reset_control_status %d \n", r_data);
+        if(CPG_RESET_SUCCESS == r_data)
+        {
+            is_stop = true;
+            break;
+        }
+    }
+
+    i = 0;
+    while((RST_MAX_TIMEOUT > i) && (false == is_stop))
+    {
+        usleep_range(100, 200);
+        i++;
+        r_data = reset_control_status(priv->rstc);
+        DRPAI_DEBUG_PRINT("CPG reset_control_status %d \n", r_data);
+        if(CPG_RESET_SUCCESS == r_data)
+        {
+            is_stop = true;
+            break;
+        }
+    }
+
+    if(false == is_stop)
+    {
+        DRPAI_DEBUG_PRINT("CPG Reset failed. Reset Control Status: %d\n", r_data);
+        goto err_reset;
+    }
+
+    retval = R_DRPAI_SUCCESS;
+    goto end;
+err_reset:
+    retval = R_DRPAI_ERR_RESET;
+    goto end;
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return retval;
+}
+
+static void drpai_init_device(uint32_t ch)
+{
+    unsigned long flags;
+    struct drpai_priv *priv = drpai_priv;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    spin_lock_irqsave(&priv->lock, flags);
+    priv->irq_flag = IRQ_CHECK_DISABLE;
+    spin_unlock_irqrestore(&priv->lock, flags);
+    R_DRPAI_DRP_Open(drp_base_addr[0], 0);
+    R_DRPAI_AIMAC_Open(aimac_base_address[0], 0);
+
+    DRPAI_DEBUG_PRINT("end.\n");
+}
+
+static long drpai_ioctl_assign(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    long result = 0;
+    volatile void *p_virt_address = 0;
+    struct drpai_rw_status *drpai_rw_status = filp->private_data;
+    struct drpai_rw_status *entry;
+    struct list_head *listitr;
+    drpai_data_t drpai_data_buf;
+    uint64_t addr, size;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    if(unlikely(down_trylock(&rw_sem)))
+    {
+        result = -ERESTART;
+        goto end;
+    }
+
+    DRPAI_DEBUG_PRINT(" \n");
+    DRPAI_DEBUG_PRINT("status_rw1:%d\n", drpai_rw_status->rw_status);
+
+    /* Check NULL */
+    if (0 == arg)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    /* Check status */
+    if (DRPAI_STATUS_IDLE_RW != drpai_rw_status->rw_status)
+    {
+        result = -EACCES;
+        goto end;
+    }
+
+    /* Copy arguments from user space to kernel space */
+    if (copy_from_user(&drpai_data_buf, (void __user *)arg, sizeof(drpai_data_t)))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+    /* Check Argument */
+    addr = drpai_data_buf.address;
+    size = drpai_data_buf.size;
+    if (0 != (addr & DRPAI_64BYTE_ALIGN))
+    {
+        result = -EINVAL;
+        goto end;
+    }
+    if (0 != drpai_check_area(addr, size))
+    {
+        result = -EINVAL;
+        goto end;
+    }
+    if (0 == size)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    /* Check the assigned address */
+    DRPAI_DEBUG_PRINT("list %px prev %px next %px\n", &drpai_rw_status->list, drpai_rw_status->list.prev, drpai_rw_status->list.next);
+    if(!list_empty(&drpai_rw_sentinel->list))
+    {
+        DRPAI_DEBUG_PRINT("List is not empty\n");
+        list_for_each(listitr, &drpai_rw_sentinel->list)
+        {
+            entry = list_entry(listitr, struct drpai_rw_status, list);
+            DRPAI_DEBUG_PRINT("rw_status %d list %px prev %px next %px\n", entry->rw_status, &entry->list, entry->list.prev, entry->list.next);
+            if( (DRPAI_STATUS_ASSIGN   == entry->rw_status) ||
+                (DRPAI_STATUS_WRITE    == entry->rw_status) ||
+                (DRPAI_STATUS_READ_MEM == entry->rw_status)    )
+            {
+                if(!(  (entry->drpai_data.address > (drpai_data_buf.address + drpai_data_buf.size - 1)) ||
+                      ((entry->drpai_data.address + entry->drpai_data.size - 1) < drpai_data_buf.address)  ))
+                {
+                    result = -EINVAL;
+                    goto end;
+                }
+            }
+        }
+    }
+
+    /* Data cache invalidate. DRP-AI W -> CPU R */
+    addr = drpai_data_buf.address;
+    p_virt_address = phys_to_virt(addr);
+    if (p_virt_address == 0)
+    {
+        result = -EFAULT;
+        goto end;
+    }
+    __inval_dcache_area((void *)p_virt_address, drpai_data_buf.size);
+
+    /* Initialization of read / write processing variables */
+    drpai_rw_status->drpai_data  = drpai_data_buf;
+    drpai_rw_status->rw_status   = DRPAI_STATUS_ASSIGN;
+    drpai_rw_status->write_count = 0;
+    drpai_rw_status->read_count  = 0;
+    /* Register assigned status */
+    list_add(&drpai_rw_status->list, &drpai_rw_sentinel->list);
+    DRPAI_DEBUG_PRINT("Registered list %px prev %px next %px\n", &drpai_rw_status->list, drpai_rw_status->list.prev, drpai_rw_status->list.next);
+
+    DRPAI_DEBUG_WAIT();
+    goto end;
+end:
+    if(-ERESTART != result)
+    {
+        up(&rw_sem);
+    }
+    DRPAI_DEBUG_PRINT("status_rw2:%d\n", drpai_rw_status->rw_status);
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return result;
+}
+
+static long drpai_ioctl_start(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    int result = 0;
+    drpai_data_t proc[DRPAI_INDEX_NUM];
+/* V2L conditional compilation */
+#if 0
+/* DRP single operation */
+    drpai_data_t proc_drp[DRPAI_SEQ_NUM * 2];
+/* DRP single operation */
+#endif
+    struct drpai_priv *priv = drpai_priv;
+    unsigned long flags;
+    int i;
+    struct drpai_rw_status *drpai_rw_status = filp->private_data;
+    uint64_t addr;
+    uint64_t size;
+    uint32_t drp_desc_addr;
+    uint32_t aimac_desc_addr;
+    uint32_t aimac_param_desc_addr;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT)))
+    {
+        result = -ETIMEDOUT;
+        goto end;
+    }
+
+    DRPAI_DEBUG_PRINT(" \n");
+    DRPAI_DEBUG_PRINT("status1:   %d\n", priv->drpai_status.status);
+
+    /* Check NULL */
+    if (0 == arg)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    /* Check status */
+    spin_lock_irqsave(&priv->lock, flags);
+    if (DRPAI_STATUS_RUN == priv->drpai_status.status)
+    {
+        spin_unlock_irqrestore(&priv->lock, flags);
+        result = -EBUSY;
+        goto end;
+    }
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+/* V2L conditional compilation */
+#if 0
+/* DRP single operation */
+    if(DRPAI_EXE_AI == exe_mode)
+    {
+#endif
+        /* Copy arguments from user space to kernel space */
+        if (copy_from_user(&proc[0], (void __user *)arg, sizeof(proc)))
+        {
+            result = -EFAULT;
+            goto end;
+        }
+        /* Check Argument */
+        for (i = DRPAI_INDEX_DRP_DESC; i < DRPAI_INDEX_NUM; i++)
+        {
+            addr = proc[i].address;
+            size = proc[i].size;
+            if (0 != (addr & DRPAI_64BYTE_ALIGN))
+            {
+                result = -EINVAL;
+                goto end;
+            }
+            if (0 != drpai_check_area(addr, size))
+            {
+                result = -EINVAL;
+                goto end;
+            }
+        }
+
+        /* Check if input is in linux memory region */
+        if(0 == atomic_read(&drpai_rw_status->inout_flag))
+        {
+            DRPAI_DEBUG_PRINT("Use arg variable\n");
+            addr = proc[DRPAI_INDEX_INPUT].address;
+            size = proc[DRPAI_INDEX_INPUT].size;
+            if(0 != drpai_flush_dcache_input_area(addr, size))
+            {
+                result = -EFAULT;
+                goto end;
+            }
+            /* Change input address to value specified by user app. */
+            addr = proc[DRPAI_INDEX_DRP_PARAM].address;
+            if (drpai_rw_status->adrconv_en)
+            {
+                uint32_t vinput;
+
+                if(0 != reverse_adrconv_tbl(&drpai_rw_status->adrconv_tbl[0], proc[DRPAI_INDEX_INPUT].address, &vinput))
+                {
+                    result = -ENOMEM;
+                    goto end;
+                }
+
+                if(0 != drp_param_change32(addr, 0, vinput))
+                {
+                    result = -EFAULT;
+                    goto end;
+                }
+            }
+            else
+            {
+                if(0 != (proc[DRPAI_INDEX_INPUT].address >> 32))
+                {
+                    result = -EINVAL;
+                    goto end;
+                }
+
+                if(0 != drp_param_change32(addr, 0, (uint32_t)proc[DRPAI_INDEX_INPUT].address))
+                {
+                    result = -EFAULT;
+                    goto end;
+                }
+            }
+        }
+
+        if (drpai_rw_status->adrconv_en)
+        {
+            if (0 != reverse_adrconv_tbl(&drpai_rw_status->adrconv_tbl[0], proc[DRPAI_INDEX_DRP_DESC].address, &drp_desc_addr))
+            {
+                result = -ENOMEM;
+                goto end;
+            }
+
+            if (0 != reverse_adrconv_tbl(&drpai_rw_status->adrconv_tbl[0], proc[DRPAI_INDEX_AIMAC_DESC].address, &aimac_desc_addr))
+            {
+                result = -ENOMEM;
+                goto end;
+            }
+
+            if (0 != reverse_adrconv_tbl(&drpai_rw_status->adrconv_tbl[0], proc[DRPAI_INDEX_AIMAC_PARAM_DESC].address, &aimac_param_desc_addr))
+            {
+                result = -ENOMEM;
+                goto end;
+            }
+        }
+        else
+        {
+            if (0 != (proc[DRPAI_INDEX_DRP_DESC].address >> 32))
+            {
+                result = -EINVAL;
+                goto end;
+            }
+
+            if (0 != (proc[DRPAI_INDEX_AIMAC_DESC].address >> 32))
+            {
+                result = -EINVAL;
+                goto end;
+            }
+
+            if (0 != (proc[DRPAI_INDEX_AIMAC_PARAM_DESC].address >> 32))
+            {
+                result = -EINVAL;
+                goto end;
+            }
+        }
+
+        spin_lock_irqsave(&priv->lock, flags);
+        /* Init drpai_status.err */
+        priv->drpai_status.err    = DRPAI_ERRINFO_SUCCESS;
+        /* IDLE -> RUN */
+        priv->drpai_status.status = DRPAI_STATUS_RUN;
+        priv->irq_flag = IRQ_CHECK_ENABLE;
+        spin_unlock_irqrestore(&priv->lock, flags);
+
+        DRPAI_DEBUG_PRINT("status2:   %d\n", priv->drpai_status.status);
+
+        (void)R_DRPAI_DRP_SetMaxFreq(drp_base_addr[0], 0, drpai_rw_status->drp_mindiv);
+        (void)R_DRPAI_AIMAC_SetFreq(aimac_base_address[0], 0, drpai_rw_status->drpai_divfix);
+
+        /* Kick */
+        if (drpai_rw_status->adrconv_en)
+        {
+            R_DRPAI_DRP_DisableAddrReloc(drp_base_addr[0]);
+            (void)R_DRPAI_DRP_EnableAddrReloc(drp_base_addr[0], &drpai_rw_status->adrconv_tbl[0]);
+            R_DRPAI_AIMAC_DisableAddrReloc(aimac_base_address[0]);
+            (void)R_DRPAI_AIMAC_EnableAddrReloc(aimac_base_address[0], &drpai_rw_status->adrconv_tbl[0]);
+            R_DRPAI_DRP_Start(drp_base_addr[0], 0, drp_desc_addr);
+            R_DRPAI_AIMAC_Start(aimac_base_address[0], 0, aimac_desc_addr, aimac_param_desc_addr);
+        }
+        else
+        {
+            R_DRPAI_DRP_DisableAddrReloc(drp_base_addr[0]);
+            R_DRPAI_AIMAC_DisableAddrReloc(aimac_base_address[0]);
+            R_DRPAI_DRP_Start(drp_base_addr[0], 0, proc[DRPAI_INDEX_DRP_DESC].address);
+            R_DRPAI_AIMAC_Start(aimac_base_address[0], 0, proc[DRPAI_INDEX_AIMAC_DESC].address, proc[DRPAI_INDEX_AIMAC_PARAM_DESC].address);
+        }
+/* V2L conditional compilation */
+#if 0
+    }
+    else if (DRPAI_EXE_DRP == exe_mode)
+    {
+        odif_intcnto.ch0 = 0;
+        odif_intcnto.ch1 = 0;
+        odif_intcnto.ch2 = 0;
+        odif_intcnto.ch3 = 0;
+
+        DRPAI_DEBUG_PRINT("DRP exe mode:%d\n", exe_mode);
+        if (copy_from_user(&proc_drp[0], (void __user *)arg, sizeof(proc_drp)))
+        {
+            result = -EFAULT;
+            goto end;
+        }
+        /* Check Argument */
+        for (i = 0; i < (seq.num * 2); i++)
+        {
+            if (0 != (proc_drp[i].address & DRPAI_64BYTE_ALIGN))
+            {
+                result = -EINVAL;
+                goto end;
+            }
+        }
+        for (i = 0; i < seq.num; i++)
+        {
+            /* DRPcfg address and size settings */
+            *(uint32_t*)(p_dmabuf_vaddr + (DRPAI_SGL_DRP_DESC_SIZE * i) + 4) = proc_drp[i * 2].address;
+            *(uint32_t*)(p_dmabuf_vaddr + (DRPAI_SGL_DRP_DESC_SIZE * i) + 8) = proc_drp[i * 2].size;
+
+            /* DRP param address and size settings */
+            *(uint32_t*)(p_dmabuf_vaddr + (DRPAI_SGL_DRP_DESC_SIZE * i) + 36) = proc_drp[i * 2 + 1].address;
+            *(uint32_t*)(p_dmabuf_vaddr + (DRPAI_SGL_DRP_DESC_SIZE * i) + 40) = proc_drp[i * 2 + 1].size;
+
+            /* Link descriptor settings */
+            if (i < (seq.num - 1))
+            {
+                /* LV enable */
+                *(p_dmabuf_vaddr + (DRPAI_SGL_DRP_DESC_SIZE * i) + 67) = 0x09;
+
+                /* Link pointer settings */
+                if (DRPAI_DRP_NOLOAD == proc_drp[(i + 1) * 2].address)
+                {
+                    *(uint32_t*)(p_dmabuf_vaddr + (DRPAI_SGL_DRP_DESC_SIZE * i) + 68)
+                    = p_dmabuf_phyaddr + (DRPAI_SGL_DRP_DESC_SIZE * (i + 1)) + DRPAI_DESC_CMD_SIZE;
+                }
+                else
+                {
+                    *(uint32_t*)(p_dmabuf_vaddr + (DRPAI_SGL_DRP_DESC_SIZE * i) + 68)
+                    = p_dmabuf_phyaddr + (DRPAI_SGL_DRP_DESC_SIZE * (i + 1));
+                }
+            }
+            else
+            {
+                /* LV disable */
+                *(p_dmabuf_vaddr + (DRPAI_SGL_DRP_DESC_SIZE * i) + 67) = 0x08;
+            }
+        }
+        __flush_dcache_area(p_dmabuf_vaddr, DRPAI_CMA_SIZE);
+
+        /* DRPcfg load skip */
+        if (DRPAI_DRP_NOLOAD == proc_drp[0].address)
+        {
+            p_dmabuf_phyaddr = p_dmabuf_phyaddr + DRPAI_DESC_CMD_SIZE;
+        }
+
+        spin_lock_irqsave(&priv->lock, flags);
+        /* Init drpai_status.err */
+        priv->drpai_status.err = DRPAI_ERRINFO_SUCCESS;
+        /* IDLE -> RUN */
+        priv->drpai_status.status = DRPAI_STATUS_RUN;
+        priv->irq_flag = IRQ_CHECK_ENABLE;
+        spin_unlock_irqrestore(&priv->lock, flags);
+        DRPAI_DEBUG_PRINT("status2:   %d\n", priv->drpai_status.status);
+
+        /* Kick */
+        (void)R_DRPAI_DRP_Start(drp_base_addr[0], 0, p_dmabuf_phyaddr);
+        (void)R_DRPAI_AIMAC_Start(aimac_base_address[0], 0, p_dmabuf_phyaddr + (DRPAI_SGL_DRP_DESC_SIZE * DRPAI_SEQ_NUM), &priv->lock);
+    }
+    else
+    {
+        // do nothing
+    }
+/* DRP single operation */
+#endif
+
+    DRPAI_DEBUG_WAIT();
+    goto end;
+end:
+    if(-ETIMEDOUT != result)
+    {
+        up(&priv->sem);
+    }
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return result;
+}
+
+static int32_t reverse_adrconv_tbl(uint8_t *adrconv_tbl, uint64_t conv, uint32_t *org)
+{
+    int32_t result = 0;
+    uint32_t tbl;
+
+    if (0 != (conv >> 40))
+    {
+        result = -1;
+        goto end;
+    }
+
+    for (tbl = 0; tbl < DRPAI_ADRCONV_TBL_NUM; tbl++)
+    {
+        if ((1 == adrconv_tbl[tbl * 4 + 0]) && (0 == adrconv_tbl[tbl * 4 + 1]))
+        {
+            if ((((uint32_t)(conv >> 24) & 0xFF) == adrconv_tbl[tbl * 4 + 2]) &&
+                (((uint32_t)(conv >> 32) & 0xFF) == adrconv_tbl[tbl * 4 + 3]))
+            {
+                if (NULL != org)
+                {
+                    *org = ((tbl << 24) | ((uint32_t)conv & 0xFFFFFF));
+                }
+                break;
+            }
+        }
+    }
+    if (DRPAI_ADRCONV_TBL_NUM <= tbl)
+    {
+        result = -1;
+    }
+    goto end;
+
+end:
+    return result;
+}
+
+static long drpai_ioctl_reset(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    long result = 0;
+    struct drpai_priv *priv = drpai_priv;
+#ifdef DRPAI_DRV_DEBUG
+    struct drpai_rw_status *drpai_rw_status = filp->private_data;
+#endif
+    unsigned long flags;
+/* V2L conditional compilation */
+#if 0
+    void (*finish_callback)(int);
+#endif
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+/* V2L conditional compilation */
+#if 0
+    /* ISP */
+    spin_lock_irqsave(&priv->lock, flags);
+    finish_callback = drpai_priv->isp_finish_loc;
+    spin_unlock_irqrestore(&priv->lock, flags);
+    /* ISP */
+#endif
+
+    if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT)))
+    {
+        result = -ETIMEDOUT;
+        goto end;
+    }
+    DRPAI_DEBUG_PRINT(" \n");
+    DRPAI_DEBUG_PRINT("status1:   %d\n", priv->drpai_status.status);
+    DRPAI_DEBUG_PRINT("status_rw1:%d\n", drpai_rw_status->rw_status);
+
+    if(R_DRPAI_SUCCESS != drpai_reset_device(0))
+    {
+        result = -EIO;
+        goto end;
+    }
+    drpai_init_device(0);
+
+    /* Update internal state */
+    spin_lock_irqsave(&priv->lock, flags);
+    priv->drpai_status.err    = DRPAI_ERRINFO_RESET;
+    priv->drpai_status.status = DRPAI_STATUS_IDLE;
+    priv->irq_flag            = IRQ_CHECK_DISABLE;
+
+    /* Wake up the process */
+    wake_up_interruptible( &drpai_waitq );
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+/* V2L conditional compilation */
+#if 0
+    /* ISP */
+    /* For reset ISP call back*/
+    if(NULL != finish_callback)
+    {
+        /* ERROR No.: ERESTART*/
+        (*finish_callback)(-ERESTART);
+    }
+    spin_lock_irqsave(&priv->lock, flags);
+    drpai_priv->isp_finish_loc = NULL;
+    spin_unlock_irqrestore(&priv->lock, flags);
+    /* For reset ISP call back*/
+    /* ISP */
+#endif
+
+    DRPAI_DEBUG_PRINT("status2:   %d\n", priv->drpai_status.status);
+    DRPAI_DEBUG_PRINT("status_rw2:%d\n", drpai_rw_status->rw_status);
+
+    result = 0;
+
+    DRPAI_DEBUG_WAIT();
+    goto end;
+end:
+    if(-ETIMEDOUT != result)
+    {
+        up(&priv->sem);
+    }
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return result;
+}
+
+static long drpai_ioctl_get_status(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    long result = 0;
+    drpai_status_t local_drpai_status;
+    struct drpai_priv *priv = drpai_priv;
+    unsigned long flags;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT)))
+    {
+        result = -ETIMEDOUT;
+        goto end;
+    }
+    DRPAI_DEBUG_PRINT(" \n");
+    /* Check NULL */
+    if (0 == arg)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    /* Get the internal state of DRP-AI */
+    spin_lock_irqsave(&priv->lock, flags);
+    R_DRPAI_Status(drp_base_addr[0], aimac_base_address[0], 0, &priv->drpai_status.reserved[0]); /* Improve IF of drpai-core */
+
+    /* Copy arguments from kernel space to user space */
+    local_drpai_status = priv->drpai_status;
+    spin_unlock_irqrestore(&priv->lock, flags);
+    if (copy_to_user((void __user *)arg, &local_drpai_status, sizeof(drpai_status_t)))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+
+    /* Check status */
+    if (DRPAI_STATUS_RUN == local_drpai_status.status)
+    {
+        result = -EBUSY;
+        goto end;
+    }
+
+    /* Check DRP-AI H/W error */
+    if ((DRPAI_ERRINFO_DRP_ERR == local_drpai_status.err) || (DRPAI_ERRINFO_AIMAC_ERR == local_drpai_status.err))
+    {
+        result = -EIO;
+        goto end;
+    }
+
+    DRPAI_DEBUG_WAIT();
+    goto end;
+end:
+    if(-ETIMEDOUT != result)
+    {
+        up(&priv->sem);
+    }
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return result;
+}
+
+static long drpai_ioctl_reg_dump(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    long result = 0;
+    struct drpai_rw_status *drpai_rw_status = filp->private_data;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    if(unlikely(down_timeout(&rw_sem, MAX_SEM_TIMEOUT)))
+    {
+        result = -ETIMEDOUT;
+        goto end;
+    }
+    DRPAI_DEBUG_PRINT(" \n");
+    DRPAI_DEBUG_PRINT("status_rw1:%d\n", drpai_rw_status->rw_status);
+
+    /* Check of writing and reading completion of DRP-AI obj file */
+    if (DRPAI_STATUS_IDLE_RW != drpai_rw_status->rw_status)
+    {
+        result = -EACCES;
+        goto end;
+    }
+
+    /* Initialization of register dump processing variables */
+    drpai_rw_status->rw_status              = DRPAI_STATUS_DUMP_REG;
+    drpai_rw_status->read_count             = 0;
+    drpai_rw_status->drp_reg_offset_count   = 0;
+    drpai_rw_status->aimac_reg_offset_count = 0;
+
+    DRPAI_DEBUG_WAIT();
+    goto end;
+end:
+    if(-ETIMEDOUT != result)
+    {
+        up(&rw_sem);
+    }
+    DRPAI_DEBUG_PRINT("status_rw2:%d\n", drpai_rw_status->rw_status);
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return result;
+}
+
+static long drpai_ioctl_assign_param(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    long result = 0;
+    struct drpai_rw_status *drpai_rw_status = filp->private_data;
+    drpai_assign_param_t drpai_assign_param_buf;
+    char *vbuf;
+    uint64_t addr, size;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    if(unlikely(down_trylock(&rw_sem)))
+    {
+        result = -ERESTART;
+        goto end;
+    }
+	/* Check NULL */
+    if (0 == arg)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+    DRPAI_DEBUG_PRINT("status_rw1:%d\n", drpai_rw_status->rw_status);
+    /* Check status */
+    if (DRPAI_STATUS_IDLE_RW != drpai_rw_status->rw_status)
+    {
+        result = -EACCES;
+        goto end;
+    }
+    if(drpai_rw_status->param_info)
+    {
+        result = -EFAULT;
+        goto end;
+    }
+
+    /* Copy arguments from user space to kernel space */
+    if (copy_from_user(&drpai_assign_param_buf, (void __user *)arg, sizeof(drpai_assign_param_t)))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+    if((0 == drpai_assign_param_buf.info_size) || (0 == drpai_assign_param_buf.obj.size))
+    {
+        result = -EINVAL;
+        goto end;
+    }
+    addr = drpai_assign_param_buf.obj.address;
+    size = drpai_assign_param_buf.obj.size;
+    if (0 != drpai_check_area(addr, size))
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    /* Allocate memory for *_param_info.txt */
+    vbuf = vmalloc(drpai_assign_param_buf.info_size + 1);
+    if(!vbuf){
+        result = -EFAULT;
+        goto end;
+    }
+    vbuf[drpai_assign_param_buf.info_size] = '\0';
+
+    /* Initialization of read / write processing variables */
+    drpai_rw_status->rw_status    = DRPAI_STATUS_ASSIGN_PARAM;
+    drpai_rw_status->write_count  = 0;
+    drpai_rw_status->assign_param = drpai_assign_param_buf;
+    drpai_rw_status->param_info   = vbuf;
+
+    DRPAI_DEBUG_WAIT();
+end:
+    if(-ERESTART != result)
+    {
+        up(&rw_sem);
+    }
+    DRPAI_DEBUG_PRINT("status_rw2:%d\n", drpai_rw_status->rw_status);
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return result;
+}
+
+/* Note: This function change line variable. so if you use, check your variables address */
+static char* get_param_attr(char *line, char *attr, unsigned long *rvalue, char **str)
+{
+    char *result;
+    char *ptr_stmp, *ptr_etmp;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    if((NULL == line) || (NULL == attr))
+    {
+        result = NULL;
+        goto end;
+    }
+
+    ptr_stmp = strstr(line, attr);
+    if(NULL == ptr_stmp)
+    {
+        result = NULL;
+        goto end;
+    }
+    ptr_stmp += strlen(attr);
+    ptr_etmp = strstr(ptr_stmp, ",");
+    if(NULL == ptr_etmp)
+    {
+        result = NULL;
+        goto end;
+    }
+    *ptr_etmp = '\0';
+    if(NULL != rvalue)
+    {
+        if(0 != kstrtoul(ptr_stmp, 10, rvalue))
+        {
+            result = NULL;
+            goto end;
+        }
+    }
+    if(NULL != str)
+    {
+        *str = ptr_stmp;
+    }
+    result = ptr_etmp + 1;
+
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
+    return result;
+}
+
+static int8_t drp_param_change16(uint64_t base, uint64_t offset, uint16_t value)
+{
+    int8_t result = 0;
+    volatile void *virt_addr = 0;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    virt_addr = phys_to_virt(base + offset);
+    if (0 == virt_addr)
+    {
+        result = -1;
+        goto end;
+    }
+    iowrite16(value, (void *)virt_addr);
+    __flush_dcache_area((void *)virt_addr, sizeof(value));
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return result;
+}
+static int8_t drp_param_change32(uint64_t base, uint64_t offset, uint32_t value)
+{
+    int8_t result = 0;
+    volatile void *virt_addr = 0;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    virt_addr = phys_to_virt(base + offset);
+    if (0 == virt_addr)
+    {
+        result = -1;
+        goto end;
+    }
+    iowrite32(value, (void *)virt_addr);
+    __flush_dcache_area((void *)virt_addr, sizeof(value));
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return result;
+}
+
+static int32_t drpai_check_area(uint64_t addr, uint64_t size)
+{
+    int32_t result = -1;
+
+    if ((drpai_region_base_addr <= addr) &&
+        ((drpai_region_base_addr + drpai_region_size) >= (addr + size)))
+    {
+        result = 0;
+    }
+    else if ((0 != drpai_region2_size) &&
+        (drpai_region2_base_addr <= addr) &&
+        ((drpai_region2_base_addr + drpai_region2_size) >= (addr + size)))
+    {
+        result = 0;
+    }
+    else if ((DRPAI_SRAM_ADDR <= addr) &&
+        ((DRPAI_SRAM_ADDR + DRPAI_SRAM_SIZE) >= (addr + size)))
+    {
+        result = 0;
+    }
+
+    return result;
+}
+
+static int8_t drpai_flush_dcache_input_area(uint64_t addr, uint64_t size)
+{
+    int8_t result = 0;
+    uint64_t flush_addr, flush_size;
+    uint64_t input_saddr, input_eaddr, linux_mem_saddr, linux_mem_eaddr;
+    volatile void *p_input = 0;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    input_saddr      = addr;
+    input_eaddr      = addr + size - 1;
+
+    linux_mem_saddr  = drpai_linux_mem_start;
+    linux_mem_eaddr  = drpai_linux_mem_start + drpai_linux_mem_size - 1;
+    if ((input_saddr >= linux_mem_saddr) &&
+        (input_eaddr <= linux_mem_eaddr))
+    {
+        flush_addr = addr;
+        flush_size = size;
+    }
+    else if ((input_saddr >= linux_mem_saddr) &&
+             (input_saddr <= linux_mem_eaddr) &&
+             (input_eaddr >  linux_mem_eaddr))
+    {
+        flush_addr = addr;
+        flush_size = (drpai_linux_mem_start + drpai_linux_mem_size) - addr;
+    }
+    else if((input_eaddr >= linux_mem_saddr) &&
+            (input_eaddr <= linux_mem_eaddr) &&
+            (input_saddr <  linux_mem_saddr))
+    {
+        flush_addr = drpai_linux_mem_start;
+        flush_size = (addr + size) - drpai_linux_mem_start;
+    }
+    else
+    {
+        flush_addr = 0;
+        flush_size = 0;
+    }
+
+    if (0 == flush_size)
+    {
+        linux_mem_saddr  = drpai_linux_mem2_start;
+        linux_mem_eaddr  = drpai_linux_mem2_start + drpai_linux_mem2_size - 1;
+        if ((input_saddr >= linux_mem_saddr) &&
+            (input_eaddr <= linux_mem_eaddr))
+        {
+            flush_addr = addr;
+            flush_size = size;
+        }
+        else if ((input_saddr >= linux_mem_saddr) &&
+                 (input_saddr <= linux_mem_eaddr) &&
+                 (input_eaddr >  linux_mem_eaddr))
+        {
+            flush_addr = addr;
+            flush_size = (drpai_linux_mem2_start + drpai_linux_mem2_size) - addr;
+        }
+        else if((input_eaddr >= linux_mem_saddr) &&
+                (input_eaddr <= linux_mem_eaddr) &&
+                (input_saddr <  linux_mem_saddr))
+        {
+            flush_addr = drpai_linux_mem2_start;
+            flush_size = (addr + size) - drpai_linux_mem2_start;
+        }
+        else
+        {
+            flush_addr = 0;
+            flush_size = 0;
+        }
+    }
+
+    if (0 == flush_size)
+    {
+        linux_mem_saddr  = drpai_linux_mem3_start;
+        linux_mem_eaddr  = drpai_linux_mem3_start + drpai_linux_mem3_size - 1;
+        if ((input_saddr >= linux_mem_saddr) &&
+            (input_eaddr <= linux_mem_eaddr))
+        {
+            flush_addr = addr;
+            flush_size = size;
+        }
+        else if ((input_saddr >= linux_mem_saddr) &&
+                 (input_saddr <= linux_mem_eaddr) &&
+                 (input_eaddr >  linux_mem_eaddr))
+        {
+            flush_addr = addr;
+            flush_size = (drpai_linux_mem3_start + drpai_linux_mem3_size) - addr;
+        }
+        else if((input_eaddr >= linux_mem_saddr) &&
+                (input_eaddr <= linux_mem_eaddr) &&
+                (input_saddr <  linux_mem_saddr))
+        {
+            flush_addr = drpai_linux_mem3_start;
+            flush_size = (addr + size) - drpai_linux_mem3_start;
+        }
+        else
+        {
+            flush_addr = 0;
+            flush_size = 0;
+        }
+    }
+
+    if (0 == flush_size)
+    {
+        linux_mem_saddr  = drpai_region_base_addr;
+        linux_mem_eaddr  = drpai_region_base_addr + drpai_region_size - 1;
+        if ((input_saddr >= linux_mem_saddr) &&
+            (input_eaddr <= linux_mem_eaddr))
+        {
+            flush_addr = addr;
+            flush_size = size;
+        }
+        else if ((input_saddr >= linux_mem_saddr) &&
+                 (input_saddr <= linux_mem_eaddr) &&
+                 (input_eaddr >  linux_mem_eaddr))
+        {
+            flush_addr = addr;
+            flush_size = (drpai_region_base_addr + drpai_region_size) - addr;
+        }
+        else if((input_eaddr >= linux_mem_saddr) &&
+                (input_eaddr <= linux_mem_eaddr) &&
+                (input_saddr <  linux_mem_saddr))
+        {
+            flush_addr = drpai_region_base_addr;
+            flush_size = (addr + size) - drpai_region_base_addr;
+        }
+        else
+        {
+            flush_addr = 0;
+            flush_size = 0;
+        }
+    }
+
+    if (0 == flush_size)
+    {
+        linux_mem_saddr  = drpai_region2_base_addr;
+        linux_mem_eaddr  = drpai_region2_base_addr + drpai_region2_size - 1;
+        if ((input_saddr >= linux_mem_saddr) &&
+            (input_eaddr <= linux_mem_eaddr))
+        {
+            flush_addr = addr;
+            flush_size = size;
+        }
+        else if ((input_saddr >= linux_mem_saddr) &&
+                 (input_saddr <= linux_mem_eaddr) &&
+                 (input_eaddr >  linux_mem_eaddr))
+        {
+            flush_addr = addr;
+            flush_size = (drpai_region2_base_addr + drpai_region2_size) - addr;
+        }
+        else if((input_eaddr >= linux_mem_saddr) &&
+                (input_eaddr <= linux_mem_eaddr) &&
+                (input_saddr <  linux_mem_saddr))
+        {
+            flush_addr = drpai_region2_base_addr;
+            flush_size = (addr + size) - drpai_region2_base_addr;
+        }
+        else
+        {
+            flush_addr = 0;
+            flush_size = 0;
+        }
+    }
+
+    if (0 == flush_size)
+    {
+        linux_mem_saddr  = image_region_addr;
+        linux_mem_eaddr  = image_region_addr + image_region_size - 1;
+        if ((input_saddr >= linux_mem_saddr) &&
+            (input_eaddr <= linux_mem_eaddr))
+        {
+            flush_addr = addr;
+            flush_size = size;
+        }
+        else if ((input_saddr >= linux_mem_saddr) &&
+                 (input_saddr <= linux_mem_eaddr) &&
+                 (input_eaddr >  linux_mem_eaddr))
+        {
+            flush_addr = addr;
+            flush_size = (image_region_addr + image_region_size) - addr;
+        }
+        else if((input_eaddr >= linux_mem_saddr) &&
+                (input_eaddr <= linux_mem_eaddr) &&
+                (input_saddr <  linux_mem_saddr))
+        {
+            flush_addr = image_region_addr;
+            flush_size = (addr + size) - image_region_addr;
+        }
+        else
+        {
+            flush_addr = 0;
+            flush_size = 0;
+        }
+    }
+
+    DRPAI_DEBUG_PRINT("flush_addr = 0x%016llX, flush_size = 0x%016llX\n", flush_addr, flush_size);
+    if (0 != flush_size)
+    {
+        /* Input data area cache flush */
+        p_input = phys_to_virt(flush_addr);
+        if (0 == p_input)
+        {
+            result = -1;
+            goto end;
+        }
+        __flush_dcache_area((void *)p_input, flush_size);
+    }
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return result;
+}
+
+static long drpai_ioctl_prepost_crop(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    long result = 0;
+    struct drpai_priv *priv = drpai_priv;
+    unsigned long flags;
+    struct drpai_rw_status *drpai_rw_status = filp->private_data;
+    drpai_crop_t crop_param_buf;
+    char *buf = NULL;
+    uint32_t buf_len;
+    char *ptr;
+    char *prev_ptr;
+    unsigned long offset_add0;
+    unsigned long offset_add1;
+    int mode = 0;
+    uint64_t addr;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    /* Check the internal state of DRP-AI */
+    spin_lock_irqsave(&priv->lock, flags);
+    if(DRPAI_STATUS_RUN == priv->drpai_status.status)
+    {
+        spin_unlock_irqrestore(&priv->lock, flags);
+        result = -EBUSY;
+        goto end;
+    }
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+    if(unlikely(down_trylock(&rw_sem)))
+    {
+        result = -ERESTART;
+        goto end;
+    }
+    DRPAI_DEBUG_PRINT("status_rw1:%d\n", drpai_rw_status->rw_status);
+
+    /* Check NULL */
+    if (0 == arg)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+    if((NULL == drpai_rw_status->param_info) ||
+       (DRPAI_STATUS_ASSIGN_PARAM == drpai_rw_status->rw_status) ||
+       (DRPAI_STATUS_WRITE_PARAM  == drpai_rw_status->rw_status))
+    {
+        result = -EACCES;
+        goto end;
+    }
+    /* Copy arguments from user space to kernel space */
+    if (copy_from_user(&crop_param_buf, (void __user *)arg, sizeof(drpai_crop_t)))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+    /* Check if there is in drpai dedicated area */
+    if((drpai_rw_status->assign_param.obj.address != crop_param_buf.obj.address) ||
+       (drpai_rw_status->assign_param.obj.size != crop_param_buf.obj.size))
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    /* Search argument */
+    ptr = drpai_rw_status->param_info;
+    while(1)
+    {
+        /* End of info_buf */
+        if(('\0' == *ptr) || (ptr >= drpai_rw_status->param_info + drpai_rw_status->assign_param.info_size))
+        {
+            result = -EFAULT;
+            goto end;
+        }
+
+        /* Save current pointer */
+        prev_ptr = ptr;
+
+        /* Get 1 line */
+        ptr = strchr(ptr, '\n');
+        if(NULL == ptr)
+        {
+            ptr = drpai_rw_status->param_info + drpai_rw_status->assign_param.info_size;
+        }
+        else
+        {
+            ptr += 1;
+        }
+        if(ptr <= prev_ptr)
+        {
+            result = -EFAULT;
+            goto end;
+        }
+        buf_len = ptr - prev_ptr;
+
+        /* Copy only 1line to buffer */
+        buf = vmalloc(buf_len + 1);
+        if(NULL == buf)
+        {
+            result = -EFAULT;
+            goto end;
+        }
+        strncpy(buf, prev_ptr, buf_len);
+        buf[buf_len] = '\0';
+
+        if(0 == mode)
+        {
+            /* Check if there is DRP_LIB_NAME_CROP in this line */
+            if(NULL != strstr(buf, DRP_LIB_NAME_CROP))
+            {
+                mode += 1;
+                if(NULL == get_param_attr(buf, DRP_PARAM_ATTR_OFFSET_ADD, &offset_add0, NULL))
+                {
+                    result = -EFAULT;
+                    goto end;
+                }
+            }
+        }
+        else if(1 == mode)
+        {
+            if(NULL != strstr(buf, DRP_PARAM_ATTR_OFFSET_ADD))
+            {
+                mode += 1;
+                if(NULL == get_param_attr(buf, DRP_PARAM_ATTR_OFFSET_ADD, &offset_add1, NULL))
+                {
+                    result = -EFAULT;
+                    goto end;
+                }
+                break;
+            }
+        }
+        vfree(buf);
+        buf = NULL;
+    }
+
+    DRPAI_DEBUG_PRINT("offset_add0=%d, offset_add1=%d\n", offset_add0, offset_add1);
+
+    /* Change parameters of drp_param.bin to value specified by user app. */
+    addr = crop_param_buf.obj.address;
+    if(0 != drp_param_change16(addr, (uint64_t)offset_add0 + DRP_PARAM_IMG_OWIDTH, crop_param_buf.img_owidth))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+    if(0 != drp_param_change16(addr, (uint64_t)offset_add0 + DRP_PARAM_IMG_OHEIGHT, crop_param_buf.img_oheight))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+    if(0 != drp_param_change16(addr, (uint64_t)offset_add0 + DRP_PARAM_CROP_POS_X, crop_param_buf.pos_x))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+    if(0 != drp_param_change16(addr, (uint64_t)offset_add0 + DRP_PARAM_CROP_POS_Y, crop_param_buf.pos_y))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+    if(0 != drp_param_change16(addr, (uint64_t)offset_add1 + DRP_PARAM_IMG_IWIDTH, crop_param_buf.img_owidth))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+    if(0 != drp_param_change16(addr, (uint64_t)offset_add1 + DRP_PARAM_IMG_IHEIGHT, crop_param_buf.img_oheight))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+
+    goto end;
+end:
+    DRPAI_DEBUG_WAIT();
+
+    if(NULL != buf)
+    {
+        vfree(buf);
+    }
+    if((-EBUSY != result) || (-ERESTART != result))
+    {
+        up(&rw_sem);
+    }
+    DRPAI_DEBUG_PRINT("status_rw2:%d\n", drpai_rw_status->rw_status);
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return result;
+}
+static long drpai_ioctl_prepost_inaddr(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    long result = 0;
+    struct drpai_priv *priv = drpai_priv;
+    struct drpai_rw_status *drpai_rw_status = filp->private_data;
+    drpai_inout_t inout_param_buf;
+    char *buf = NULL;
+    uint32_t buf_len;
+    char *ptr;
+    char *prev_ptr;
+    unsigned long flags;
+    unsigned long offset_add;
+    uint64_t addr;
+    uint64_t size;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    /* Check the internal state of DRP-AI */
+    spin_lock_irqsave(&priv->lock, flags);
+    if(DRPAI_STATUS_RUN == priv->drpai_status.status)
+    {
+        spin_unlock_irqrestore(&priv->lock, flags);
+        result = -EBUSY;
+        goto end;
+    }
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+    if(unlikely(down_trylock(&rw_sem)))
+    {
+        result = -ERESTART;
+        goto end;
+    }
+    DRPAI_DEBUG_PRINT("status_rw1:%d\n", drpai_rw_status->rw_status);
+
+    /* Check NULL */
+    if (0 == arg)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+    if((NULL == drpai_rw_status->param_info) ||
+       (DRPAI_STATUS_ASSIGN_PARAM == drpai_rw_status->rw_status) ||
+       (DRPAI_STATUS_WRITE_PARAM  == drpai_rw_status->rw_status))
+    {
+        result = -EACCES;
+        goto end;
+    }
+    /* Copy arguments from user space to kernel space */
+    if (copy_from_user(&inout_param_buf, (void __user *)arg, sizeof(drpai_inout_t)))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+    /* Check if there is in drpai dedicated area */
+    if((drpai_rw_status->assign_param.obj.address != inout_param_buf.obj.address) ||
+       (drpai_rw_status->assign_param.obj.size != inout_param_buf.obj.size))
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    /* Search argument */
+    ptr = drpai_rw_status->param_info;
+    while(1)
+    {
+        /* End of info_buf */
+        if(('\0' == *ptr) || (ptr >= drpai_rw_status->param_info + drpai_rw_status->assign_param.info_size))
+        {
+            result = -EFAULT;
+            goto end;
+        }
+
+        /* Save current pointer */
+        prev_ptr = ptr;
+
+        /* Get 1 line */
+        ptr = strchr(ptr, '\n');
+        if(NULL == ptr)
+        {
+            ptr = drpai_rw_status->param_info + drpai_rw_status->assign_param.info_size;
+        }
+        else
+        {
+            ptr += 1;
+        }
+        if(ptr <= prev_ptr)
+        {
+            result = -EFAULT;
+            goto end;
+        }
+        buf_len = ptr - prev_ptr;
+
+        /* Copy only 1line to buffer */
+        buf = vmalloc(buf_len + 1);
+        if(NULL == buf)
+        {
+            result = -EFAULT;
+            goto end;
+        }
+        strncpy(buf, prev_ptr, buf_len);
+        buf[buf_len] = '\0';
+
+        /* Check if there is DRP_PARAM_ATTR_PROP_INPUT in this line */
+        if(NULL != strstr(buf, DRP_PARAM_ATTR_PROP_INPUT))
+        {
+            if(NULL != strstr(buf, inout_param_buf.name))
+            {
+                if(NULL == get_param_attr(buf, DRP_PARAM_ATTR_OFFSET_ADD, &offset_add, NULL))
+                {
+                    result = -EFAULT;
+                    goto end;
+                }
+                break;
+            }
+        }
+        vfree(buf);
+        buf = NULL;
+    }
+
+    DRPAI_DEBUG_PRINT("offset_add=%d\n", offset_add);
+
+    /* Check if input is in linux memory region */
+    addr = inout_param_buf.data.address;
+    size = inout_param_buf.data.size;
+    if(0 != drpai_flush_dcache_input_area(addr, size))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+    /* Change parameters of drp_param.bin to value specified by user app. */
+    addr = inout_param_buf.obj.address;
+    if (drpai_rw_status->adrconv_en)
+    {
+        uint32_t vinput;
+
+        if(0 != reverse_adrconv_tbl(&drpai_rw_status->adrconv_tbl[0], inout_param_buf.data.address, &vinput))
+        {
+            result = -ENOMEM;
+            goto end;
+        }
+
+        if(0 != drp_param_change32(addr, (uint64_t)offset_add + DRP_PARAM_raddr, vinput))
+        {
+            result = -EFAULT;
+            goto end;
+        }
+    }
+    else
+    {
+        if(0 != (inout_param_buf.data.address >> 32))
+        {
+            result = -EINVAL;
+            goto end;
+        }
+
+        if(0 != drp_param_change32(addr, (uint64_t)offset_add + DRP_PARAM_raddr, (uint32_t)inout_param_buf.data.address))
+        {
+            result = -EFAULT;
+            goto end;
+        }
+    }
+    atomic_set(&drpai_rw_status->inout_flag, 1);
+
+    goto end;
+end:
+    DRPAI_DEBUG_WAIT();
+
+    if(NULL != buf)
+    {
+        vfree(buf);
+    }
+    if((-EBUSY != result) || (-ERESTART != result))
+    {
+        up(&rw_sem);
+    }
+    DRPAI_DEBUG_PRINT("status_rw2:%d\n", drpai_rw_status->rw_status);
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return result;
+}
+
+/* V2L conditional compilation */
+#if 0
+static long drpai_ioctl_set_seq(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    long result = 0;
+    struct drpai_priv *priv = drpai_priv;
+    unsigned long flags;
+
+    DRPAI_DEBUG_PRINT(" start.\n");
+    DRPAI_DEBUG_PRINT(" status1:%d\n", priv->drpai_status.status);
+
+    /* Check the internal state of DRP-AI */
+    spin_lock_irqsave(&priv->lock, flags);
+    if (DRPAI_STATUS_RUN == priv->drpai_status.status)
+    {
+        spin_unlock_irqrestore(&priv->lock, flags);
+        result = -EBUSY;
+        goto end;
+    }
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+    /* Copy arguments from user space to kernel space */
+    if (copy_from_user(&seq, (void __user *)arg, sizeof(drpai_seq_t)))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+
+    /* Check Argument DRP Simgle */
+    if (DRPAI_SEQ_NUM < seq.num)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    if (DRPAI_EXE_DRP == seq.order[0])
+    {
+        exe_mode = DRPAI_EXE_DRP;
+    }
+    else if (DRPAI_EXE_AI == seq.order[0])
+    {
+        exe_mode = DRPAI_EXE_AI;
+    }
+    else
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    DRPAI_DEBUG_PRINT(" DRP exe mode:%d\n", exe_mode);
+
+    DRPAI_DEBUG_PRINT(" status2:%d\n", priv->drpai_status.status);
+end:
+    DRPAI_DEBUG_PRINT(" end.\n");
+
+    return result;
+}
+/* DRP single operation */
+#endif
+
+static long drpai_ioctl_get_drpai_area(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    long result = 0;
+    struct drpai_priv *priv = drpai_priv;
+    struct drpai_rw_status *drpai_rw_status = filp->private_data;
+    drpai_data_t local_drpai_data;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT)))
+    {
+        result = -ETIMEDOUT;
+        goto end;
+    }
+
+    /* Check NULL */
+    if (0 == arg)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    if (0 == drpai_rw_status->get_drpai_area_count)
+    {
+        local_drpai_data.address = drpai_region_base_addr;
+        local_drpai_data.size    = drpai_region_size;
+
+        if (0 != drpai_region2_size)
+        {
+            drpai_rw_status->get_drpai_area_count = 1;
+        }
+    }
+    else
+    {
+        local_drpai_data.address = drpai_region2_base_addr;
+        local_drpai_data.size    = drpai_region2_size;
+
+        drpai_rw_status->get_drpai_area_count = 0;
+    }
+
+    if (copy_to_user((void __user *)arg, &local_drpai_data, sizeof(drpai_data_t)))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+
+    goto end;
+
+end:
+    if(-ETIMEDOUT != result)
+    {
+        up(&priv->sem);
+    }
+
+    DRPAI_DEBUG_PRINT("end.\n");
+    return result;
+}
+
+static long drpai_ioctl_set_drp_max_freq(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    long result = 0;
+    struct drpai_priv *priv = drpai_priv;
+    unsigned long flags;
+    struct drpai_rw_status *drpai_rw_status = filp->private_data;
+    uint32_t mindiv;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT)))
+    {
+        result = -ETIMEDOUT;
+        goto end;
+    }
+
+    /* Check the internal state of DRP-AI */
+    spin_lock_irqsave(&priv->lock, flags);
+    if(DRPAI_STATUS_RUN == priv->drpai_status.status)
+    {
+        spin_unlock_irqrestore(&priv->lock, flags);
+        result = -EBUSY;
+        goto end;
+    }
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+    /* Check NULL */
+    if (0 == arg)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    if (copy_from_user(&mindiv, (void __user *)arg, sizeof(uint32_t)))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+
+    if ((2 <= mindiv) && (127 >= mindiv))
+    {
+        drpai_rw_status->drp_mindiv = mindiv;
+    }
+    else
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    goto end;
+
+end:
+    if(-ETIMEDOUT != result)
+    {
+        up(&priv->sem);
+    }
+
+    DRPAI_DEBUG_PRINT("end.\n");
+    return result;
+}
+
+static long drpai_ioctl_set_drpai_freq(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    long result = 0;
+    struct drpai_priv *priv = drpai_priv;
+    unsigned long flags;
+    struct drpai_rw_status *drpai_rw_status = filp->private_data;
+    uint32_t divfix;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT)))
+    {
+        result = -ETIMEDOUT;
+        goto end;
+    }
+
+    /* Check the internal state of DRP-AI */
+    spin_lock_irqsave(&priv->lock, flags);
+    if(DRPAI_STATUS_RUN == priv->drpai_status.status)
+    {
+        spin_unlock_irqrestore(&priv->lock, flags);
+        result = -EBUSY;
+        goto end;
+    }
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+    /* Check NULL */
+    if (0 == arg)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    if (copy_from_user(&divfix, (void __user *)arg, sizeof(uint32_t)))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+
+    if ((1 <= divfix) && (127 >= divfix))
+    {
+        drpai_rw_status->drpai_divfix = divfix;
+    }
+    else
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    goto end;
+
+end:
+    if(-ETIMEDOUT != result)
+    {
+        up(&priv->sem);
+    }
+
+    DRPAI_DEBUG_PRINT("end.\n");
+    return result;
+}
+
+static long drpai_ioctl_set_adrconv(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    long result = 0;
+    struct drpai_priv *priv = drpai_priv;
+    unsigned long flags;
+    drpai_adrconv_t adrconv;
+    struct drpai_rw_status *drpai_rw_status = filp->private_data;
+    uint32_t tbl;
+    uint32_t page;
+    uint32_t tbl_num;
+    uint32_t map;
+    uint32_t offset;
+    uint32_t act_size;
+    uint64_t conv_addr;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT)))
+    {
+        result = -ETIMEDOUT;
+        DRPAI_DEBUG_PRINT("ETIMEOUT.\n");
+        goto end;
+    }
+
+    /* Check NULL */
+    if (0 == arg)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    if (copy_from_user(&adrconv, (void __user *)arg, sizeof(drpai_adrconv_t)))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+
+    spin_lock_irqsave(&priv->lock, flags);
+    if (DRPAI_STATUS_RUN == priv->drpai_status.status)
+    {
+        spin_unlock_irqrestore(&priv->lock, flags);
+        result = -EBUSY;
+        goto end;
+    }
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+    if ((DRPAI_ADRCONV_MODE_REPLACE == adrconv.mode) || (DRPAI_ADRCONV_MODE_DISABLE == adrconv.mode))
+    {
+#if 0 /* debug */
+        pr_info("[%s: %d](pid: %d) SET_ADRCONV clear table\n", __func__, __LINE__, current->pid);
+#endif
+        drpai_rw_status->adrconv_en = 0;
+        for (tbl = 0; tbl < DRPAI_ADRCONV_NUM; tbl++)
+        {
+            drpai_rw_status->adrconv_tbl[tbl] = 0;
+        }
+
+        if (0 != drpai_rw_status->image_region_vnum)
+        {
+            page = (drpai_rw_status->image_region_vaddr >> 24);
+            tbl_num = drpai_rw_status->image_region_vnum;
+            map = (image_region_addr >> 24);
+
+#if 0 /* debug */
+            pr_info("[%s: %d](pid: %d) SET_ADRCONV page=0x%02X, vnum=0x%02X, map=0x%04X\n", __func__, __LINE__, current->pid, page, tbl_num, map);
+#endif
+            for (tbl = page; tbl < (page + tbl_num); tbl++)
+            {
+                drpai_rw_status->adrconv_tbl[tbl * 4 + 0] = 1;             /* Valid           */
+                drpai_rw_status->adrconv_tbl[tbl * 4 + 1] = 0;             /* PG = 0 (16MB)   */
+                drpai_rw_status->adrconv_tbl[tbl * 4 + 2] = (map &  0xFF); /* MAP_ADDR[31:24] */
+                drpai_rw_status->adrconv_tbl[tbl * 4 + 3] = (map >>    8); /* MAP_ADDR[39:32] */
+                map++;
+            }
+        }
+    }
+
+    if ((DRPAI_ADRCONV_MODE_REPLACE == adrconv.mode) || (DRPAI_ADRCONV_MODE_ADD == adrconv.mode))
+    {
+        offset = (adrconv.org_address & DRPAI_MAX_24BIT);
+        if ((0 ==  adrconv.size) ||
+            ((uint32_t)(adrconv.conv_address & DRPAI_MAX_24BIT) != offset) ||
+            (DRPAI_MAX_32BIT < ((uint64_t)offset + (uint64_t)adrconv.size)))
+        {
+            result = -EINVAL;
+            goto end;
+        }
+
+        page = (adrconv.org_address >> 24);
+        act_size = offset + adrconv.size;
+        tbl_num = (act_size >> 24);
+        tbl_num = ((act_size & DRPAI_MAX_24BIT) == 0) ? tbl_num : tbl_num + 1;
+        if (DRPAI_ADRCONV_TBL_NUM < (page + tbl_num))
+        {
+            result = -EINVAL;
+            goto end;
+        }
+
+        /* check (same org_address) */
+        for (tbl = page; tbl < (page + tbl_num); tbl++)
+        {
+            if (0 != drpai_rw_status->adrconv_tbl[tbl * 4])
+            {
+                result = -ENOMEM;
+                goto end;
+            }
+        }
+
+        /* check (same conv_address) */
+        conv_addr = adrconv.conv_address;
+        for (tbl = page; tbl < (page + tbl_num); tbl++)
+        {
+            if (0 == reverse_adrconv_tbl(&drpai_rw_status->adrconv_tbl[0], conv_addr, NULL))
+            {
+                result = -ENOMEM;
+                goto end;
+            }
+            conv_addr += DRPAI_INF_24BIT;
+        }
+
+        drpai_rw_status->adrconv_en = 1;
+
+        /* apply */
+        map = (uint32_t)(adrconv.conv_address >> 24);
+#if 0 /* debug */
+        pr_info("[%s: %d](pid: %d) SET_ADRCONV page=0x%02X, tbl_num=0x%02X, map=0x%04X\n", __func__, __LINE__, current->pid, page, tbl_num, map);
+#endif
+        for (tbl = page; tbl < (page + tbl_num); tbl++)
+        {
+            drpai_rw_status->adrconv_tbl[tbl * 4 + 0] = 1;             /* Valid           */
+            drpai_rw_status->adrconv_tbl[tbl * 4 + 1] = 0;             /* PG = 0 (16MB)   */
+            drpai_rw_status->adrconv_tbl[tbl * 4 + 2] = (map &  0xFF); /* MAP_ADDR[31:24] */
+            drpai_rw_status->adrconv_tbl[tbl * 4 + 3] = (map >>    8); /* MAP_ADDR[39:32] */
+            map++;
+        }
+    }
+
+    goto end;
+
+end:
+    if(-ETIMEDOUT != result)
+    {
+        /* Return semaphore when no ETIMEOUT */
+        up(&priv->sem);
+    }
+
+    DRPAI_DEBUG_PRINT("end.\n");
+    return result;
+}
+
+static long drpai_ioctl_set_extra_area(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    long result = 0;
+    struct drpai_priv *priv = drpai_priv;
+    unsigned long flags;
+    uint32_t address;
+    struct drpai_rw_status *drpai_rw_status = filp->private_data;
+    uint32_t page;
+    uint32_t offset;
+    uint32_t act_size;
+    uint32_t tbl_num;
+    uint32_t tbl;
+    uint32_t map;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT)))
+    {
+        result = -ETIMEDOUT;
+        DRPAI_DEBUG_PRINT("ETIMEOUT.\n");
+        goto end;
+    }
+
+    /* Check NULL */
+    if (0 == arg)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    if (copy_from_user(&address, (void __user *)arg, sizeof(uint32_t)))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+
+    if ((DRPAI_MAX_32BIT != address) && (0 != (address & DRPAI_MAX_24BIT)))
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    if (0 == image_region_size)
+    {
+        result = -ENOMEM;
+        goto end;
+    }
+
+    page = (address >> 24);
+    offset = (image_region_addr & DRPAI_MAX_24BIT);
+    act_size = offset + image_region_size;
+    tbl_num = (act_size >> 24);
+    tbl_num = (0 == (act_size & DRPAI_MAX_24BIT)) ? tbl_num : tbl_num + 1;
+    if (DRPAI_ADRCONV_TBL_NUM < (page + tbl_num))
+    {
+        result = -ENOMEM;
+        goto end;
+    }
+
+    spin_lock_irqsave(&priv->lock, flags);
+    if (DRPAI_STATUS_RUN == priv->drpai_status.status)
+    {
+        spin_unlock_irqrestore(&priv->lock, flags);
+        result = -EBUSY;
+        goto end;
+    }
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+    drpai_rw_status->adrconv_en = 0;
+    for (tbl = 0; tbl < DRPAI_ADRCONV_NUM; tbl++)
+    {
+        drpai_rw_status->adrconv_tbl[tbl] = 0;
+    }
+
+    if (DRPAI_MAX_32BIT == address)
+    {
+#if 0 /* debug */
+        pr_info("[%s: %d](pid: %d) SET_EXTRA_AREA clear image region\n", __func__, __LINE__, current->pid);
+#endif
+        drpai_rw_status->image_region_vaddr = DRPAI_MAX_32BIT;
+        drpai_rw_status->image_region_vnum  = 0;
+    }
+    else
+    {
+        map = (image_region_addr >> 24);
+#if 0 /* debug */
+        pr_info("[%s: %d](pid: %d) SET_EXTRA_AREA page=0x%02X, vnum=0x%02X, map=0x%04X\n", __func__, __LINE__, current->pid, page, tbl_num, map);
+#endif
+        for (tbl = page; tbl < (page + tbl_num); tbl++)
+        {
+            drpai_rw_status->adrconv_tbl[tbl * 4 + 0] = 1;             /* Valid           */
+            drpai_rw_status->adrconv_tbl[tbl * 4 + 1] = 0;             /* PG = 0 (16MB)   */
+            drpai_rw_status->adrconv_tbl[tbl * 4 + 2] = (map &  0xFF); /* MAP_ADDR[31:24] */
+            drpai_rw_status->adrconv_tbl[tbl * 4 + 3] = (map >>    8); /* MAP_ADDR[39:32] */
+            map++;
+        }
+
+        drpai_rw_status->image_region_vaddr = (address | offset);
+        drpai_rw_status->image_region_vnum  = tbl_num;
+    }
+
+    goto end;
+
+end:
+    if(-ETIMEDOUT != result)
+    {
+        /* Return semaphore when no ETIMEOUT */
+        up(&priv->sem);
+    }
+
+    DRPAI_DEBUG_PRINT("end.\n");
+    return result;
+}
+
+static int drpai_drp_cpg_init(void)
+{
+    int result;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+/* V2L conditional compilation */
+#if 0
+    /* Access clock interface */
+    clk_prepare_enable(priv->clk_int);
+    clk_prepare_enable(priv->clk_aclk_drp);
+    clk_prepare_enable(priv->clk_mclk);
+    clk_prepare_enable(priv->clk_dclkin);
+    clk_prepare_enable(priv->clk_aclk);
+#endif
+
+#if 1 /* for CPG direct access (preliminary) */
+    result =  R_DRPAI_SUCCESS;
+    initialize_cpg(cpg_base_address);
+#endif
+
+    goto end;
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return result;
+}
+
+static int drpai_open_process(void)
+{
+    int ret;
+    struct drpai_priv *priv = drpai_priv;
+    unsigned long flags;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    /* Initialize CPG */
+    if(R_DRPAI_SUCCESS != drpai_drp_cpg_init())
+    {
+        ret = -EIO;
+        goto end;
+    }
+
+    /* Initialize DRP-AI */
+    drpai_init_device(0);
+
+    /* Reset DRP-AI */
+    if(R_DRPAI_SUCCESS != drpai_reset_device(0))
+    {
+        ret = -EIO;
+        goto end;
+    }
+
+    /* Initialize DRP-AI */
+    drpai_init_device(0);
+
+/* V2L conditional compilation */
+#if 0
+    if(R_DRPAI_SUCCESS != drpai_drp_config_init())
+    {
+        ret = -ENOMEM;
+        goto end;
+    }
+#endif
+
+    /* INIT -> IDLE */
+    spin_lock_irqsave(&priv->lock, flags);
+    priv->drpai_status.status = DRPAI_STATUS_IDLE;
+/* V2L conditional compilation */
+#if 0
+    exe_mode = DRPAI_EXE_AI;
+#endif
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+    ret = R_DRPAI_SUCCESS;
+    goto end;
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
+    return ret;
+}
+
+static int drpai_close_process(void)
+{
+    int ret;
+    struct drpai_priv *priv = drpai_priv;
+    unsigned long flags;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    (void)drpai_reset_device(0);
+
+/* V2L conditional compilation */
+#if 0
+    //CPG clock disable
+    DRPAI_DEBUG_PRINT("CPG clock disable\n");
+    clk_disable_unprepare(priv->clk_int);
+    clk_disable_unprepare(priv->clk_aclk_drp);
+    clk_disable_unprepare(priv->clk_mclk);
+    clk_disable_unprepare(priv->clk_dclkin);
+    clk_disable_unprepare(priv->clk_aclk);
+
+    drpai_drp_config_uninit();
+#endif
+
+    /* IDLE -> INIT */
+    /* RUN  -> INIT */
+    spin_lock_irqsave(&priv->lock, flags);
+    priv->drpai_status.status = DRPAI_STATUS_INIT;
+    priv->drpai_status.err    = DRPAI_ERRINFO_SUCCESS;
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+    ret = R_DRPAI_SUCCESS;
+    goto end;
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
+    return ret;
+}
+
+/* V2L conditional compilation */
+#if 0
+/* ISP */
+static int drpai_drp_config_init(void)
+{
+    int result;
+    struct drpai_priv *priv = drpai_priv;
+    struct device *dev = &priv->pdev->dev;
+    int i;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    /* Get driver workspace from Linux CMA */
+    p_dmabuf_vaddr = dma_alloc_coherent(dev, DRPAI_CMA_SIZE, &p_dmabuf_phyaddr, GFP_DMA);
+    if (NULL == p_dmabuf_vaddr)
+    {
+        /* Error -ENOMEM */
+        result = -1;
+        goto end;
+    }
+    DRPAI_DEBUG_PRINT("dmabuf:0x%08X, dmaphys:0x%08X\n", p_dmabuf_vaddr, p_dmabuf_phyaddr);
+
+    /* 64bytes alignment adjustment */
+    if (0 != (p_dmabuf_phyaddr & DRPAI_64BYTE_ALIGN))
+    {
+        p_dmabuf_vaddr = p_dmabuf_vaddr + (0x40 - (p_dmabuf_phyaddr & DRPAI_64BYTE_ALIGN));
+        p_dmabuf_phyaddr = p_dmabuf_phyaddr + (0x40 - (p_dmabuf_phyaddr & DRPAI_64BYTE_ALIGN));
+    }
+
+/* DRP single operation */
+    /* Deploy drp_single_desc */
+    for (i = 0; i < DRPAI_SEQ_NUM; i++)
+    {
+        memcpy(p_dmabuf_vaddr + (DRPAI_SGL_DRP_DESC_SIZE * i), &drp_single_desc_bin[0], sizeof(drp_single_desc_bin));
+    }
+/* DRP single operation */
+
+    __flush_dcache_area(p_dmabuf_vaddr, DRPAI_CMA_SIZE);
+
+    result = R_DRPAI_SUCCESS;
+
+    goto end;
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return result;
+}
+
+static void drpai_drp_config_uninit(void)
+{
+    struct drpai_priv *priv = drpai_priv;
+    struct device *dev = &priv->pdev->dev;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    dma_free_coherent(dev, DRPAI_CMA_SIZE, p_dmabuf_vaddr, p_dmabuf_phyaddr);
+    DRPAI_DEBUG_PRINT("end.\n");
+}
+
+int drpai_open_k(void)
+{
+    int result = 0;
+    struct drpai_priv *priv = drpai_priv;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+    DRPAI_DEBUG_PRINT("status1:   %d\n", priv->drpai_status.status);
+
+    if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT)))
+    {
+        result = -ETIMEDOUT;
+        DRPAI_DEBUG_PRINT("ETIMEDOUT.\n");
+        goto end;
+    }
+
+    if(likely(1 == refcount_read(&priv->count)))
+    {
+        result = drpai_open_process();
+        if(R_DRPAI_SUCCESS != result)
+        {
+            goto end;
+        }
+    }
+
+    /* Increment reference count */
+    refcount_inc(&priv->count);
+
+    DRPAI_DEBUG_PRINT("status2:%d\n", priv->drpai_status.status);
+
+    DRPAI_DEBUG_WAIT();
+    goto end;
+end:
+    if(-ETIMEDOUT != result)
+    {
+        /* Return semaphore when no ETIMEOUT */
+        up(&priv->sem);
+    }
+
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return result;
+}
+
+int drpai_close_k(void)
+{
+    int result = 0;
+    struct drpai_priv *priv = drpai_priv;
+    unsigned long flags;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+    DRPAI_DEBUG_PRINT("status1:   %d\n", priv->drpai_status.status);
+
+    if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT)))
+    {
+        result = -ETIMEDOUT;
+        DRPAI_DEBUG_PRINT("ETIMEOUT.\n");
+        goto end;
+    }
+
+    /* Check status */
+    spin_lock_irqsave(&priv->lock, flags);
+    if (DRPAI_STATUS_INIT == priv->drpai_status.status)
+    {
+        spin_unlock_irqrestore(&priv->lock, flags);
+        result = -EACCES;
+        DRPAI_DEBUG_PRINT("EACCES.\n");
+        goto end;
+    }
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+    if(2 == refcount_read(&priv->count))
+    {
+        result = drpai_close_process();
+        if(R_DRPAI_SUCCESS != result)
+        {
+            goto end;
+        }
+    }
+
+    /* Decrement referenece count*/
+    refcount_dec(&priv->count);
+
+    DRPAI_DEBUG_PRINT("status2:   %d\n", priv->drpai_status.status);
+
+    DRPAI_DEBUG_WAIT();
+    goto end;
+end:
+    if(-ETIMEDOUT != result)
+    {
+        /* Return semaphore when no ETIMEOUT */
+        up(&priv->sem);
+    }
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return result;
+}
+
+int drpai_start_k(drpai_data_t *arg, void (*isp_finish)(int result))
+{
+    int result = 0;
+    struct drpai_priv *priv = drpai_priv;
+    drpai_data_t *proc_k;
+    unsigned long flags;
+    int i;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT)))
+    {
+        result = -ETIMEDOUT;
+        DRPAI_DEBUG_PRINT("ETIMEOUT.\n");
+        goto end;
+    }
+
+    DRPAI_DEBUG_PRINT("status1:   %d\n", priv->drpai_status.status);
+
+    /* Check H/W Error */
+    spin_lock_irqsave(&priv->lock, flags);
+    if ((DRPAI_ERRINFO_DRP_ERR == priv->drpai_status.err) || (DRPAI_ERRINFO_AIMAC_ERR == priv->drpai_status.err))
+    {
+        spin_unlock_irqrestore(&priv->lock, flags);
+        result = -EIO;
+        DRPAI_DEBUG_PRINT("EIO.\n");
+        goto end;
+    }
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+    /* Check status */
+    spin_lock_irqsave(&priv->lock, flags);
+    if (DRPAI_STATUS_RUN == priv->drpai_status.status)
+    {
+        spin_unlock_irqrestore(&priv->lock, flags);
+        result = -EBUSY;
+        DRPAI_DEBUG_PRINT("EBUSY.\n");
+        goto end;
+    }
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+    /* Check status */
+    spin_lock_irqsave(&priv->lock, flags);
+    if (DRPAI_STATUS_INIT == priv->drpai_status.status)
+    {
+        spin_unlock_irqrestore(&priv->lock, flags);
+        result = -EACCES;
+        DRPAI_DEBUG_PRINT("EACCES.\n");
+        goto end;
+    }
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+    /* Check NULL */
+    if (NULL == isp_finish)
+    {
+        result = -EINVAL;
+        DRPAI_DEBUG_PRINT("EINVAL NULL function pointer.\n");
+        goto end;
+    }
+    /* Referring the call back function info from ISP Lib */
+    priv->isp_finish_loc = isp_finish;
+
+    /* Check NULL */
+    if (NULL == arg)
+    {
+        result = -EINVAL;
+        DRPAI_DEBUG_PRINT("EINVAL NULL argument pointer.\n");
+        goto end;
+    }
+    /* Referring the obj file info from ISP Lib */
+    proc_k = arg;
+
+    spin_lock_irqsave(&priv->lock, flags);
+    odif_intcnto.ch0 = 0;
+    odif_intcnto.ch1 = 0;
+    odif_intcnto.ch2 = 0;
+    odif_intcnto.ch3 = 0;
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+    DRPAI_DEBUG_PRINT("ODIF_INTCNTO0 : 0x%08X\n", odif_intcnto.ch0);
+    DRPAI_DEBUG_PRINT("ODIF_INTCNTO1 : 0x%08X\n", odif_intcnto.ch1);
+    DRPAI_DEBUG_PRINT("ODIF_INTCNTO2 : 0x%08X\n", odif_intcnto.ch2);
+    DRPAI_DEBUG_PRINT("ODIF_INTCNTO3 : 0x%08X\n", odif_intcnto.ch3);
+
+    /* Check Argument 64-byte*/
+    for (i = 0; i < 2; i++)
+    {
+        if (0 != (proc_k[i].address & DRPAI_64BYTE_ALIGN))
+        {
+            result = -EINVAL;
+            DRPAI_DEBUG_PRINT("EINVAL argument. Not 64-byte aligned.\n");
+            goto end;
+        }
+    }
+
+    for (i = 0; i < 1; i++)
+    {
+        /* DRPcfg address and size settings */
+        *(uint32_t*)(p_dmabuf_vaddr + (DRPAI_SGL_DRP_DESC_SIZE * i) + 4) = proc_k[i * 2].address;
+        *(uint32_t*)(p_dmabuf_vaddr + (DRPAI_SGL_DRP_DESC_SIZE * i) + 8) = proc_k[i * 2].size;
+
+        DRPAI_DEBUG_PRINT("cfg_address:0x%08X, cfg_size:0x%08X\n", proc_k[i * 2].address, proc_k[i * 2].size);
+
+        /* DRP param address and size settings */
+        *(uint32_t*)(p_dmabuf_vaddr + (DRPAI_SGL_DRP_DESC_SIZE * i) + 36) = proc_k[i * 2 + 1].address;
+        *(uint32_t*)(p_dmabuf_vaddr + (DRPAI_SGL_DRP_DESC_SIZE * i) + 40) = proc_k[i * 2 + 1].size;
+
+        DRPAI_DEBUG_PRINT("parm_address:0x%08X, parm_size:0x%08X\n", proc_k[i * 2 + 1].address, proc_k[i * 2 + 1].size);
+
+    }
+    __flush_dcache_area(p_dmabuf_vaddr, DRPAI_CMA_SIZE);
+
+    spin_lock_irqsave(&priv->lock, flags);
+    /* Init drpai_status.err */
+    priv->drpai_status.err = DRPAI_ERRINFO_SUCCESS;
+
+    /* IDLE -> RUN */
+    priv->drpai_status.status = DRPAI_STATUS_RUN;
+    DRPAI_DEBUG_PRINT("status2:   %d\n", priv->drpai_status.status);
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+    /* Kick */
+    (void)R_DRPAI_DRP_Start(drp_base_addr[0], 0, p_dmabuf_phyaddr);
+    (void)R_DRPAI_AIMAC_Start(aimac_base_address[0], 0, p_dmabuf_phyaddr + (DRPAI_SGL_DRP_DESC_SIZE * DRPAI_SEQ_NUM), &priv->lock);
+
+    DRPAI_DEBUG_WAIT();
+    goto end;
+end:
+    if(-ETIMEDOUT != result)
+    {
+        /* Return semaphore when no ETIMEOUT */
+        up(&priv->sem);
+    }
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return result;
+}
+
+/* Public to Kernel space */
+EXPORT_SYMBOL(drpai_open_k);
+EXPORT_SYMBOL(drpai_close_k);
+EXPORT_SYMBOL(drpai_start_k);
+/* ISP */
+#endif
+
+static long drpai_ioctl_read_drp_reg(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    long result = 0;
+    drpai_reg_t drpai_reg;
+    int32_t ret;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    /* Check NULL */
+    if (0 == arg)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    if (copy_from_user(&drpai_reg, (void __user *)arg, sizeof(drpai_reg_t)))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+
+    if ((drp_size - sizeof(uint32_t)) < drpai_reg.offset)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    ret = R_DRPAI_DRP_RegRead(drp_base_addr[0], drpai_reg.offset, &drpai_reg.value);
+    if (R_DRPAI_SUCCESS != ret)
+    {
+        result = -EFAULT;
+        goto end;
+    }
+
+    if (copy_to_user((void __user *)arg, &drpai_reg, sizeof(drpai_reg_t)))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+
+    goto end;
+
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
+    return result;
+}
+
+static long drpai_ioctl_write_drp_reg(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    long result = 0;
+    drpai_reg_t drpai_reg;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    /* Check NULL */
+    if (0 == arg)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    if (copy_from_user(&drpai_reg, (void __user *)arg, sizeof(drpai_reg_t)))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+
+    if ((drp_size - sizeof(uint32_t)) < drpai_reg.offset)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    R_DRPAI_DRP_RegWrite(drp_base_addr[0], drpai_reg.offset, drpai_reg.value);
+
+    goto end;
+
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
+    return result;
+}
+
+static long drpai_ioctl_read_drpai_reg(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    long result = 0;
+    drpai_reg_t drpai_reg;
+    int32_t ret;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    /* Check NULL */
+    if (0 == arg)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    if (copy_from_user(&drpai_reg, (void __user *)arg, sizeof(drpai_reg_t)))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+
+    if ((aimac_size - sizeof(uint32_t)) < drpai_reg.offset)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    ret = R_DRPAI_AIMAC_RegRead(aimac_base_address[0], drpai_reg.offset, &drpai_reg.value);
+    if (R_DRPAI_SUCCESS != ret)
+    {
+        result = -EFAULT;
+        goto end;
+    }
+
+    if (copy_to_user((void __user *)arg, &drpai_reg, sizeof(drpai_reg_t)))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+
+    goto end;
+
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
+    return result;
+}
+
+static long drpai_ioctl_write_drpai_reg(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    long result = 0;
+    drpai_reg_t drpai_reg;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    /* Check NULL */
+    if (0 == arg)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    if (copy_from_user(&drpai_reg, (void __user *)arg, sizeof(drpai_reg_t)))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+
+    if ((aimac_size - sizeof(uint32_t)) < drpai_reg.offset)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    R_DRPAI_AIMAC_RegWrite(aimac_base_address[0], drpai_reg.offset, drpai_reg.value);
+
+    goto end;
+
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
+    return result;
+}
+
+static long drpai_ioctl_read_cpg_reg(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+#if 1 /* for CPG direct access (preliminary) */
+    long result = 0;
+    drpai_reg_t drpai_reg;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    /* Check NULL */
+    if (0 == arg)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    if (copy_from_user(&drpai_reg, (void __user *)arg, sizeof(drpai_reg_t)))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+
+    if ((cpg_size - sizeof(uint32_t)) < drpai_reg.offset)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    drpai_reg.value = ioread32(cpg_base_address + drpai_reg.offset);
+
+    if (copy_to_user((void __user *)arg, &drpai_reg, sizeof(drpai_reg_t)))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+
+    goto end;
+
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
+    return result;
+#else
+    return -ENOENT;
+#endif
+}
+
+static long drpai_ioctl_write_cpg_reg(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+#if 1 /* for CPG direct access (preliminary) */
+    long result = 0;
+    drpai_reg_t drpai_reg;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    /* Check NULL */
+    if (0 == arg)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    if (copy_from_user(&drpai_reg, (void __user *)arg, sizeof(drpai_reg_t)))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+
+    if ((cpg_size - sizeof(uint32_t)) < drpai_reg.offset)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    iowrite32(drpai_reg.value, cpg_base_address + drpai_reg.offset);
+
+    goto end;
+
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
+    return result;
+#else
+    return -ENOENT;
+#endif
+}
+
+module_platform_driver(drpai_platform_driver);
+MODULE_DEVICE_TABLE(of, drpai_match);
+
+#if 1
+/* V2H conditional compilation */
+MODULE_DESCRIPTION("RZ/V2H DRPAI driver");
+#endif
+MODULE_AUTHOR("Renesas Electronics Corporation");
+MODULE_LICENSE("GPL v2");
diff --git b/drivers/drpai/drpai-reg.h b/drivers/drpai/drpai-reg.h
new file mode 100644
index 0000000..7b3f93e
--- /dev/null
+++ b/drivers/drpai/drpai-reg.h
@@ -0,0 +1,1053 @@
+/*
+ * Driver for the Renesas RZ/V2H DRP-AI unit
+ *
+ * Copyright (C) 2023 Renesas Electronics Corporation
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+//==================================================================================================================
+// DRP-AI
+//==================================================================================================================
+
+#ifndef DRPAI_REG__H
+#define DRPAI_REG__H
+
+#define DRP0_BADDR                  (0x17000000uLL)
+#define DRP1_BADDR                  (0x18000000uLL)
+#define AIMAC0_BADDR                (0x16800000uLL)
+
+//==================================================================================================================
+// BaseAddress
+//==================================================================================================================
+// drp core
+#define DRPCORE_BADDR               (0x00000000uLL)
+#define DRPINIF_BADDR               (0x003FE000uLL)
+#define DRPOUTIF_BADDR              (0x003FE800uLL)
+#define CFGLIF_BADDR                (0x003FF000uLL)
+#define DRP_CDCC_BADDR              (0x003FF800uLL)
+
+// spa4dma
+#define STP_DRPIN_BADDR             (0x00F00000uLL)
+#define STP_DRPOUT_BADDR            (0x00F08000uLL)
+#define STP_CFGL_BADDR              (0x00F10000uLL)
+#define STP_DSCC_BADDR              (0x00F18000uLL)
+#define STP_IDIF_BADDR              (0x00F19000uLL)
+#define STP_ODIF_BADDR              (0x00F1A000uLL)
+#define STP_IDMAC_BADDR             (0x00F1B000uLL)
+#define STP_ODMAC_BADDR             (0x00F1C000uLL)
+#define STP_RAC_BADDR               (0x00F1D000uLL)
+#define STP_STPC_BADDR              (0x00F1D800uLL)
+#define STP_SYNCTBL_BADDR           (0x00F1E000uLL)
+#define STP_ADRCONV_BADDR           (0x00F0C000uLL)
+
+// aimac
+#define EXD0_DRPIN_M_BADDR          (0x00000000uLL)
+#define EXD0_DRPOUT_M_BADDR         (0x00008000uLL)
+#define EXD0_ADRCONV_BADDR          (0x0000C000uLL)
+#define EXD0_DSCC_BADDR             (0x00018000uLL)
+#define EXD0_IDIF_BADDR             (0x00019000uLL)
+#define EXD0_ODIF_BADDR             (0x0001A000uLL)
+#define EXD0_IDMAC_BADDR            (0x0001B000uLL)
+#define EXD0_ODMAC_BADDR            (0x0001C000uLL)
+#define EXD0_RAC_BADDR              (0x0001D000uLL)
+#define EXD0_STPC_BADDR             (0x0001D800uLL)
+#define EXD0_DRPIN_A_BADDR          (0x00020000uLL)
+#define EXD0_DRPOUT_A_BADDR         (0x00030000uLL)
+
+#define EXD1_DRPIN_M_BADDR          (0x00040000uLL)
+#define EXD1_DRPOUT_M_BADDR         (0x00048000uLL)
+#define EXD1_IDIF_BADDR             (0x00059000uLL)
+#define EXD1_ODIF_BADDR             (0x0005A000uLL)
+#define EXD1_IDMAC_BADDR            (0x0005B000uLL)
+#define EXD1_ODMAC_BADDR            (0x0005C000uLL)
+#define EXD1_RAC_BADDR              (0x0005D000uLL)
+#define EXD1_STPC_BADDR             (0x0005D800uLL)
+#define EXD1_DRPIN_A_BADDR          (0x00060000uLL)
+#define EXD1_DRPOUT_A_BADDR         (0x00070000uLL)
+
+#define AID0_DRPIN_BADDR            (0x00100000uLL)
+#define AID0_DSCC_BADDR             (0x00118000uLL)
+#define AID0_IDIF_BADDR             (0x00119000uLL)
+#define AID0_IDIF2_BADDR            (0x0011A000uLL)
+#define AID0_IDMAC_BADDR            (0x0011B000uLL)
+#define AID1_DRPIN_BADDR            (0x000C0000uLL)
+#define AID1_DSCC_BADDR             (0x000D8000uLL)
+#define AID1_IDIF_BADDR             (0x000D9000uLL)
+#define AID1_IDIF2_BADDR            (0x000DA000uLL)
+#define AID1_IDMAC_BADDR            (0x000DB000uLL)
+
+#define AID_AREG_BADDR              (0x0011D800uLL)
+#define CMDSEL_BADDR                (0x00140000uLL)
+#define SYNCTBL_BADDR               (0x00140800uLL)
+#define INTMON_BADR                 (0x00141000uLL)
+#define CLKRSTCON_BADDR             (0x00141800uLL)
+#define MAC4K_BASE_ADDRESS          (0x00180000uLL)
+#define MACCTL_BADDR                (0x001C0000uLL)
+#define MACCTL_DCLK_BADDR           (0x001D0000uLL)
+#define FMBUF_BADDR                 (0x001E0000uLL)
+#define PRAM_BADDR                  (0x00200000uLL)
+
+#define EXD0_ODIF_BASE_ADDRESS      (EXD0_ODIF_BADDR)
+#define EXD1_ODIF_BASE_ADDRESS      (EXD1_ODIF_BADDR)
+#define AID0_IDIF_BASE_ADDRESS      (AID0_IDIF_BADDR)
+#define AID0_IDIF2_BASE_ADDRESS     (AID0_IDIF2_BADDR)
+#define AID1_IDIF_BASE_ADDRESS      (AID1_IDIF_BADDR)
+#define AID1_IDIF2_BASE_ADDRESS     (AID1_IDIF2_BADDR)
+
+//==================================================================================================================
+// AreaSize
+//==================================================================================================================
+// drp core
+#define DRPCORE_AREASIZE            (0x3FE000uLL)
+#define DRPINIF_AREASIZE            (0x000800uLL)
+#define DRPOUTIF_AREASIZE           (0x000800uLL)
+#define CFGLIF_AREASIZE             (0x001000uLL)
+// dmac
+#define DRPIN_M_AREASIZE            (0x002000uLL)
+#define DRPOUT_M_AREASIZE           (0x002000uLL)
+#define CFGL_AREASIZE               (0x008000uLL)
+#define DSCC_AREASIZE               (0x001000uLL)
+#define IDIF_AREASIZE               (0x001000uLL)
+#define ODIF_AREASIZE               (0x001000uLL)
+#define IDMAC_AREASIZE              (0x001000uLL)
+#define ODMAC_AREASIZE              (0x001000uLL)
+#define RAC_AREASIZE                (0x000800uLL)
+#define STPC_AREASIZE               (0x000800uLL)
+#define SYNCTBL_AREASIZE            (0x020000uLL)
+#define DRPIN_A_AREASIZE            (0x010000uLL)
+#define DRPOUT_A_AREASIZE           (0x010000uLL)
+
+// aimac
+#define AID_AREG_AREASIZE           (0x000080uLL)
+#define CMDSEL_AREASIZE             (0x000600uLL)
+#define INTMON_AREASIZE             (0x000010uLL)
+#define CLKRSTCON_AREASIZE          (0x000010uLL)
+//#define PRAM_AREASIZE               (0x201000uLL)
+//#define PRAM_AREASIZE               (0x400000uLL)
+#define PRAM_AREASIZE               (0x1000uLL)
+#define MACCTL_AREASIZE             (0x007200uLL)
+
+//==================================================================================================================
+// Address
+//==================================================================================================================
+
+//------------------------------------------------------------------------------------------------------------------
+// DRP
+//------------------------------------------------------------------------------------------------------------------
+#define DRP_MINDIV                  (0x398000uLL)
+#define DRP_ECC                     (0x398038uLL)
+#define DRP_ERRINT_ENABLE           (0x3B0038uLL)
+#define DRP_CDCC_DBGCTL             (0x3FF830uLL)
+#define DRP_CDCC_CCCTL              (0x3FF804uLL)
+
+#define CDCC_CCE                    ((DRP_CDCC_BADDR) + 0x000uLL)
+#define CDCC_CCCTL                  ((DRP_CDCC_BADDR) + 0x004uLL)
+#define CDCC_CFGFWCTL               ((DRP_CDCC_BADDR) + 0x010uLL)
+#define CDCC_DBGCTL                 ((DRP_CDCC_BADDR) + 0x030uLL)
+#define CDCC_DBGCTL2                ((DRP_CDCC_BADDR) + 0x034uLL)
+#define CDCC_PFCNTCTL               ((DRP_CDCC_BADDR) + 0x040uLL)
+#define CDCC_PFCNTCLR               ((DRP_CDCC_BADDR) + 0x044uLL)
+#define CDCC_PFCNTSEL               ((DRP_CDCC_BADDR) + 0x048uLL)
+#define CDCC_PFCNT0                 ((DRP_CDCC_BADDR) + 0x060uLL)
+#define CDCC_PFCNT1                 ((DRP_CDCC_BADDR) + 0x064uLL)
+#define CDCC_PFCNT2                 ((DRP_CDCC_BADDR) + 0x068uLL)
+#define CDCC_PFCNT3                 ((DRP_CDCC_BADDR) + 0x06cuLL)
+#define CDCC_DBGMON                 ((DRP_CDCC_BADDR) + 0x0c0uLL)
+#define CDCC_ECC_MODE               ((DRP_CDCC_BADDR) + 0x0d0uLL)
+#define CDCC_INT_STATUS             ((DRP_CDCC_BADDR) + 0x0e0uLL)
+#define CDCC_ERR_INT_STATUS         ((DRP_CDCC_BADDR) + 0x0e8uLL)
+#define CDCC_INT_MASK               ((DRP_CDCC_BADDR) + 0x0f0uLL)
+#define CDCC_ERR_INT_MASK           ((DRP_CDCC_BADDR) + 0x0f4uLL)
+#define CDCC_CCINFO0                ((DRP_CDCC_BADDR) + 0x100uLL)
+
+#define DRPCORE_REGCLKSEL           (0x3b0018uLL)
+#define DRPCORE_REGPARITYEN         (0x398038uLL)
+#define DRPCORE_REGCFGMREADEN       (0x398040uLL)
+#define DRPCORE_REGCONFIGEN         (0x398048uLL)
+#define DRPCORE_REGRESET            (0x398010uLL)
+#define DRPCORE_REGPRESET           (0x398050uLL)
+#define DRPCORE_REGRUN              (0x398008uLL)
+#define DRPCORE_REGSTATE            (0x398020uLL)
+#define DRPCORE_REGCLEARCOUNT       (0x398060uLL)
+#define DRPCORE_REGCTRLMASK         (0x3b0000uLL)
+#define DRPCORE_REGCODEAWE          (0x3b0010uLL)
+#define DRPCORE_REGINTMODE          (0x3b0028uLL)
+#define DRPCORE_REGINTMASK          (0x3b0030uLL)
+#define DRPCORE_REGERRINTMASK       (0x3b0038uLL)
+#define DRPCORE_INTSTATUS           (0x3b0040uLL)
+#define DRPCORE_ERRINTSTATUS        (0x3b0048uLL)
+#define DRPCORE_REGCHIPMODE         (0x398030uLL)
+#define DRPCORE_VMEMREG             (0x110000uLL)
+#define DRPCORE_REGMINDIV           (0x398000uLL)
+#define DRPCORE_REGFPRND            (0x398058uLL)
+#define DRPCORE_REGCALCERREN        (0x398078uLL)
+
+#define DRPCORE_STCSTATUS           (0x0f8010uLL)  // StcStatus
+#define DRPCORE_STCSTATUS_10        ((DRPCORE_STCSTATUS) + (10uLL << 6)) // StcStatus(Sel=10)
+#define DRPCORE_STCSTATUS_11        ((DRPCORE_STCSTATUS) + (11uLL << 6)) // StcStatus(Sel=11)
+#define DRPCORE_STCSTATUS_12        ((DRPCORE_STCSTATUS) + (12uLL << 6)) // StcStatus(Sel=12)
+#define DRPCORE_STCSTATUS_26        ((DRPCORE_STCSTATUS) + (26uLL << 6)) // StcStatus(Sel=26)
+#define DRPCORE_STCSTATUS_28        ((DRPCORE_STCSTATUS) + (28uLL << 6)) // StcStatus(Sel=28)
+#define DRPCORE_STCSTATUS_34        ((DRPCORE_STCSTATUS) + (34uLL << 6)) // StcStatus(Sel=34)
+
+#define DRPCORE_STCSTBL             (0x280000uLL)  // StcSTbl
+#define DRPCORE_VMEMIU              (0x000000uLL)  // PeIu+VmemIu
+#define DRPCORE_STCIU               (0x0C0000uLL)  // StcIu
+#define DRPCORE_VMEMRFU             (0x100000uLL)  // PeRfu+VmemRfu
+#define DRPCORE_VMEMVMU             (0x120000uLL)  // VmemVmu
+#define DRPCORE_HMEMHMU             (0x180000uLL)  // Hmu
+
+#define DRPCORE_INSEL_RCSIZE        (0x31C500uLL)  // Dout0W0-3_out
+#define DRPCORE_INSEL_RCADDR        (0x31C504uLL)  // Dout0W4-7_out
+#define DRPCORE_INSEL_RCSTRD        (0x31C508uLL)  // Dout1W2-3_out
+#define DRPCORE_INSEL_RCCMD         (0x31C50CuLL)  // Dout1W4-5_out
+
+#define DRPCORE_OUTSEL_DATA0_L      (0x31C700uLL)  // Dout0E0-3_out
+#define DRPCORE_OUTSEL_DATA0_H      (0x31C704uLL)  // Dout0E4-7_out
+#define DRPCORE_OUTSEL_DATA1_L      (0x31C708uLL)  // Dout1E0-3_out
+#define DRPCORE_OUTSEL_DATA1_H      (0x31C70CuLL)  // Dout1E4-7_out
+#define DRPCORE_OUTSEL_STRB         (0x31C714uLL)  // Dout2E4-5_out
+
+//------------------------------------------------------------------------------------------------------------------
+// DSCC
+//------------------------------------------------------------------------------------------------------------------
+#define DSCC_INT_REG                (0x000uLL)
+#define DSCC_DCTLI0_REG             (0x100uLL)
+#define DSCC_DPFC                   (0x104uLL)
+#define DSCC_DPA_REG                (0x108uLL)
+#define DSCC_DPA2_REG               (0x10CuLL)
+#define DSCC_PAMON_REG              (0x118uLL)
+
+//------------------------------------------------------------------------------------------------------------------
+// IDMACIF
+//------------------------------------------------------------------------------------------------------------------
+#define IDIF_INT_REG                (0x000uLL)
+#define IDIF_INTMSK_REG             (0x004uLL)
+#define IDIF_EINT_REG               (0x008uLL)
+#define IDIF_EINTMSK_REG            (0x00CuLL)
+#define IDIF_EINT_DSC_REG           (0x010uLL)
+#define IDIF_EINTMSK_DSC_REG        (0x014uLL)
+#define IDIF_DMACTLI0_REG           (0x100uLL)
+#define IDIF_DMACTLI1_REG           (0x200uLL)
+#define IDIF_DMACTLI2_REG           (0x300uLL)
+#define IDIF_DMACTLI3_REG           (0x400uLL)
+#define IDIF_DMACTLI4_REG           (0x500uLL)
+#define IDIF_DMACTLI5_REG           (0x600uLL)
+#define IDIF_DMACTLI6_REG           (0x700uLL)
+#define IDIF_DMACTLI7_REG           (0x800uLL)
+#define IDIF_DMACTLCW_REG           (0x900uLL)
+#define IDIF_DMACTLMCMD_REG         (0x300uLL)
+#define IDIF_DMACTPCMD_REG          (0x100uLL)
+
+#define STP_IDIF_INT_REG            ((STP_IDIF_BADDR) + (IDIF_INT_REG))
+#define STP_IDIF_INTMSK_REG         ((STP_IDIF_BADDR) + (IDIF_INTMSK_REG))
+#define STP_IDIF_EINT_REG           ((STP_IDIF_BADDR) + (IDIF_EINT_REG))
+#define STP_IDIF_EINTMSK_REG        ((STP_IDIF_BADDR) + (IDIF_EINTMSK_REG))
+#define STP_IDIF_EINT_DSC_REG       ((STP_IDIF_BADDR) + (IDIF_EINT_DSC_REG))
+#define STP_IDIF_EINTMSK_DSC_REG    ((STP_IDIF_BADDR) + (IDIF_EINTMSK_DSC_REG))
+#define STP_IDIF_DMACTLI0_REG       ((STP_IDIF_BADDR) + (IDIF_DMACTLI0_REG))
+#define STP_IDIF_DMACTLI1_REG       ((STP_IDIF_BADDR) + (IDIF_DMACTLI1_REG))
+#define STP_IDIF_DMACTLI2_REG       ((STP_IDIF_BADDR) + (IDIF_DMACTLI2_REG))
+#define STP_IDIF_DMACTLI3_REG       ((STP_IDIF_BADDR) + (IDIF_DMACTLI3_REG))
+#define STP_IDIF_DMACTLI4_REG       ((STP_IDIF_BADDR) + (IDIF_DMACTLI4_REG))
+#define STP_IDIF_DMACTLI5_REG       ((STP_IDIF_BADDR) + (IDIF_DMACTLI5_REG))
+#define STP_IDIF_DMACTLI6_REG       ((STP_IDIF_BADDR) + (IDIF_DMACTLI6_REG))
+#define STP_IDIF_DMACTLI7_REG       ((STP_IDIF_BADDR) + (IDIF_DMACTLI7_REG))
+#define STP_IDIF_DMACTLCW_REG       ((STP_IDIF_BADDR) + (IDIF_DMACTLCW_REG))
+#define STP_IDIF_DMACTLMCMD_REG     ((STP_IDIF_BADDR) + (IDIF_DMACTLMCMD_REG))
+#define STP_IDIF_DMACTPCMD_REG      ((STP_IDIF_BADDR) + (IDIF_DMACTPCMD_REG))
+
+//------------------------------------------------------------------------------------------------------------------
+// ODMACIF
+//------------------------------------------------------------------------------------------------------------------
+#define ODIF_INT_REG                (0x000uLL)
+#define ODIF_INTMSK_REG             (0x004uLL)
+#define ODIF_EINT_REG               (0x008uLL)
+#define ODIF_EINTMSK_REG            (0x00CuLL)
+#define ODIF_DMACTLO0_REG           (0x100uLL)
+#define ODIF_DMACTLO1_REG           (0x200uLL)
+#define ODIF_DMACTLO2_REG           (0x300uLL)
+#define ODIF_DMACTLO3_REG           (0x400uLL)
+#define ODIF_INTCNTO0_REG           (0x118uLL)
+#define ODIF_INTCNTO1_REG           (0x218uLL)
+#define ODIF_INTCNTO2_REG           (0x318uLL)
+#define ODIF_INTCNTO3_REG           (0x418uLL)
+#define ODIF_INTCNTO4_REG           (0x518uLL)
+#define ODIF_INTCNTO5_REG           (0x618uLL)
+#define ODIF_INTCNTO6_REG           (0x718uLL)
+#define ODIF_INTCNTO7_REG           (0x818uLL)
+#define ODIF_INTCNTCR_REG           (0x918uLL)
+#define ODIF_ELCCTL_REG             (0x060uLL)
+#define ODIF_ELCPLS_REG             (0x064uLL)
+#define ODIF_ELCDBG_REG             (0x070uLL)
+#define ODIF_ELCCNT_REG             (0x074uLL)
+#define ODIF_ELCOUT_REG             (0x078uLL)
+
+#define STP_ODIF_INT_REG            ((STP_ODIF_BADDR) + (ODIF_INT_REG))
+#define STP_ODIF_INTMSK_REG         ((STP_ODIF_BADDR) + (ODIF_INTMSK_REG))
+#define STP_ODIF_EINT_REG           ((STP_ODIF_BADDR) + (ODIF_EINT_REG))
+#define STP_ODIF_EINTMSK_REG        ((STP_ODIF_BADDR) + (ODIF_EINTMSK_REG))
+#define STP_ODIF_DMACTLO0_REG       ((STP_ODIF_BADDR) + (ODIF_DMACTLO0_REG))
+#define STP_ODIF_DMACTLO1_REG       ((STP_ODIF_BADDR) + (ODIF_DMACTLO1_REG))
+#define STP_ODIF_DMACTLO2_REG       ((STP_ODIF_BADDR) + (ODIF_DMACTLO2_REG))
+#define STP_ODIF_DMACTLO3_REG       ((STP_ODIF_BADDR) + (ODIF_DMACTLO3_REG))
+#define STP_ODIF_INTCNTO0_REG       ((STP_ODIF_BADDR) + (ODIF_INTCNTO0_REG))
+#define STP_ODIF_INTCNTO1_REG       ((STP_ODIF_BADDR) + (ODIF_INTCNTO1_REG))
+#define STP_ODIF_INTCNTO2_REG       ((STP_ODIF_BADDR) + (ODIF_INTCNTO2_REG))
+#define STP_ODIF_INTCNTO3_REG       ((STP_ODIF_BADDR) + (ODIF_INTCNTO3_REG))
+#define STP_ODIF_INTCNTO4_REG       ((STP_ODIF_BADDR) + (ODIF_INTCNTO4_REG))
+#define STP_ODIF_INTCNTO5_REG       ((STP_ODIF_BADDR) + (ODIF_INTCNTO5_REG))
+#define STP_ODIF_INTCNTO6_REG       ((STP_ODIF_BADDR) + (ODIF_INTCNTO6_REG))
+#define STP_ODIF_INTCNTO7_REG       ((STP_ODIF_BADDR) + (ODIF_INTCNTO7_REG))
+#define STP_ODIF_INTCNTCR_REG       ((STP_ODIF_BADDR) + (ODIF_INTCNTCR_REG))
+#define STP_ODIF_ELCCTL_REG         ((STP_ODIF_BADDR) + (ODIF_ELCCTL_REG))
+#define STP_ODIF_ELCPLS_REG         ((STP_ODIF_BADDR) + (ODIF_ELCPLS_REG))
+#define STP_ODIF_ELCDBG_REG         ((STP_ODIF_BADDR) + (ODIF_ELCDBG_REG))
+#define STP_ODIF_ELCCNT_REG         ((STP_ODIF_BADDR) + (ODIF_ELCCNT_REG))
+#define STP_ODIF_ELCOUT_REG         ((STP_ODIF_BADDR) + (ODIF_ELCOUT_REG))
+
+#define EXD1_ODIF_INT_REG           ((EXD1_ODIF_BASE_ADDRESS) + (ODIF_INT_REG))
+#define EXD1_ODIF_INTCNTO1_REG      ((EXD1_ODIF_BASE_ADDRESS) + (ODIF_INTCNTO1_REG))
+#define EXD1_ODIF_INTCNTO2_REG      ((EXD1_ODIF_BASE_ADDRESS) + (ODIF_INTCNTO2_REG))
+#define EXD1_ODIF_INTCNTO3_REG      ((EXD1_ODIF_BASE_ADDRESS) + (ODIF_INTCNTO3_REG))
+#define EXD1_ODIF_INTCNTO4_REG      ((EXD1_ODIF_BASE_ADDRESS) + (ODIF_INTCNTO4_REG))
+#define EXD1_ODIF_INTCNTO5_REG      ((EXD1_ODIF_BASE_ADDRESS) + (ODIF_INTCNTO5_REG))
+#define EXD1_ODIF_INTCNTO6_REG      ((EXD1_ODIF_BASE_ADDRESS) + (ODIF_INTCNTO6_REG))
+#define EXD1_ODIF_INTCNTO7_REG      ((EXD1_ODIF_BASE_ADDRESS) + (ODIF_INTCNTO7_REG))
+
+//------------------------------------------------------------------------------------------------------------------
+// IDMAC
+//------------------------------------------------------------------------------------------------------------------
+#define IDMAC_INTME_REG             (0x024uLL)
+
+//------------------------------------------------------------------------------------------------------------------
+// ODMAC
+//------------------------------------------------------------------------------------------------------------------
+#define ODMAC_INTME_REG             (0x024uLL)
+
+//------------------------------------------------------------------------------------------------------------------
+// DRPIN
+//------------------------------------------------------------------------------------------------------------------
+#define DRPIN_DUMMY                 (0x000uLL)
+
+//------------------------------------------------------------------------------------------------------------------
+// STPC
+//------------------------------------------------------------------------------------------------------------------
+#define STPC_SFTRST                 (0x000uLL)
+#define STPC_RSTCON_RST             (0x000uLL) // alias for old version
+#define STPC_INT_STS                (0x004uLL)
+#define STPC_ERRINT_STS             (0x008uLL)
+#define STPC_CLKE                   (0x010uLL)
+#define STPC_CLKGEN_RST             (0x040uLL)
+#define STPC_CLKGEN_STBY            (0x044uLL)
+#define STPC_CLKGEN_DIV             (0x048uLL)
+#define STPC_CLKGEN_STS             (0x04CuLL)
+#define STPC_CLKGEN_BYPASS          (0x050uLL)
+#define STPC_CLKGEN_HDIV            (0x054uLL)
+#define STPC_CLKGEN_DIVLAT          (0x058uLL)
+#define STPC_CLKGEN_STBYWAIT        (0x060uLL)
+#define STPC_CLKSW_CONFIG           (0x064uLL)
+#define STPC_CLKSW_CONFIG2          (0x068uLL)
+#define STPC_CLKSW_ACK              (0x06CuLL)
+#define STPC_PFCNTCTL               (0x080uLL)
+#define STPC_PFCNTCLR               (0x084uLL)
+#define STPC_CNT0                   (0x088uLL)
+#define STPC_CNT1                   (0x08CuLL)
+#define STPC_DRPCMD_MSK             (0x0C0uLL)
+#define STPC_MONI0                  (0x100uLL)
+#define STPC_MONI1                  (0x104uLL)
+#define STPC_MONI2                  (0x108uLL)
+#define STPC_MONI3                  (0x10CuLL)
+#define STPC_CTRLPLS0               (0x110uLL)
+#define STPC_CTRLPLS1               (0x114uLL)
+#define STPC_CTRLPLS2               (0x118uLL)
+#define STPC_CTRLPLS3               (0x11CuLL)
+#define STPC_CTRL0                  (0x120uLL)
+#define STPC_CTRL1                  (0x124uLL)
+#define STPC_CTRL2                  (0x128uLL)
+#define STPC_CTRL3                  (0x12CuLL)
+#define STPC_CLKGEN_CTRL            (0x130uLL)
+
+#define STP_STPC_SFTRST             ((STP_STPC_BADDR) + (STPC_SFTRST))
+#define STP_STPC_RSTCON_RST         ((STP_STPC_BADDR) + (STPC_RSTCON_RST))
+#define STP_STPC_INT_STS            ((STP_STPC_BADDR) + (STPC_INT_STS))
+#define STP_STPC_ERRINT_STS         ((STP_STPC_BADDR) + (STPC_ERRINT_STS))
+#define STP_STPC_CLKE               ((STP_STPC_BADDR) + (STPC_CLKE))
+#define STP_STPC_CLKGEN_RST         ((STP_STPC_BADDR) + (STPC_CLKGEN_RST))
+#define STP_STPC_CLKGEN_STBY        ((STP_STPC_BADDR) + (STPC_CLKGEN_STBY))
+#define STP_STPC_CLKGEN_DIV         ((STP_STPC_BADDR) + (STPC_CLKGEN_DIV))
+#define STP_STPC_CLKGEN_STS         ((STP_STPC_BADDR) + (STPC_CLKGEN_STS))
+#define STP_STPC_CLKGEN_BYPASS      ((STP_STPC_BADDR) + (STPC_CLKGEN_BYPASS))
+#define STP_STPC_CLKGEN_HDIV        ((STP_STPC_BADDR) + (STPC_CLKGEN_HDIV))
+#define STP_STPC_CLKGEN_DIVLAT      ((STP_STPC_BADDR) + (STPC_CLKGEN_DIVLAT))
+#define STP_STPC_CLKGEN_STBYWAIT    ((STP_STPC_BADDR) + (STPC_CLKGEN_STBYWAIT))
+#define STP_STPC_CLKSW_CONFIG       ((STP_STPC_BADDR) + (STPC_CLKSW_CONFIG))
+#define STP_STPC_CLKSW_CONFIG2      ((STP_STPC_BADDR) + (STPC_CLKSW_CONFIG2))
+#define STP_STPC_CLKSW_ACK          ((STP_STPC_BADDR) + (STPC_CLKSW_ACK))
+#define STP_STPC_PFCNTCTL           ((STP_STPC_BADDR) + (STPC_PFCNTCTL))
+#define STP_STPC_PFCNTCLR           ((STP_STPC_BADDR) + (STPC_PFCNTCLR))
+#define STP_STPC_CNT0               ((STP_STPC_BADDR) + (STPC_CNT0))
+#define STP_STPC_CNT1               ((STP_STPC_BADDR) + (STPC_CNT1))
+#define STP_STPC_DRPCMD_MSK         ((STP_STPC_BADDR) + (STPC_DRPCMD_MSK))
+#define STP_STPC_MONI0              ((STP_STPC_BADDR) + (STPC_MONI0))
+#define STP_STPC_MONI1              ((STP_STPC_BADDR) + (STPC_MONI1))
+#define STP_STPC_MONI2              ((STP_STPC_BADDR) + (STPC_MONI2))
+#define STP_STPC_MONI3              ((STP_STPC_BADDR) + (STPC_MONI3))
+#define STP_STPC_CTRLPLS0           ((STP_STPC_BADDR) + (STPC_CTRLPLS0))
+#define STP_STPC_CTRLPLS1           ((STP_STPC_BADDR) + (STPC_CTRLPLS1))
+#define STP_STPC_CTRLPLS2           ((STP_STPC_BADDR) + (STPC_CTRLPLS2))
+#define STP_STPC_CTRLPLS3           ((STP_STPC_BADDR) + (STPC_CTRLPLS3))
+#define STP_STPC_CTRL0              ((STP_STPC_BADDR) + (STPC_CTRL0))
+#define STP_STPC_CTRL1              ((STP_STPC_BADDR) + (STPC_CTRL1))
+#define STP_STPC_CTRL2              ((STP_STPC_BADDR) + (STPC_CTRL2))
+#define STP_STPC_CTRL3              ((STP_STPC_BADDR) + (STPC_CTRL3))
+#define STP_STPC_CLKGEN_CTRL        ((STP_STPC_BADDR) + (STPC_CLKGEN_CTRL))
+
+#define EXD0_STPC_CLKSW_CONFIG      ((EXD0_STPC_BADDR) + (STPC_CLKSW_CONFIG))
+
+//------------------------------------------------------------------------------------------------------------------
+// ADRCONV
+//------------------------------------------------------------------------------------------------------------------
+#define ADRCONV_TBL_EN              (0x1FFCuLL)
+#define ADRCONV_TBL                 (0x2000uLL)
+#define ADRCONV_CTL_REG             (0xDFFCuLL)
+#define ADRCONV_TBLn_REG            (0xE000uLL)
+
+#define STP_ADRCONV_TBL_EN          ((STP_ADRCONV_BADDR) + (ADRCONV_TBL_EN))
+#define STP_ADRCONV_TBL             ((STP_ADRCONV_BADDR) + (ADRCONV_TBL))
+
+#define EXD0_ADRCONV_TBL_EN         ((EXD0_ADRCONV_BADDR) + (ADRCONV_TBL_EN))
+#define EXD0_ADRCONV_TBL            ((EXD0_ADRCONV_BADDR) + (ADRCONV_TBL))
+
+//------------------------------------------------------------------------------------------------------------------
+// SYNC TBL
+//------------------------------------------------------------------------------------------------------------------
+#define STP_STBL_TBL0               ((STP_SYNCTBL_BADDR) + 0x000uLL)
+#define STP_STBL_TBL1               ((STP_SYNCTBL_BADDR) + 0x004uLL)
+#define STP_STBL_TBL2               ((STP_SYNCTBL_BADDR) + 0x008uLL)
+#define STP_STBL_TBL3               ((STP_SYNCTBL_BADDR) + 0x00CuLL)
+#define STP_STBL_TBL4               ((STP_SYNCTBL_BADDR) + 0x010uLL)
+#define STP_STBL_TBL5               ((STP_SYNCTBL_BADDR) + 0x014uLL)
+#define STP_STBL_TBL6               ((STP_SYNCTBL_BADDR) + 0x018uLL)
+#define STP_STBL_TBL7               ((STP_SYNCTBL_BADDR) + 0x01CuLL)
+#define STP_STBL_TBL8               ((STP_SYNCTBL_BADDR) + 0x020uLL)
+#define STP_STBL_TBL9               ((STP_SYNCTBL_BADDR) + 0x024uLL)
+#define STP_STBL_TBL10              ((STP_SYNCTBL_BADDR) + 0x028uLL)
+#define STP_STBL_TBL11              ((STP_SYNCTBL_BADDR) + 0x02CuLL)
+#define STP_STBL_TBL12              ((STP_SYNCTBL_BADDR) + 0x030uLL)
+#define STP_STBL_TBL13              ((STP_SYNCTBL_BADDR) + 0x034uLL)
+#define STP_STBL_TBL14              ((STP_SYNCTBL_BADDR) + 0x038uLL)
+#define STP_STBL_TBL15              ((STP_SYNCTBL_BADDR) + 0x03CuLL)
+#define STP_STBL_TBL16              ((STP_SYNCTBL_BADDR) + 0x040uLL)
+#define STP_STBL_TBL17              ((STP_SYNCTBL_BADDR) + 0x044uLL)
+#define STP_STBL_TBL18              ((STP_SYNCTBL_BADDR) + 0x048uLL)
+#define STP_STBL_TBL19              ((STP_SYNCTBL_BADDR) + 0x04CuLL)
+#define STP_STBL_TBL20              ((STP_SYNCTBL_BADDR) + 0x050uLL)
+#define STP_STBL_TBL21              ((STP_SYNCTBL_BADDR) + 0x054uLL)
+#define STP_STBL_TBL22              ((STP_SYNCTBL_BADDR) + 0x058uLL)
+#define STP_STBL_TBL23              ((STP_SYNCTBL_BADDR) + 0x05CuLL)
+#define STP_STBL_TBL24              ((STP_SYNCTBL_BADDR) + 0x060uLL)
+#define STP_STBL_TBL25              ((STP_SYNCTBL_BADDR) + 0x064uLL)
+#define STP_STBL_TBL26              ((STP_SYNCTBL_BADDR) + 0x068uLL)
+#define STP_STBL_TBL27              ((STP_SYNCTBL_BADDR) + 0x06CuLL)
+#define STP_STBL_TBL28              ((STP_SYNCTBL_BADDR) + 0x070uLL)
+#define STP_STBL_TBL29              ((STP_SYNCTBL_BADDR) + 0x074uLL)
+#define STP_STBL_TBL30              ((STP_SYNCTBL_BADDR) + 0x078uLL)
+#define STP_STBL_TBL31              ((STP_SYNCTBL_BADDR) + 0x07CuLL)
+
+//------------------------------------------------------------------------------------------------------------------
+// CLKRSTCON
+//------------------------------------------------------------------------------------------------------------------
+#define CLKRSTCON_SFTRST_REG        (0x000uLL)
+#define CLKRSTCON_CLKE_REG          (0x008uLL)
+
+//------------------------------------------------------------------------------------------------------------------
+// PRAM
+//------------------------------------------------------------------------------------------------------------------
+#define PRAM_INT                    ((PRAM_BADDR) + 0x00000000uLL)
+#define PRAM_INTMSK                 ((PRAM_BADDR) + 0x00000008uLL)
+#define PRAM_CTRL                   ((PRAM_BADDR) + 0x00000100uLL)
+#define PRAM_STATE0                 ((PRAM_BADDR) + 0x00000110uLL)
+#define PRAM_STATE1                 ((PRAM_BADDR) + 0x00000114uLL)
+#define PRAM_CNT0                   ((PRAM_BADDR) + 0x00000200uLL)
+#define PRAM_CNT1                   ((PRAM_BADDR) + 0x00000204uLL)
+#define PRAM_CNT2                   ((PRAM_BADDR) + 0x00000208uLL)
+#define PRAM_CNT3                   ((PRAM_BADDR) + 0x0000020CuLL)
+#define PRAM_CNT4                   ((PRAM_BADDR) + 0x00000210uLL)
+#define PRAM_CNT5                   ((PRAM_BADDR) + 0x00000214uLL)
+#define PRAM_CNT6                   ((PRAM_BADDR) + 0x00000218uLL)
+#define PRAM_CNT7                   ((PRAM_BADDR) + 0x0000021CuLL)
+#define PRAM_CNTSEL0                ((PRAM_BADDR) + 0x00000220uLL)
+#define PRAM_CNTSEL1                ((PRAM_BADDR) + 0x00000224uLL)
+#define PRAM_CNTSEL2                ((PRAM_BADDR) + 0x00000228uLL)
+#define PRAM_CNTSEL3                ((PRAM_BADDR) + 0x0000022CuLL)
+#define PRAM_CNTSEL4                ((PRAM_BADDR) + 0x00000230uLL)
+#define PRAM_CNTSEL5                ((PRAM_BADDR) + 0x00000234uLL)
+#define PRAM_CNTSEL6                ((PRAM_BADDR) + 0x00000238uLL)
+#define PRAM_CNTSEL7                ((PRAM_BADDR) + 0x0000023CuLL)
+#define PRAM_CNT_EN                 ((PRAM_BADDR) + 0x00000240uLL)
+#define PRAM_CHICKEN                ((PRAM_BADDR) + 0x00000840uLL)
+#define PRAM_DBGCTRL                ((PRAM_BADDR) + 0x00000F00uLL)
+#define PRAM_INFO                   ((PRAM_BADDR) + 0x00000F04uLL)
+#define PRAM_WDINFO                 ((PRAM_BADDR) + 0x00000F10uLL)
+#define PRAM_RDINFO                 ((PRAM_BADDR) + 0x00000F14uLL)
+#define PRAM_FSM                    ((PRAM_BADDR) + 0x00000F30uLL)
+
+//------------------------------------------------------------------------------------------------------------------
+// MACTOP
+//------------------------------------------------------------------------------------------------------------------
+#define MACTOP_MACCTL_INT_STS       ((MACCTL_BADDR) + 0x00000000uLL)
+#define MACTOP_MACCTL_INT_MSK       ((MACCTL_BADDR) + 0x00000004uLL)
+#define MACTOP_MACCTL_ERR_STS       ((MACCTL_BADDR) + 0x00000008uLL)
+#define MACTOP_MACCTL_ERR_MSK       ((MACCTL_BADDR) + 0x0000000CuLL)
+#define MACTOP_MACCTL_SETTING       ((MACCTL_BADDR) + 0x00000400uLL)
+#define MACTOP_MACCTL_ADD_NOP       ((MACCTL_BADDR) + 0x00000410uLL)
+#define MACTOP_MACCTL_FERR_STS      ((MACCTL_BADDR) + 0x00000800uLL)
+#define MACTOP_MACCTL_FERR_LOG1     ((MACCTL_BADDR) + 0x00000900uLL)
+#define MACTOP_MACCTL_FERR_LOG2     ((MACCTL_BADDR) + 0x00000904uLL)
+#define MACTOP_MACCTL_FERR_LOG3     ((MACCTL_BADDR) + 0x00000908uLL)
+#define MACTOP_MACCTL_STS0_0        ((MACCTL_BADDR) + 0x00001000uLL)
+#define MACTOP_MACCTL_STS0_1        ((MACCTL_BADDR) + 0x00001004uLL)
+#define MACTOP_MACCTL_STS0_2        ((MACCTL_BADDR) + 0x00001008uLL)
+#define MACTOP_MACCTL_STS1_0        ((MACCTL_BADDR) + 0x00001100uLL)
+#define MACTOP_MACCTL_STS1_1        ((MACCTL_BADDR) + 0x00001104uLL)
+#define MACTOP_MACCTL_STS1_2        ((MACCTL_BADDR) + 0x00001108uLL)
+#define MACTOP_MACCTL_STS1_3        ((MACCTL_BADDR) + 0x0000110CuLL)
+#define MACTOP_MACCTL_STS2_0        ((MACCTL_BADDR) + 0x00001180uLL)
+#define MACTOP_MACCTL_STS2_1        ((MACCTL_BADDR) + 0x00001184uLL)
+#define MACTOP_MACCTL_STS2_2        ((MACCTL_BADDR) + 0x00001188uLL)
+#define MACTOP_MACCTL_STS2_3        ((MACCTL_BADDR) + 0x0000118CuLL)
+#define MACTOP_MACCTL_STS2_4        ((MACCTL_BADDR) + 0x00001190uLL)
+#define MACTOP_MACCTL_STS3_0        ((MACCTL_BADDR) + 0x00001200uLL)
+#define MACTOP_MACCTL_STS3_1        ((MACCTL_BADDR) + 0x00001204uLL)
+#define MACTOP_MACCTL_STS3_2        ((MACCTL_BADDR) + 0x00001208uLL)
+#define MACTOP_MACCTL_STS3_3        ((MACCTL_BADDR) + 0x0000120CuLL)
+#define MACTOP_MACCTL_STS3_4        ((MACCTL_BADDR) + 0x00001210uLL)
+#define MACTOP_MACCTL_STS3_5        ((MACCTL_BADDR) + 0x00001214uLL)
+#define MACTOP_MACCTL_STS3_6        ((MACCTL_BADDR) + 0x00001218uLL)
+#define MACTOP_MACCTL_STS3_7        ((MACCTL_BADDR) + 0x0000121CuLL)
+#define MACTOP_MACCTL_STS3_8        ((MACCTL_BADDR) + 0x00001220uLL)
+#define MACTOP_MACCTL_STS3_9        ((MACCTL_BADDR) + 0x00001224uLL)
+#define MACTOP_MACCTL_STS3_10       ((MACCTL_BADDR) + 0x00001228uLL)
+#define MACTOP_MACCTL_STS4_0        ((MACCTL_BADDR) + 0x00001280uLL)
+#define MACTOP_MACCTL_STS4_1        ((MACCTL_BADDR) + 0x00001284uLL)
+#define MACTOP_MACCTL_STS4_2        ((MACCTL_BADDR) + 0x00001288uLL)
+#define MACTOP_MACCTL_STS4_3        ((MACCTL_BADDR) + 0x0000128CuLL)
+#define MACTOP_MACCTL_STS4_4        ((MACCTL_BADDR) + 0x00001290uLL)
+#define MACTOP_MACCTL_STS4_5        ((MACCTL_BADDR) + 0x00001294uLL)
+#define MACTOP_MACCTL_STS4_6        ((MACCTL_BADDR) + 0x00001298uLL)
+#define MACTOP_MACCTL_STS4_7        ((MACCTL_BADDR) + 0x0000129CuLL)
+#define MACTOP_MACCTL_STS4_8        ((MACCTL_BADDR) + 0x000012A0uLL)
+#define MACTOP_MACCTL_STS4_9        ((MACCTL_BADDR) + 0x000012A4uLL)
+#define MACTOP_MACCTL_STS4_10       ((MACCTL_BADDR) + 0x000012A8uLL)
+#define MACTOP_MACCTL_STS5_0        ((MACCTL_BADDR) + 0x00001300uLL)
+#define MACTOP_MACCTL_STS5_1        ((MACCTL_BADDR) + 0x00001304uLL)
+#define MACTOP_MACCTL_STS5_2        ((MACCTL_BADDR) + 0x00001308uLL)
+#define MACTOP_MACCTL_STS5_3        ((MACCTL_BADDR) + 0x0000130CuLL)
+#define MACTOP_MACCTL_STS5_4        ((MACCTL_BADDR) + 0x00001310uLL)
+#define MACTOP_MACCTL_STS5_5        ((MACCTL_BADDR) + 0x00001314uLL)
+#define MACTOP_MACCTL_STS5_6        ((MACCTL_BADDR) + 0x00001318uLL)
+#define MACTOP_MACCTL_STS5_7        ((MACCTL_BADDR) + 0x0000131CuLL)
+#define MACTOP_MACCTL_STS5_8        ((MACCTL_BADDR) + 0x00001320uLL)
+#define MACTOP_MACCTL_STS5_9        ((MACCTL_BADDR) + 0x00001324uLL)
+#define MACTOP_MACCTL_STS5_10       ((MACCTL_BADDR) + 0x00001328uLL)
+#define MACTOP_MACCTL_STS5_11       ((MACCTL_BADDR) + 0x0000132CuLL)
+#define MACTOP_MACCTL_STS5_12       ((MACCTL_BADDR) + 0x00001330uLL)
+#define MACTOP_MACCTL_STS5_13       ((MACCTL_BADDR) + 0x00001334uLL)
+#define MACTOP_MACCTL_STS5_14       ((MACCTL_BADDR) + 0x00001338uLL)
+#define MACTOP_MACCTL_STS5_15       ((MACCTL_BADDR) + 0x0000133CuLL)
+#define MACTOP_MACCTL_STS5_16       ((MACCTL_BADDR) + 0x00001340uLL)
+#define MACTOP_MACCTL_STS5_17       ((MACCTL_BADDR) + 0x00001344uLL)
+#define MACTOP_MACCTL_STS6_0        ((MACCTL_BADDR) + 0x00001380uLL)
+#define MACTOP_MACCTL_STS6_1        ((MACCTL_BADDR) + 0x00001384uLL)
+#define MACTOP_MACCTL_STS6_2        ((MACCTL_BADDR) + 0x00001388uLL)
+#define MACTOP_MACCTL_STS6_3        ((MACCTL_BADDR) + 0x0000138CuLL)
+#define MACTOP_MACCTL_STS6_4        ((MACCTL_BADDR) + 0x00001390uLL)
+#define MACTOP_MACCTL_STS6_5        ((MACCTL_BADDR) + 0x00001394uLL)
+#define MACTOP_MACCTL_STS6_6        ((MACCTL_BADDR) + 0x00001398uLL)
+#define MACTOP_MACCTL_STS6_7        ((MACCTL_BADDR) + 0x0000139CuLL)
+#define MACTOP_MACCTL_STS6_8        ((MACCTL_BADDR) + 0x000013A0uLL)
+#define MACTOP_MACCTL_STS6_9        ((MACCTL_BADDR) + 0x000013A4uLL)
+#define MACTOP_MACCTL_STS6_10       ((MACCTL_BADDR) + 0x000013A8uLL)
+#define MACTOP_MACCTL_STS6_11       ((MACCTL_BADDR) + 0x000013ACuLL)
+#define MACTOP_MACCTL_STS6_12       ((MACCTL_BADDR) + 0x000013B0uLL)
+#define MACTOP_MACCTL_MONITOR1_CTL  ((MACCTL_BADDR) + 0x00001400uLL)
+#define MACTOP_MACCTL_MONITOR2_CTL  ((MACCTL_BADDR) + 0x00001404uLL)
+#define MACTOP_MACCTL_MONITOR1L     ((MACCTL_BADDR) + 0x00001500uLL)
+#define MACTOP_MACCTL_MONITOR1H     ((MACCTL_BADDR) + 0x00001504uLL)
+#define MACTOP_MACCTL_MONITOR2L     ((MACCTL_BADDR) + 0x00001508uLL)
+#define MACTOP_MACCTL_MONITOR2H     ((MACCTL_BADDR) + 0x0000150CuLL)
+#define MACTOP_MACCTL_DBG_LOG_CTL   ((MACCTL_BADDR) + 0x00001700uLL)
+#define MACTOP_MACCTL_DBG_LOG_NUM   ((MACCTL_BADDR) + 0x00001704uLL)
+#define MACTOP_MACCTL_DBG_LOG_RDAT  ((MACCTL_BADDR) + 0x00001708uLL)
+#define MACTOP_MACCTL_DBG_LOG_RSIZE ((MACCTL_BADDR) + 0x0000170CuLL)
+#define MACTOP_MACCTL_DBG_LOG_LID   ((MACCTL_BADDR) + 0x00001710uLL)
+#define MACTOP_MACCTL_DBG_LOG_CID0  ((MACCTL_BADDR) + 0x00001714uLL)
+#define MACTOP_MACCTL_DBG_LOG_CID1  ((MACCTL_BADDR) + 0x00001718uLL)
+
+#define MACTOP_MACCTL_SCNT          ((MACCTL_BADDR) + 0x00001800uLL)
+#define MACTOP_MACCTL_CCNT          ((MACCTL_BADDR) + 0x00001804uLL)
+#define MACTOP_MACCTL_INST_EN       ((MACCTL_BADDR) + 0x00002000uLL)
+#define MACTOP_MACCTL_INST_NUM_M1   ((MACCTL_BADDR) + 0x00002004uLL)
+#define MACTOP_MACCTL_INST_DATA     ((MACCTL_BADDR) + 0x00002100uLL)
+#define MACTOP_MACCTL_BP_MODE       ((MACCTL_BADDR) + 0x00003000uLL)
+#define MACTOP_MACCTL_BP_CTL        ((MACCTL_BADDR) + 0x00003004uLL)
+#define MACTOP_MACCTL_BP_DONE       ((MACCTL_BADDR) + 0x00003008uLL)
+#define MACTOP_MACCTL_BP_CSTART     ((MACCTL_BADDR) + 0x0000300CuLL)
+#define MACTOP_MACCTL_BP_ITR        ((MACCTL_BADDR) + 0x00003010uLL)
+#define MACTOP_MACCTL_BP_INST       ((MACCTL_BADDR) + 0x00003014uLL)
+#define MAC64_0_STATUS_REG_BASE     ((MACCTL_BADDR) + 0x00010000uLL)
+#define MAC64_1_STATUS_REG_BASE     ((MACCTL_BADDR) + 0x00011000uLL)
+#define MAC64_2_STATUS_REG_BASE     ((MACCTL_BADDR) + 0x00012000uLL)
+#define MAC64_3_STATUS_REG_BASE     ((MACCTL_BADDR) + 0x00013000uLL)
+#define MAC64_4_STATUS_REG_BASE     ((MACCTL_BADDR) + 0x00014000uLL)
+#define MAC64_5_STATUS_REG_BASE     ((MACCTL_BADDR) + 0x00015000uLL)
+#define MAC64_6_STATUS_REG_BASE     ((MACCTL_BADDR) + 0x00016000uLL)
+#define MAC64_7_STATUS_REG_BASE     ((MACCTL_BADDR) + 0x00017000uLL)
+#define MAC64_8_STATUS_REG_BASE     ((MACCTL_BADDR) + 0x00018000uLL)
+
+// MACTOP DCLK
+#define DOFIFO0_STS                 ((MACCTL_DCLK_BADDR) + 0x0000F800uLL)
+#define DOFIFO0_RD0_L               ((MACCTL_DCLK_BADDR) + 0x0000F900uLL)
+#define DOFIFO0_RD0_U               ((MACCTL_DCLK_BADDR) + 0x0000F904uLL)
+#define DOFIFO0_RD15_L              ((MACCTL_DCLK_BADDR) + 0x0000F9F0uLL)
+#define DOFIFO0_RD15_U              ((MACCTL_DCLK_BADDR) + 0x0000F9F4uLL)
+#define DOFIFO1_STS                 ((MACCTL_DCLK_BADDR) + 0x0000FA00uLL)
+#define DOFIFO1_RD0_L               ((MACCTL_DCLK_BADDR) + 0x0000FB00uLL)
+#define DOFIFO1_RD0_U               ((MACCTL_DCLK_BADDR) + 0x0000FB04uLL)
+#define DOFIFO1_RD15_L              ((MACCTL_DCLK_BADDR) + 0x0000FBF0uLL)
+#define DOFIFO1_RD15_U              ((MACCTL_DCLK_BADDR) + 0x0000FBF4uLL)
+#define DOFIFO2_STS                 ((MACCTL_DCLK_BADDR) + 0x0000FC00uLL)
+#define DOFIFO2_RD0_L               ((MACCTL_DCLK_BADDR) + 0x0000FD00uLL)
+#define DOFIFO2_RD0_U               ((MACCTL_DCLK_BADDR) + 0x0000FD04uLL)
+#define DOFIFO2_RD15_L              ((MACCTL_DCLK_BADDR) + 0x0000FDF0uLL)
+#define DOFIFO2_RD15_U              ((MACCTL_DCLK_BADDR) + 0x0000FDF4uLL)
+#define DOFIFO3_STS                 ((MACCTL_DCLK_BADDR) + 0x0000FE00uLL)
+#define DOFIFO3_RD0_L               ((MACCTL_DCLK_BADDR) + 0x0000FF00uLL)
+#define DOFIFO3_RD0_U               ((MACCTL_DCLK_BADDR) + 0x0000FF04uLL)
+#define DOFIFO3_RD15_L              ((MACCTL_DCLK_BADDR) + 0x0000FFF0uLL)
+#define DOFIFO3_RD15_U              ((MACCTL_DCLK_BADDR) + 0x0000FFF4uLL)
+
+//MACTOP MCLK
+#define DIFIFO0_STS                 ((MACCTL_BADDR) + 0x00008000uLL)
+#define DIFIFO0_RD0_L               ((MACCTL_BADDR) + 0x00008100uLL)
+#define DIFIFO0_RD0_U               ((MACCTL_BADDR) + 0x00008104uLL)
+#define DIFIFO0_RD15_L              ((MACCTL_BADDR) + 0x000081F0uLL)
+#define DIFIFO0_RD15_U              ((MACCTL_BADDR) + 0x000081F4uLL)
+#define DIFIFO1_STS                 ((MACCTL_BADDR) + 0x00008200uLL)
+#define DIFIFO1_RD0_L               ((MACCTL_BADDR) + 0x00008300uLL)
+#define DIFIFO1_RD0_U               ((MACCTL_BADDR) + 0x00008304uLL)
+#define DIFIFO1_RD15_L              ((MACCTL_BADDR) + 0x000083F0uLL)
+#define DIFIFO1_RD15_U              ((MACCTL_BADDR) + 0x000083F4uLL)
+#define DIFIFO2_STS                 ((MACCTL_BADDR) + 0x00008400uLL)
+#define DIFIFO2_RD0_L               ((MACCTL_BADDR) + 0x00008500uLL)
+#define DIFIFO2_RD0_U               ((MACCTL_BADDR) + 0x00008504uLL)
+#define DIFIFO2_RD15_L              ((MACCTL_BADDR) + 0x000085F0uLL)
+#define DIFIFO2_RD15_U              ((MACCTL_BADDR) + 0x000085F4uLL)
+#define DIFIFO3_STS                 ((MACCTL_BADDR) + 0x00008600uLL)
+#define DIFIFO3_RD0_L               ((MACCTL_BADDR) + 0x00008700uLL)
+#define DIFIFO3_RD0_U               ((MACCTL_BADDR) + 0x00008704uLL)
+#define DIFIFO3_RD15_L              ((MACCTL_BADDR) + 0x000087F0uLL)
+#define DIFIFO3_RD15_U              ((MACCTL_BADDR) + 0x000087F4uLL)
+#define MACCTL_INT_STS              ((MACCTL_BADDR) + 0x00000000uLL)
+#define MACCTL_INT_MSK              ((MACCTL_BADDR) + 0x00000004uLL)
+#define MACCTL_ERR_STS              ((MACCTL_BADDR) + 0x00000008uLL)
+#define MACCTL_ERR_MSK              ((MACCTL_BADDR) + 0x0000000CuLL)
+#define MACCTL_INT_CNT              ((MACCTL_BADDR) + 0x00000100uLL)
+#define MACCTL_ERR_CNT              ((MACCTL_BADDR) + 0x00000104uLL)
+#define MACCTL_SETTING              ((MACCTL_BADDR) + 0x00000400uLL)
+#define MACCTL_ADD_NOP              ((MACCTL_BADDR) + 0x00000410uLL)
+#define MACCTL_EXT_HOLD_PERIOD      ((MACCTL_BADDR) + 0x00000420uLL)
+#define MACCTL_EXT_HOLD_TH          ((MACCTL_BADDR) + 0x00000424uLL)
+#define MACCTL_NZNUM_CLR            ((MACCTL_BADDR) + 0x00000430uLL)
+#define MACCTL_NZNUM_TH             ((MACCTL_BADDR) + 0x00000434uLL)
+#define MACCTL_NZNUM_SET            ((MACCTL_BADDR) + 0x00000438uLL)
+#define MACCTL_PPU_NOP              ((MACCTL_BADDR) + 0x00000440uLL)
+#define MACCTL_WAIT_IM_NUM          ((MACCTL_BADDR) + 0x00000444uLL)
+#define MACCTL_INST_EBL             ((MACCTL_BADDR) + 0x00000450uLL)
+#define MACCTL_MAC_DATA_EBL         ((MACCTL_BADDR) + 0x00000460uLL)
+#define MACCTL_SET_PRAM_TH          ((MACCTL_BADDR) + 0x00000470uLL)
+#define MACCTL_GUARD                ((MACCTL_BADDR) + 0x00000480uLL)
+#define MACCTL_WAIT_IM_READY        ((MACCTL_BADDR) + 0x00000490uLL)
+#define MACCTL_FMA_OP_LIMIT2        ((MACCTL_BADDR) + 0x000004A0uLL)
+#define MACCTL_FERR_STS             ((MACCTL_BADDR) + 0x00000800uLL)
+#define MACCTL_FERR_LOG1            ((MACCTL_BADDR) + 0x00000900uLL)
+#define MACCTL_FERR_LOG2            ((MACCTL_BADDR) + 0x00000904uLL)
+#define MACCTL_FERR_LOG3            ((MACCTL_BADDR) + 0x00000908uLL)
+#define MACCTL_STS0_0               ((MACCTL_BADDR) + 0x00001000uLL)
+#define MACCTL_STS0_1               ((MACCTL_BADDR) + 0x00001004uLL)
+#define MACCTL_STS0_2               ((MACCTL_BADDR) + 0x00001008uLL)
+#define MACCTL_STS1_0               ((MACCTL_BADDR) + 0x00001100uLL)
+#define MACCTL_STS1_1               ((MACCTL_BADDR) + 0x00001104uLL)
+#define MACCTL_STS1_2               ((MACCTL_BADDR) + 0x00001108uLL)
+#define MACCTL_STS1_3               ((MACCTL_BADDR) + 0x0000110CuLL)
+#define MACCTL_STS2_0               ((MACCTL_BADDR) + 0x00001180uLL)
+#define MACCTL_STS2_1               ((MACCTL_BADDR) + 0x00001184uLL)
+#define MACCTL_STS2_2               ((MACCTL_BADDR) + 0x00001188uLL)
+#define MACCTL_STS2_3               ((MACCTL_BADDR) + 0x0000118CuLL)
+#define MACCTL_STS2_4               ((MACCTL_BADDR) + 0x00001190uLL)
+#define MACCTL_STS3_0               ((MACCTL_BADDR) + 0x00001200uLL)
+#define MACCTL_STS3_1               ((MACCTL_BADDR) + 0x00001204uLL)
+#define MACCTL_STS3_2               ((MACCTL_BADDR) + 0x00001208uLL)
+#define MACCTL_STS3_3               ((MACCTL_BADDR) + 0x0000120CuLL)
+#define MACCTL_STS3_4               ((MACCTL_BADDR) + 0x00001210uLL)
+#define MACCTL_STS3_5               ((MACCTL_BADDR) + 0x00001214uLL)
+#define MACCTL_STS3_6               ((MACCTL_BADDR) + 0x00001218uLL)
+#define MACCTL_STS3_7               ((MACCTL_BADDR) + 0x0000121CuLL)
+#define MACCTL_STS3_8               ((MACCTL_BADDR) + 0x00001220uLL)
+#define MACCTL_STS3_9               ((MACCTL_BADDR) + 0x00001224uLL)
+#define MACCTL_STS3_10              ((MACCTL_BADDR) + 0x00001228uLL)
+#define MACCTL_STS4_0               ((MACCTL_BADDR) + 0x00001280uLL)
+#define MACCTL_STS4_1               ((MACCTL_BADDR) + 0x00001284uLL)
+#define MACCTL_STS4_2               ((MACCTL_BADDR) + 0x00001288uLL)
+#define MACCTL_STS4_3               ((MACCTL_BADDR) + 0x0000128CuLL)
+#define MACCTL_STS4_4               ((MACCTL_BADDR) + 0x00001290uLL)
+#define MACCTL_STS4_5               ((MACCTL_BADDR) + 0x00001294uLL)
+#define MACCTL_STS4_6               ((MACCTL_BADDR) + 0x00001298uLL)
+#define MACCTL_STS4_7               ((MACCTL_BADDR) + 0x0000129CuLL)
+#define MACCTL_STS4_8               ((MACCTL_BADDR) + 0x000012A0uLL)
+#define MACCTL_STS4_9               ((MACCTL_BADDR) + 0x000012A4uLL)
+#define MACCTL_STS4_10              ((MACCTL_BADDR) + 0x000012A8uLL)
+#define MACCTL_STS5_0               ((MACCTL_BADDR) + 0x00001300uLL)
+#define MACCTL_STS5_1               ((MACCTL_BADDR) + 0x00001304uLL)
+#define MACCTL_STS5_2               ((MACCTL_BADDR) + 0x00001308uLL)
+#define MACCTL_STS5_3               ((MACCTL_BADDR) + 0x0000130CuLL)
+#define MACCTL_STS5_4               ((MACCTL_BADDR) + 0x00001310uLL)
+#define MACCTL_STS5_5               ((MACCTL_BADDR) + 0x00001314uLL)
+#define MACCTL_STS5_6               ((MACCTL_BADDR) + 0x00001318uLL)
+#define MACCTL_STS5_7               ((MACCTL_BADDR) + 0x0000131CuLL)
+#define MACCTL_STS5_8               ((MACCTL_BADDR) + 0x00001320uLL)
+#define MACCTL_STS5_9               ((MACCTL_BADDR) + 0x00001324uLL)
+#define MACCTL_STS5_10              ((MACCTL_BADDR) + 0x00001328uLL)
+#define MACCTL_STS5_11              ((MACCTL_BADDR) + 0x0000132CuLL)
+#define MACCTL_STS5_12              ((MACCTL_BADDR) + 0x00001330uLL)
+#define MACCTL_STS5_13              ((MACCTL_BADDR) + 0x00001334uLL)
+#define MACCTL_STS5_14              ((MACCTL_BADDR) + 0x00001338uLL)
+#define MACCTL_STS5_15              ((MACCTL_BADDR) + 0x0000133CuLL)
+#define MACCTL_STS5_16              ((MACCTL_BADDR) + 0x00001340uLL)
+#define MACCTL_STS5_17              ((MACCTL_BADDR) + 0x00001344uLL)
+#define MACCTL_STS6_0               ((MACCTL_BADDR) + 0x00001380uLL)
+#define MACCTL_STS6_1               ((MACCTL_BADDR) + 0x00001384uLL)
+#define MACCTL_STS6_2               ((MACCTL_BADDR) + 0x00001388uLL)
+#define MACCTL_STS6_3               ((MACCTL_BADDR) + 0x0000138CuLL)
+#define MACCTL_STS6_4               ((MACCTL_BADDR) + 0x00001390uLL)
+#define MACCTL_STS6_5               ((MACCTL_BADDR) + 0x00001394uLL)
+#define MACCTL_STS6_6               ((MACCTL_BADDR) + 0x00001398uLL)
+#define MACCTL_STS6_7               ((MACCTL_BADDR) + 0x0000139CuLL)
+#define MACCTL_STS6_8               ((MACCTL_BADDR) + 0x000013A0uLL)
+#define MACCTL_STS6_9               ((MACCTL_BADDR) + 0x000013A4uLL)
+#define MACCTL_STS6_10              ((MACCTL_BADDR) + 0x000013A8uLL)
+#define MACCTL_STS6_11              ((MACCTL_BADDR) + 0x000013ACuLL)
+#define MACCTL_STS6_12              ((MACCTL_BADDR) + 0x000013B0uLL)
+#define MACCTL_MONITOR1_CTL         ((MACCTL_BADDR) + 0x00001400uLL)
+#define MACCTL_MONITOR2_CTL         ((MACCTL_BADDR) + 0x00001404uLL)
+#define MACCTL_MONITOR1L            ((MACCTL_BADDR) + 0x00001500uLL)
+#define MACCTL_MONITOR1H            ((MACCTL_BADDR) + 0x00001504uLL)
+#define MACCTL_MONITOR2L            ((MACCTL_BADDR) + 0x00001508uLL)
+#define MACCTL_MONITOR2H            ((MACCTL_BADDR) + 0x0000150CuLL)
+#define MACCTL_DBG_LOG_CTL          ((MACCTL_BADDR) + 0x00001700uLL)
+#define MACCTL_DBG_LOG_NUM          ((MACCTL_BADDR) + 0x00001704uLL)
+#define MACCTL_DBG_LOG_RDAT         ((MACCTL_BADDR) + 0x00001708uLL)
+#define MACCTL_SCNT                 ((MACCTL_BADDR) + 0x00001800uLL)
+#define MACCTL_CCNT                 ((MACCTL_BADDR) + 0x00001804uLL)
+#define MACCTL_INST_EN              ((MACCTL_BADDR) + 0x00002000uLL)
+#define MACCTL_INST_NUM_M1          ((MACCTL_BADDR) + 0x00002004uLL)
+#define MACCTL_INST                 ((MACCTL_BADDR) + 0x00002100uLL)
+#define MACCTL_BP_MODE              ((MACCTL_BADDR) + 0x00003000uLL)
+#define MACCTL_BP_CTL               ((MACCTL_BADDR) + 0x00003004uLL)
+#define MACCTL_BP_DONE              ((MACCTL_BADDR) + 0x00003008uLL)
+#define MACCTL_BP_CSTART            ((MACCTL_BADDR) + 0x0000300CuLL)
+#define MACCTL_BP_ITR               ((MACCTL_BADDR) + 0x00003010uLL)
+#define MACCTL_BP_INST              ((MACCTL_BADDR) + 0x00003014uLL)
+#define CFIFO_STS                   ((MACCTL_BADDR) + 0x00007000uLL)
+#define CFIFO_RD0_L                 ((MACCTL_BADDR) + 0x00007100uLL)
+#define CFIFO_RD0_LM                ((MACCTL_BADDR) + 0x00007104uLL)
+#define CFIFO_RD0_UM                ((MACCTL_BADDR) + 0x00007108uLL)
+#define CFIFO_RD0_U                 ((MACCTL_BADDR) + 0x0000710CuLL)
+#define CFIFO_RD1_L                 ((MACCTL_BADDR) + 0x00007110uLL)
+#define CFIFO_RD1_LM                ((MACCTL_BADDR) + 0x00007114uLL)
+#define CFIFO_RD1_UM                ((MACCTL_BADDR) + 0x00007118uLL)
+#define CFIFO_RD1_U                 ((MACCTL_BADDR) + 0x0000711CuLL)
+#define CFIFO_RD2_L                 ((MACCTL_BADDR) + 0x00007120uLL)
+#define CFIFO_RD2_LM                ((MACCTL_BADDR) + 0x00007124uLL)
+#define CFIFO_RD2_UM                ((MACCTL_BADDR) + 0x00007128uLL)
+#define CFIFO_RD2_U                 ((MACCTL_BADDR) + 0x0000712CuLL)
+#define CFIFO_RD3_L                 ((MACCTL_BADDR) + 0x00007130uLL)
+#define CFIFO_RD3_LM                ((MACCTL_BADDR) + 0x00007134uLL)
+#define CFIFO_RD3_UM                ((MACCTL_BADDR) + 0x00007138uLL)
+#define CFIFO_RD3_U                 ((MACCTL_BADDR) + 0x0000713CuLL)
+#define CFIFO_RD4_L                 ((MACCTL_BADDR) + 0x00007140uLL)
+#define CFIFO_RD4_LM                ((MACCTL_BADDR) + 0x00007144uLL)
+#define CFIFO_RD4_UM                ((MACCTL_BADDR) + 0x00007148uLL)
+#define CFIFO_RD4_U                 ((MACCTL_BADDR) + 0x0000714CuLL)
+#define CFIFO_RD5_L                 ((MACCTL_BADDR) + 0x00007150uLL)
+#define CFIFO_RD5_LM                ((MACCTL_BADDR) + 0x00007154uLL)
+#define CFIFO_RD5_UM                ((MACCTL_BADDR) + 0x00007158uLL)
+#define CFIFO_RD5_U                 ((MACCTL_BADDR) + 0x0000715CuLL)
+#define CFIFO_RD6_L                 ((MACCTL_BADDR) + 0x00007160uLL)
+#define CFIFO_RD6_LM                ((MACCTL_BADDR) + 0x00007164uLL)
+#define CFIFO_RD6_UM                ((MACCTL_BADDR) + 0x00007168uLL)
+#define CFIFO_RD6_U                 ((MACCTL_BADDR) + 0x0000716CuLL)
+#define CFIFO_RD7_L                 ((MACCTL_BADDR) + 0x00007170uLL)
+#define CFIFO_RD7_LM                ((MACCTL_BADDR) + 0x00007174uLL)
+#define CFIFO_RD7_UM                ((MACCTL_BADDR) + 0x00007178uLL)
+#define CFIFO_RD7_U                 ((MACCTL_BADDR) + 0x0000717CuLL)
+#define CFIFO_RD8_L                 ((MACCTL_BADDR) + 0x00007180uLL)
+#define CFIFO_RD8_LM                ((MACCTL_BADDR) + 0x00007184uLL)
+#define CFIFO_RD8_UM                ((MACCTL_BADDR) + 0x00007188uLL)
+#define CFIFO_RD8_U                 ((MACCTL_BADDR) + 0x0000718CuLL)
+#define CFIFO_RD9_L                 ((MACCTL_BADDR) + 0x00007190uLL)
+#define CFIFO_RD9_LM                ((MACCTL_BADDR) + 0x00007194uLL)
+#define CFIFO_RD9_UM                ((MACCTL_BADDR) + 0x00007198uLL)
+#define CFIFO_RD9_U                 ((MACCTL_BADDR) + 0x0000719CuLL)
+#define CFIFO_RD10_L                ((MACCTL_BADDR) + 0x000071A0uLL)
+#define CFIFO_RD10_LM               ((MACCTL_BADDR) + 0x000071A4uLL)
+#define CFIFO_RD10_UM               ((MACCTL_BADDR) + 0x000071A8uLL)
+#define CFIFO_RD10_U                ((MACCTL_BADDR) + 0x000071ACuLL)
+#define CFIFO_RD11_L                ((MACCTL_BADDR) + 0x000071B0uLL)
+#define CFIFO_RD11_LM               ((MACCTL_BADDR) + 0x000071B4uLL)
+#define CFIFO_RD11_UM               ((MACCTL_BADDR) + 0x000071B8uLL)
+#define CFIFO_RD11_U                ((MACCTL_BADDR) + 0x000071BCuLL)
+#define CFIFO_RD12_L                ((MACCTL_BADDR) + 0x000071C0uLL)
+#define CFIFO_RD12_LM               ((MACCTL_BADDR) + 0x000071C4uLL)
+#define CFIFO_RD12_UM               ((MACCTL_BADDR) + 0x000071C8uLL)
+#define CFIFO_RD12_U                ((MACCTL_BADDR) + 0x000071CCuLL)
+#define CFIFO_RD13_L                ((MACCTL_BADDR) + 0x000071D0uLL)
+#define CFIFO_RD13_LM               ((MACCTL_BADDR) + 0x000071D4uLL)
+#define CFIFO_RD13_UM               ((MACCTL_BADDR) + 0x000071D8uLL)
+#define CFIFO_RD13_U                ((MACCTL_BADDR) + 0x000071DCuLL)
+#define CFIFO_RD14_L                ((MACCTL_BADDR) + 0x000071E0uLL)
+#define CFIFO_RD14_LM               ((MACCTL_BADDR) + 0x000071E4uLL)
+#define CFIFO_RD14_UM               ((MACCTL_BADDR) + 0x000071E8uLL)
+#define CFIFO_RD14_U                ((MACCTL_BADDR) + 0x000071ECuLL)
+#define CFIFO_RD15_L                ((MACCTL_BADDR) + 0x000071F0uLL)
+#define CFIFO_RD15_LM               ((MACCTL_BADDR) + 0x000071F4uLL)
+#define CFIFO_RD15_UM               ((MACCTL_BADDR) + 0x000071F8uLL)
+#define CFIFO_RD15_U                ((MACCTL_BADDR) + 0x000071FCuLL)
+
+//------------------------------------------------------------------------------------------------------------------
+// MAC64 (stp/b1top/env/bench/v/reg_address_mac4k.v)
+//------------------------------------------------------------------------------------------------------------------
+#define MAC64_0_BASE_ADDRESS        ((MAC4K_BASE_ADDRESS) + 0x000000uLL)
+#define MAC64_1_BASE_ADDRESS        ((MAC4K_BASE_ADDRESS) + 0x001000uLL)
+#define MAC64_2_BASE_ADDRESS        ((MAC4K_BASE_ADDRESS) + 0x002000uLL)
+#define MAC64_3_BASE_ADDRESS        ((MAC4K_BASE_ADDRESS) + 0x003000uLL)
+#define MAC64_4_BASE_ADDRESS        ((MAC4K_BASE_ADDRESS) + 0x004000uLL)
+#define MAC64_5_BASE_ADDRESS        ((MAC4K_BASE_ADDRESS) + 0x005000uLL)
+#define MAC64_6_BASE_ADDRESS        ((MAC4K_BASE_ADDRESS) + 0x006000uLL)
+#define MAC64_7_BASE_ADDRESS        ((MAC4K_BASE_ADDRESS) + 0x007000uLL)
+#define MAC64_8_BASE_ADDRESS        ((MAC4K_BASE_ADDRESS) + 0x008000uLL)
+#define MAC64_9_BASE_ADDRESS        ((MAC4K_BASE_ADDRESS) + 0x009000uLL)
+#define MAC64_10_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x00A000uLL)
+#define MAC64_11_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x00B000uLL)
+#define MAC64_12_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x00C000uLL)
+#define MAC64_13_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x00D000uLL)
+#define MAC64_14_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x00E000uLL)
+#define MAC64_15_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x00F000uLL)
+
+#define MAC64_16_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x010000uLL)
+#define MAC64_17_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x011000uLL)
+#define MAC64_18_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x012000uLL)
+#define MAC64_19_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x013000uLL)
+#define MAC64_20_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x014000uLL)
+#define MAC64_21_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x015000uLL)
+#define MAC64_22_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x016000uLL)
+#define MAC64_23_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x017000uLL)
+#define MAC64_24_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x018000uLL)
+#define MAC64_25_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x019000uLL)
+#define MAC64_26_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x01A000uLL)
+#define MAC64_27_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x01B000uLL)
+#define MAC64_28_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x01C000uLL)
+#define MAC64_29_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x01D000uLL)
+#define MAC64_30_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x01E000uLL)
+#define MAC64_31_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x01F000uLL)
+
+#define MAC64_32_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x020000uLL)
+#define MAC64_33_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x021000uLL)
+#define MAC64_34_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x022000uLL)
+#define MAC64_35_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x023000uLL)
+#define MAC64_36_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x024000uLL)
+#define MAC64_37_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x025000uLL)
+#define MAC64_38_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x026000uLL)
+#define MAC64_39_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x027000uLL)
+#define MAC64_40_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x028000uLL)
+#define MAC64_41_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x029000uLL)
+#define MAC64_42_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x02A000uLL)
+#define MAC64_43_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x02B000uLL)
+#define MAC64_44_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x02C000uLL)
+#define MAC64_45_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x02D000uLL)
+#define MAC64_46_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x02E000uLL)
+#define MAC64_47_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x02F000uLL)
+
+#define MAC64_48_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x030000uLL)
+#define MAC64_49_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x031000uLL)
+#define MAC64_50_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x032000uLL)
+#define MAC64_51_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x033000uLL)
+#define MAC64_52_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x034000uLL)
+#define MAC64_53_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x035000uLL)
+#define MAC64_54_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x036000uLL)
+#define MAC64_55_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x037000uLL)
+#define MAC64_56_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x038000uLL)
+#define MAC64_57_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x039000uLL)
+#define MAC64_58_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x03A000uLL)
+#define MAC64_59_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x03B000uLL)
+#define MAC64_60_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x03C000uLL)
+#define MAC64_61_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x03D000uLL)
+#define MAC64_62_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x03E000uLL)
+#define MAC64_63_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x03F000uLL)
+
+//------------------------------------------------------------------------------------------------------------------
+// FMBUF
+//------------------------------------------------------------------------------------------------------------------
+#define FMBUF_ERR_STS               ((FMBUF_BADDR) + 0x00000000uLL)
+#define FMBUF_ERR_MSK               ((FMBUF_BADDR) + 0x00000004uLL)
+#define FMBUF_FMAP_CTRL             ((FMBUF_BADDR) + 0x00000100uLL)
+#define FMBUF_FMAP_IM_ARB           ((FMBUF_BADDR) + 0x00000104uLL)
+#define FMBUF_EXTIN_CTRL            ((FMBUF_BADDR) + 0x00000118uLL)
+#define FMBUF_EXTOUT_CTRL           ((FMBUF_BADDR) + 0x00000120uLL)
+#define FMBUF_FB_W_INTERVAL0        ((FMBUF_BADDR) + 0x00000130uLL)
+#define FMBUF_FB_W_INTERVAL1        ((FMBUF_BADDR) + 0x00000134uLL)
+#define FMBUF_FB_W_INTERVAL2        ((FMBUF_BADDR) + 0x00000138uLL)
+#define FMBUF_FB_W_INTERVAL3        ((FMBUF_BADDR) + 0x0000013CuLL)
+#define FMBUF_FB_W_INTERVAL4        ((FMBUF_BADDR) + 0x00000140uLL)
+#define FMBUF_FB_W_INTERVAL5        ((FMBUF_BADDR) + 0x00000144uLL)
+#define FMBUF_STS0                  ((FMBUF_BADDR) + 0x00000200uLL)
+#define FMBUF_STS1                  ((FMBUF_BADDR) + 0x00000204uLL)
+#define FMBUF_STS2                  ((FMBUF_BADDR) + 0x00000208uLL)
+#define FMBUF_STS3                  ((FMBUF_BADDR) + 0x0000020CuLL)
+#define FMBUF_STS4                  ((FMBUF_BADDR) + 0x00000210uLL)
+#define FMBUF_STS5                  ((FMBUF_BADDR) + 0x00000214uLL)
+#define FMBUF_STS6                  ((FMBUF_BADDR) + 0x00000218uLL)
+#define FMBUF_DEBUG                 ((FMBUF_BADDR) + 0x00000E00uLL)
+#define FMBUF_CNTER_CLR             ((FMBUF_BADDR) + 0x00000E04uLL)
+#define FMBUF_CNTER_SEL0            ((FMBUF_BADDR) + 0x00000E10uLL)
+#define FMBUF_CNTER_SEL1            ((FMBUF_BADDR) + 0x00000E14uLL)
+#define FMBUF_CNTER_SEL2            ((FMBUF_BADDR) + 0x00000E18uLL)
+#define FMBUF_CNTER_SEL3            ((FMBUF_BADDR) + 0x00000E1CuLL)
+#define FMBUF_CALC_START_CNT        ((FMBUF_BADDR) + 0x00000E20uLL)
+#define FMBUF_TARGET                ((FMBUF_BADDR) + 0x00000E24uLL)
+#define FMBUF_CNT0                  ((FMBUF_BADDR) + 0x00000E30uLL)
+#define FMBUF_CNT1                  ((FMBUF_BADDR) + 0x00000E34uLL)
+#define FMBUF_CNT2                  ((FMBUF_BADDR) + 0x00000E38uLL)
+#define FMBUF_CNT3                  ((FMBUF_BADDR) + 0x00000E3CuLL)
+#define FMBUF_CNT4                  ((FMBUF_BADDR) + 0x00000E40uLL)
+#define FMBUF_CNT5                  ((FMBUF_BADDR) + 0x00000E44uLL)
+#define FMBUF_CNT6                  ((FMBUF_BADDR) + 0x00000E48uLL)
+#define FMBUF_CNT7                  ((FMBUF_BADDR) + 0x00000E4CuLL)
+#define FMBUF_CNT8                  ((FMBUF_BADDR) + 0x00000E50uLL)
+#define FMBUF_CNT9                  ((FMBUF_BADDR) + 0x00000E54uLL)
+#define FMBUF_CNT10                 ((FMBUF_BADDR) + 0x00000E58uLL)
+#define FMBUF_CNT11                 ((FMBUF_BADDR) + 0x00000E5CuLL)
+#define FMBUF_CNT12                 ((FMBUF_BADDR) + 0x00000E60uLL)
+#define FMBUF_CNT13                 ((FMBUF_BADDR) + 0x00000E64uLL)
+#define FMBUF_CNT14                 ((FMBUF_BADDR) + 0x00000E68uLL)
+#define FMBUF_CNT15                 ((FMBUF_BADDR) + 0x00000E6CuLL)
+#define FMBUF_MMON_CTRL             ((FMBUF_BADDR) + 0x00000E80uLL)
+#define FMBUF_MEMLOG                ((FMBUF_BADDR) + 0x00000E84uLL)
+#define FMBUF_CHICKEN0              ((FMBUF_BADDR) + 0x00000F00uLL)
+#define FMBUF_CHICKEN1              ((FMBUF_BADDR) + 0x00000F04uLL)
+#define FMBUF_CLK_CTRL              ((FMBUF_BADDR) + 0x00000F08uLL)
+
+//------------------------------------------------------------------------------------------------------------------
+// AIDMAC
+//------------------------------------------------------------------------------------------------------------------
+#define AID0_IDIF2_INT_REG              ((AID0_IDIF2_BADDR) + 0x000uLL)
+#define AID0_IDIF2_INTMSK_REG           ((AID0_IDIF2_BADDR) + 0x004uLL)
+#define AID0_IDIF2_EINT_REG             ((AID0_IDIF2_BADDR) + 0x008uLL)
+#define AID0_IDIF2_EINTMSK_REG          ((AID0_IDIF2_BADDR) + 0x00CuLL)
+#define AID0_IDIF2_EINT_DSC_REG         ((AID0_IDIF2_BADDR) + 0x010uLL)
+#define AID0_IDIF2_EINTMSK_DSC_REG      ((AID0_IDIF2_BADDR) + 0x014uLL)
+#define AID0_IDIF2_INTMSKSET_REG        ((AID0_IDIF2_BADDR) + 0x020uLL)
+#define AID0_IDIF2_INTMSKCLR_REG        ((AID0_IDIF2_BADDR) + 0x024uLL)
+#define AID0_IDIF2_EINTMSKSET_REG       ((AID0_IDIF2_BADDR) + 0x030uLL)
+#define AID0_IDIF2_EINTMSKCLR_REG       ((AID0_IDIF2_BADDR) + 0x034uLL)
+#define AID0_IDIF2_EINTMSKDSCSET_REG    ((AID0_IDIF2_BADDR) + 0x038uLL)
+#define AID0_IDIF2_EINTMSKDSCCLR_REG    ((AID0_IDIF2_BADDR) + 0x03CuLL)
+
+//------------------------------------------------------------------------------------------------------------------
+// INTMON
+//------------------------------------------------------------------------------------------------------------------
+#define INTM_INT_REG                ((INTMON_BADR) + 0x000uLL)
+#define INTM_ERRINT_REG             ((INTMON_BADR) + 0x008uLL)
+
+//------------------------------------------------------------------------------------------------------------------
+// CPG
+//------------------------------------------------------------------------------------------------------------------
+#define CPG_BADDR                   (0x10420000uLL)
+
+// PLLETH
+#define CPG_PLLETH_STBY_REG         (0x0A0uLL)
+#define CPG_PLLETH_MON_REG          (0x0B0uLL)
+
+// MSTOP
+#define CPG_BUS_8_MSTOP_REG         (0xD1CuLL)     // 0=module operating(initial),1=stopF[8]=AIMAC, [9]=STP, [10]=DRP
+#define CPG_BUS_9_MSTOP_REG         (0xD20uLL)
+
+// BUS
+#define CPG_BUS_12_MSTOP_REG        (0xD2CuLL)
+
+// ACLK dividing ratio setting
+#define CPG_CDDIV2_REG              (0x408uLL)      // PLLCM33_CST400_GEAR dividing ratio setting
+#define CPG_CLKON_1_REG             (0x604uLL)
+#define CPG_CLKON_17_REG            (0x644uLL)      // CLK_ON(0=OFF(initial),1=ON) : [0]=DRP.DCLKIN, [1]=DRP.ACLK, [2]=DRP.INITCLK, [3]=DRPAI.DCLKIN, [4]=DRPAI.ACLK, [5]=DRPAI.INITCLK, [6]=DRPAI.MCLK
+#define CPG_CLKSTATUS0_REG          (0x700uLL)      // PLLCM33_CST400_GEAR status check
+#define CPG_CLKMON_0_REG            (0x800uLL)      // Clock monitor
+#define CPG_CLKMON_8_REG            (0x820uLL)      // Clock monitor
+
+// RESETn
+#define CPG_RST_3_REG               (0x90CuLL)
+#define CPG_RST_4_REG               (0x910uLL)
+#define CPG_RST_15_REG              (0x93CuLL)      // reset control (0=ResetON(initial), 1=OFF):[12]=DRP.ARESETn, [13]=DRPAI.ARESETn)
+#define CPG_RSTMON_1_REG            (0xA04uLL)      // reset monitor
+#define CPG_RSTMON_7_REG            (0xA1CuLL)      // reset monitor
+
+
+//------------------------------------------------------------------------------------------------------------------
+// Error Status Register
+//------------------------------------------------------------------------------------------------------------------
+//[drp error status]
+#define STPC_ERRINT_STS_ADDR        (0x00F1D808uLL)
+#define DRP_ERRINT_STATUS_ADDR      (0x003B0048uLL)
+#define IDIF_EINT_ADDR              (0x00F19008uLL)
+#define IDIF_EINT_DSC_ADDR          (0x00F19010uLL)
+#define ODIF_EINT_ADDR              (0x00F1A008uLL)
+#define IDMAC_INTSE_ADDR            (0x00F1B020uLL)
+#define IDMAC_AERS_ADDR             (0x00F1B030uLL)
+#define ODMAC_INTSE_ADDR            (0x00F1C020uLL)
+#define ODMAC_AERS_ADDR             (0x00F1C030uLL)
+//[aimac error status]
+#define INTMON_ERRINT_ADDR          (0x00141008uLL)
+#define AID0_IDIF_EINT_ADDR         (0x00119008uLL)
+#define AID0_IDIF2_EINT_DSC_ADDR    (0x0011A010uLL)
+#define AID0_IDMAC_INTSE_ADDR       (0x0011B020uLL)
+#define AID0_IDMAC_AERS_ADDR        (0x0011B030uLL)
+#define AID1_IDIF_EINT_ADDR         (0x000D9008uLL)
+#define AID1_IDMAC_INTSE_ADDR       (0x000DB020uLL)
+#define AID1_IDMAC_AERS_ADDR        (0x000DB030uLL)
+#define EXD0_IDIF_EINT_ADDR         (0x00019008uLL)
+#define EXD0_IDIF_DSC_ADDR          (0x00019010uLL)
+#define EXD0_ODIF_EINT_ADDR         (0x0001A008uLL)
+#define EXD0_IDMAC_INTSE_ADDR       (0x0001B020uLL)
+#define EXD0_IDMAC_AERS_ADDR        (0x0001B030uLL)
+#define EXD0_ODMAC_INTSE_ADDR       (0x0001C020uLL)
+#define EXD0_ODMAC_AERS_ADDR        (0x0001C030uLL)
+#define EXD1_IDIF_EINT_ADDR         (0x00059008uLL)
+#define EXD1_ODIF_EINT_ADDR         (0x0005A008uLL)
+#define EXD1_IDMAC_INTSE_ADDR       (0x0005B020uLL)
+#define EXD1_IDMAC_AERS_ADDR        (0x0005B030uLL)
+#define EXD1_ODMAC_INTSE_ADDR       (0x0005C020uLL)
+#define EXD1_ODMAC_AERS_ADDR        (0x0005C030uLL)
+#define PRAM_INT_ADDR               (0x00200000uLL)
+#define FMBUF_ERR_STS_ADDR          (0x001E0000uLL)
+#define MACCTL_ERR_STS_ADDR         (0x001C0008uLL)
+
+#endif /* DRPAI_REG__H */
diff --git b/include/linux/drpai.h b/include/linux/drpai.h
new file mode 100644
index 0000000..8b6cf6b
--- /dev/null
+++ b/include/linux/drpai.h
@@ -0,0 +1,22 @@
+/*
+ * Driver for the Renesas RZ/V2M RZ/V2MA RZ/V2L DRP-AI unit
+ *
+ * Copyright (C) 2021 Renesas Electronics Corporation
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _DRPAI_H
+#define _DRPAI_H
+
+#include <uapi/linux/drpai.h>
+
+#endif /* _DRPAI_H */
diff --git b/include/uapi/linux/drpai.h b/include/uapi/linux/drpai.h
new file mode 100644
index 0000000..62e0d52
--- /dev/null
+++ b/include/uapi/linux/drpai.h
@@ -0,0 +1,148 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+/*
+ * Driver for the Renesas RZ/V2H DRP-AI unit
+ *
+ * Copyright (C) 2023 Renesas Electronics Corporation
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _UAPI__DRPAI_H
+#define _UAPI__DRPAI_H
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#else
+#include <stdint.h>
+#endif
+#include <linux/ioctl.h>
+
+#define DRPAI_IO_TYPE               (46)
+#define DRPAI_ASSIGN                _IOW (DRPAI_IO_TYPE, 0, drpai_data_t)
+#define DRPAI_START                 _IOW (DRPAI_IO_TYPE, 1, drpai_data_t)
+#define DRPAI_RESET                 _IO  (DRPAI_IO_TYPE, 2)
+#define DRPAI_GET_STATUS            _IOR (DRPAI_IO_TYPE, 3, drpai_status_t)
+#define DRPAI_REG_DUMP              _IO  (DRPAI_IO_TYPE, 5)
+#define DRPAI_ASSIGN_PARAM          _IOW (DRPAI_IO_TYPE, 6, drpai_assign_param_t)  /* Since the sturecture size is different,       */
+                                                                                   /* it will be a different ID from DRPAI_SET_SEQ. */
+#define DRPAI_PREPOST_CROP          _IOW (DRPAI_IO_TYPE, 7, drpai_crop_t)
+#define DRPAI_PREPOST_INADDR        _IOW (DRPAI_IO_TYPE, 8, drpai_inout_t)
+#define DRPAI_SET_SEQ               _IOW (DRPAI_IO_TYPE, 6, drpai_seq_t)           /* Since the sturecture size is different,            */
+                                                                                   /* it will be a different ID from DRPAI_ASSIGN_PARAM. */
+#define DRPAI_GET_DRPAI_AREA        _IOR (DRPAI_IO_TYPE, 11, drpai_data_t)
+
+#define DRPAI_SET_DRP_MAX_FREQ      _IOW (DRPAI_IO_TYPE, 12, uint32_t)
+#define DRPAI_SET_DRPAI_FREQ        _IOW (DRPAI_IO_TYPE, 13, uint32_t)
+
+#define DRPAI_SET_ADRCONV           _IOW (DRPAI_IO_TYPE, 14, drpai_adrconv_t)
+#define DRPAI_SET_EXTRA_AREA        _IOW (DRPAI_IO_TYPE, 15, uint32_t)
+
+#define DRPAI_READ_DRP_REG          _IOWR(DRPAI_IO_TYPE, 64, drpai_reg_t)
+#define DRPAI_WRITE_DRP_REG         _IOW (DRPAI_IO_TYPE, 65, drpai_reg_t)
+#define DRPAI_READ_DRPAI_REG        _IOWR(DRPAI_IO_TYPE, 66, drpai_reg_t)
+#define DRPAI_WRITE_DRPAI_REG       _IOW (DRPAI_IO_TYPE, 67, drpai_reg_t)
+#define DRPAI_READ_CPG_REG          _IOWR(DRPAI_IO_TYPE, 68, drpai_reg_t)
+#define DRPAI_WRITE_CPG_REG         _IOW (DRPAI_IO_TYPE, 69, drpai_reg_t)
+
+#define DRPAI_INDEX_NUM                     (10)
+#define DRPAI_INDEX_INPUT                   (0)
+#define DRPAI_INDEX_DRP_DESC                (1)
+#define DRPAI_INDEX_DRP_CFG                 (2)
+#define DRPAI_INDEX_DRP_PARAM               (3)
+#define DRPAI_INDEX_AIMAC_DESC              (4)
+#define DRPAI_INDEX_WEIGHT                  (5)
+#define DRPAI_INDEX_OUTPUT                  (6)
+#define DRPAI_INDEX_AIMAC_CMD               (7)
+#define DRPAI_INDEX_AIMAC_PARAM_DESC        (8)
+#define DRPAI_INDEX_AIMAC_PARAM_CMD         (9)
+#define DRPAI_STATUS_INIT                   (0)
+#define DRPAI_STATUS_IDLE                   (1)
+#define DRPAI_STATUS_RUN                    (2)
+#define DRPAI_ERRINFO_SUCCESS               (0)
+#define DRPAI_ERRINFO_DRP_ERR               (-1)
+#define DRPAI_ERRINFO_AIMAC_ERR             (-2)
+#define DRPAI_ERRINFO_RESET                 (-3)
+#define DRPAI_RESERVED_NUM                  (32)
+#define DRPAI_SEQ_NUM                       (20)
+#define DRPAI_EXE_AI                        (1)
+#define DRPAI_EXE_DRP                       (2)
+#define DRPAI_DRP_NOLOAD                    (0)
+#define DRPAI_MAX_NODE_NAME                 (256)
+#define DRPAI_ADRCONV_MODE_REPLACE          (0)
+#define DRPAI_ADRCONV_MODE_ADD              (1)
+#define DRPAI_ADRCONV_MODE_DISABLE          (0xFF)
+#define DRPAI_ADRCONV_MODE_ALL_CLEAR        (0xFF)
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct drpai_data
+{
+    uint64_t        address;
+    uint64_t        size;
+} drpai_data_t;
+
+typedef struct drpai_status
+{
+    uint32_t        status;
+    int32_t         err;
+    uint32_t        reserved[DRPAI_RESERVED_NUM];
+} drpai_status_t;
+
+typedef struct drpai_assign_param
+{
+    uint32_t        info_size;
+    drpai_data_t    obj;
+} drpai_assign_param_t;
+
+typedef struct drpai_crop
+{
+    uint16_t        img_owidth;
+    uint16_t        img_oheight;
+    uint16_t        pos_x;
+    uint16_t        pos_y;
+    drpai_data_t    obj;
+} drpai_crop_t;
+
+typedef struct drpai_inout
+{
+    char            name[DRPAI_MAX_NODE_NAME];
+    drpai_data_t    data;
+    drpai_data_t    obj;
+} drpai_inout_t;
+
+typedef struct drpai_seq
+{
+    uint32_t        num;
+    uint32_t        order[DRPAI_SEQ_NUM];
+} drpai_seq_t;
+
+typedef struct drpai_adrconv
+{
+    uint32_t        org_address;
+    uint32_t        size;
+    uint64_t        conv_address;
+    uint8_t         mode;
+} drpai_adrconv_t;
+
+typedef struct drpai_reg
+{
+    uint32_t        offset;
+    uint32_t        value;
+} drpai_reg_t;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _UAPI__DRPAI_H */
